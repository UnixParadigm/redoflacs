#!/usr/bin/env bash
#-------------------------------------------------------------------------------
# redoflacs - Parallel BASH commandline FLAC compressor, verifier, organizer,
#             analyzer, and retagger
#-------------------------------------------------------------------------------
# ~ THIS IS THE UNIX/LINUX/BSD VERSION OF REDOFLACS ~
#-------------------------------------------------------------------------------
# Copyright (C) 2010-2013  Jaren Stangret
#-------------------------------------------------------------------------------
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#-------------------------------------------------------------------------------
# You can follow development of this script on Github at:
# https://github.com/sirjaren/redoflacs
#
# Please submit requests/changes/patches and/or comments
#-------------------------------------------------------------------------------
# File Descriptors used in this script:
#    0: STDIN
#    1: STDOUT
#    2: STDERR
#    3: FIFO process manager
#    4: auCDtect's (STDOUT) output
#    5: Number of FLAC files that failed and/or had issues
#    6: Spinner PID
#-------------------------------------------------------------------------------
# .: SCRIPT MESSAGES :.
#-------------------------------------------------------------------------------
# Bold green message
__info () {
	printf " ${green}*${normal} ${@}"
}

# Yellow message
__warn () {
	printf " ${yellow}*${normal} ${@}"
}

# Bold red message
__error () {
	printf " ${red}*${normal} ${@}"
}

# No FLACS found error message
__no_flacs () {
	__error "There are not any FLAC files to process!\n" >&2
}

# Display why COVERART tag should not be used
__coverart_warning () {
	__newline >&2
	__warn "The ${cyan}COVERART${normal} tag is deprecated and should not be\n" >&2
	__warn "used. Instead, consider migrating over to the new format:\n" >&2
	__warn "${cyan}METADATA_BLOCK_PICTURE${normal}, using modern tag editors. Read:\n" >&2
	__warn "${cyan}http://wiki.xiph.org/VorbisComment#Unofficial_COVERART_field_.28deprecated.29${normal}\n" >&2
	__warn "for more details.\n" >&2
}

# Display message that system is missing vital programs
__display_missing_commands_header () {
	__error "You seem to be missing one or more necessary programs\n" >&2
	__error "to run this script reliably.  Below shows the program(s)\n" >&2
	__error "missing, as well as where you can install them from:\n" >&2
}

# Display a lot of help
__long_help () {
long_help=".TH \"REDOFLACS\" 1
.SH NAME
redoflacs \\- Parallel BASH commandline FLAC compressor, verifier, organizer, analyzer, and retagger
.SH SYNOPSIS
.B redoflacs
.RI [operations]
.RI [options]
.RI [target]
.RI ...
.SH DESCRIPTION
redoflacs is a BASH commandline program providing a series of operations
to help manage and verify a user's FLAC music library.  One of the key
features of redoflacs is it's ability to process a great number of FLAC
files in parallel, using as many jobs to complete an operation as
possible, very similar to 'GNU make'.

redoflacs searches for a config file (if run as a user) in:

.br
        \\fB~/.config/redoflacs/config\\fP

.br
or (if run as root) in:

.br
        \\fB/etc/redoflacs.conf\\fP

If a config file is not found (in either place), one is created.

More information can be found at <\\fBhttps://github.com/sirjaren/redoflacs\\fP>.
.SH OPERATIONS
.TP
.BI -c, --compress
Compress the FLAC files with the user-specified level of compression
defined from the configuration file as 'compression_level' and
verify the resultant files.

The default is 8, with the range of values starting from 1 to 8 with
the smallest compression at 1, and the highest at 8.  This option
will add a tag to all successfully verified FLAC files.  Below
shows the default COMPRESSION tag added to each successfully
verified FLAC:

        COMPRESSION=8

If any FLAC files already have the defined compression_level tag (a
good indicator the files are already compressed at that level), the
script will instead test the FLAC files for any errors.  This is
useful to check your entire music library to make sure all the FLAC
files are compressed at the level specified as well as make sure they
are intact.

If any files are found to be corrupt, this script will quit upon
finishing the compression of any other files and produce an error
log.
.TP
.BI -C, --compress-notest
Same as the '--compress' option, but if any FLAC files already have
the defined compression_level tag, the script will skip the file and
continue on to the next without test the FLAC file's integrity.
This is useful for checking all your FLAC files are compressed at the
level specified.
.TP
.BI -t, --test
Same as compress but instead of compressing the FLAC files, this
script just verfies the files.  This option will NOT add the
COMPRESSION tag to the files.

As with the '--compress' option, this will produce an error log if any
FLAC files are found to be corrupt.
.TP
.BI -a, --aucdtect
Uses the auCDtect program by Oleg Berngardt and Alexander Djourik to
analyze FLAC files and check with fairly accurate precision whether
the FLAC files are lossy sourced or not.  For example, an MP3 file
converted to FLAC is no longer lossless therefore lossy sourced.

While this program isn't foolproof, it gives a good idea which FLAC
files will need further investigation (ie a spectrogram).  This
program does not work on FLAC files which have a bit depth more than a
typical audio CD (16bit), and will skip the files that have a higher
bit depth.

If any files are found to not be perfect (100% CDDA), a log will be
created with the questionable FLAC files recorded in it.
.TP
.BI -A, --aucdtect-spectrogram
Same as '-a, --aucdtect' with the addition of creating a spectrogram
for each FLAC file that fails auCDtect, that is, any FLAC file that
does not return 100% CDDA from auCDtect will be scanned and a
spectrogram will be created.

Any FLAC file skipped (due to having a higher bit depth than 16), will
NOT have a spectrogram created.

By default, each spectrogram will be created in the same folder as the
tested FLAC file name as follows:

        [<# of current file processed>] <filename>.png

An example of this:

        FLAC file (7th file processed):
.br
                03 - Some FLAC File.flac

        Spectrogram Image:
.br
                [7] 03 - Some FLAC File.png

The user can change the location of where to store the created
spectrogram images by changing the value of 'spectrogram_location'
defined in the configuration file.  The location defined by the user
will be tested to see if it exists before starting the script.  If
The location does NOT exist, the script will warn the user and exit.

The created PNG file is large in resolution to best capture the FLAC
file's waveform (roughly 1800x513).

The spectrogram is created using the program SoX.  If the user tries
to use this option without having SoX installed, the script will warn
the user that SoX is missing and exit.
.TP
.BI -m, --md5check
Check the FLAC files for unset MD5 Signatures and log the output of
any unset signatures.  An unset MD5 signature doesn't necessarily mean
a FLAC file is corrupt, and can be repaired with a re-encoding of said
FLAC file.
.TP
.BI -p, --prune
Delete every METADATA block in each FLAC file except the STREAMINFO
and VORBIS_COMMENT block.  If 'remove_artwork' is not set as 'true',
defined in the configuration file, then the PICTURE block will NOT be
removed.
.TP
.BI -g, --replaygain
Add ReplayGain tags to the FLAC files.  The ReplayGain is calculated
for ALBUM and TRACK values. ReplayGain is applied via VORBIS_TAGS and
as such, will require the '-r, --retag' argument to have these tags
kept in order to preserve the added ReplayGain values.  The tags
added are:

        REPLAYGAIN_REFERENCE_LOUDNESS
.br
        REPLAYGAIN_TRACK_GAIN
.br
        REPLAYGAIN_TRACK_PEAK
.br
        REPLAYGAIN_ALBUM_GAIN
.br
        REPLAYGAIN_ALBUM_PEAK

This option ignores any ReplayGain tags that may already be set,
removing existing values before applying new ones.

In order for the ReplayGain values to be applied correctly, the script
has to determine which FLAC files to add values by directory.  What
this means is that the script must add the ReplayGain values by
working off the FLAC files' parent directory.  If there are some FLAC
files found, the script will move up one directory and begin applying
the ReplayGain values.  This is necessary in order to get the
REPLAYGAIN_ALBUM_GAIN and REPLAYGAIN_ALBUM_PEAK values set correctly.
Without doing this, the ALBUM and TRACK values would be identical.

If a user has many FLAC files under one directory (of different
albums/artists), the ReplayGain ALBUM values are going to be incorrect
as the script will perceive all those FLAC files to essentially be
from the same album.  This is mitigated by having your music library
somewhat organized with each album housing the correct FLAC files and
no others.  Keep in mind, multi-disc albums must be in separate
folders in order to be processed with different ALBUM GAIN and PEAK
values.

If there are any errors found while creating the ReplayGain values
and/or setting the values, an error log will be produced.
.TP
.BI -G, --replaygain-noforce
Same as '-g, --replaygain' but will check for existing ReplayGain tags
before reapplying new ones.  If any one of the five ReplayGain tags
are missing from any FLAC file, the script will apply new values to
each FLAC file in that folder (first removing the old ReplayGain
tags - if any).

If all five ReplayGain tags are intact in every FLAC file in a
directory, that directory will be skipped and no new ReplayGain tags
will be added.
.TP
.BI -r, --retag
Extract the configured tags in each FLAC file and clear the rest
before retagging the file.  The default tags kept are:

        TITLE
.br
        ARTIST
.br
        ALBUM
.br
        DISCNUMBER
.br
        DATE
.br
        TRACKNUMBER
.br
        TRACKTOTAL
.br
        GENRE
.br
        COMPRESSION
.br
        RELEASETYPE
.br
        SOURCE
.br
        MASTERING
.br
        REPLAYGAIN_REFERENCE_LOUDNESS
.br
        REPLAYGAIN_TRACK_GAIN
.br
        REPLAYGAIN_TRACK_PEAK
.br
        REPLAYGAIN_ALBUM_GAIN
.br
        REPLAYGAIN_ALBUM_PEAK

If any FLAC files have missing tags (from those configured to be
kept), the file and the missing tag will be recorded in a log.

The tags that can be kept are eseentially infinite, as long as the
tags to be kept are set in the TAGGING SECTION of the configuration
file.

If this option is specified, a warning will appear upon script
execution.  This warning will show which of the configured TAG fields
to keep when re-tagging the FLAC files.  A countdown will appear
giving the user 10 seconds to abort the script, after which, the
program will begin running it's course.
.TP
.BI -l, --all
This option is short for:

        -c, --compress
.br
        -m, --md5check
.br
        -p, --prune
.br
        -g, --replaygain
.br
        -r, --retag

If any of these options (or variations of the above options) are
called, this script will warn the user of conflicting options and
exit.
.TP
.BI -L, --reallyall
This option is short for:

        -c, --compress
.br
        -m, --md5check
.br
        -p, --prune
.br
        -g, --replaygain
.br
        -r, --retag
.br
        -A, --aucdtect-spectrogram

If any of these options (or variations of the above options) are
called, this script will warn the user of conflicting options and
exit.
.SH OPTIONS
.TP
.BI -j[N], --jobs[=N]
Set the number of parallel jobs to run on script invocation.  If this
is not set, this script will attempt to find the number of CPU cores
available, using the number found as the number of parallel jobs to
run.

If the script is unable to find the number of CPU cores available, the
number of jobs will be set to two (2) by default.
.TP
.BI -n, --no-color
Turn off color output.
.TP
.BI -o, --new-config
Force the creation of a new configuration file.  This option does _NOT_
overwrite any existing configuration file.
.TP
.BI -v, --version
Display script version and exit.
.TP
.BI -h, --help
Shows this help message.
.SH FILES
.TP
.BI ~/.config/redoflacs/config
User configuration file.
.TP
.BI /etc/redoflacs.conf
System/root configuration file.
.SH BUGS
If you find a bug, please report it at:
<\\fBhttps://github.com/sirjaren/redoflacs/issues/new\\fP>
.SH AUTHOR
Jaren Stangret <sirjaren@gmail.com>
.SH THANKS
Thanks to all the people that provided feedback and support
.br
.SH REVISION
[ 2 ]"

	# Print out help to temporary file which will read by 'man'
	printf "%s\n" "${long_help}" > "${tmp_man_page}"
}

# Display short help
__short_help () {
	printf "%s\n" " Usage: redoflacs [operations] [options] [target] ..."
	printf "%s\n" " Operations:"
	printf "%s\n" "   -c, --compress"
	printf "%s\n" "   -C, --compress-notest"
	printf "%s\n" "   -t, --test"
	printf "%s\n" "   -m, --md5check"
	printf "%s\n" "   -a, --aucdtect"
	printf "%s\n" "   -A, --aucdtect-spectrogram"
	printf "%s\n" "   -p, --prune"
	printf "%s\n" "   -g, --replaygain"
	printf "%s\n" "   -G, --replaygain-noforce"
	printf "%s\n" "   -r, --retag"
	printf "%s\n" "   -l, --all"
	printf "%s\n" "   -L, --reallyall"
	printf "%s\n" " Options:"
	printf "%s\n" "   -j[N], --jobs[=N]"
	printf "%s\n" "   -n, --no-color"
	printf "%s\n" "   -o, --new-config"
	printf "%s\n" "   -v, --version"
	printf "%s\n" "   -h, --help"
	printf "%s\n" " This is the short help; for details use 'redoflacs --help' or 'redoflacs -h'"
}

# Display usage
__usage () {
	printf "%s\n" " Usage: redoflacs [operations] [options] [target] ..."
}
#== .: END SCRIPT MESSAGES :. ==================================================


#-------------------------------------------------------------------------------
# .: LOG MESSAGES :.
#-------------------------------------------------------------------------------
# ReplayGain test error log message
__log_replaygain_test () {
	printf "\033[${lines}H\n"
	__error "There were issues with some of the FLAC files,\n" >&2
	__error "please check:\n" >&2
	__error "${cyan}${replay_test_errors}${normal}\n" >&2
	__error "for details.\n" >&2
}

# ReplayGain process error log message
__log_replaygain_process () {
	printf "\033[${lines}H\n"
	__error "There were issues adding ReplayGain values,\n" >&2
	__error "please check:\n" >&2
	__error "${cyan}${replay_add_errors}${normal}\n" >&2
	__error "for details.\n" >&2
}

# Compress and verify error log message
__log_compress_verify () {
	printf "\033[${lines}H\n"
	__error "Errors found in some FLAC files, please check:\n" >&2
	__error "${cyan}${verify_errors}${normal}\n" >&2
	__error "for errors.\n" >&2
}

# Test error log message
__log_test () {
	printf "\033[${lines}H\n"
	__error "Errors found in some FLAC files, please check:\n" >&2
	__error "${cyan}${test_errors}${normal}\n" >&2
	__error "for errors.\n" >&2
}

# auCDtect error log message
__log_aucdtect () {
	printf "\033[${lines}H\n"
	__error "Some FLAC files may be lossy sourced, please check:\n" >&2
	__error "${cyan}${aucdtect_errors}${normal}\n" >&2
	__error "for details.\n" >&2
}

# MD5 check error log message
__log_md5_check () {
	printf "\033[${lines}H\n"
	__error "The MD5 Signature is unset for some FLAC files or there were\n" >&2
	__error "issues with some of the FLAC files, please check:\n" >&2
	__error "${cyan}${md5_errors}${normal}\n" >&2
	__error "for details.\n" >&2
}

# Missing tags error log message
__log_missing_tags () {
	printf "\033[${lines}H\n"
	__error "Some FLAC files have missing tags or there were\n" >&2
	__error "issues with some of the FLAC files, please check:\n" >&2
	__error "${cyan}${metadata_errors}${normal}\n" >&2
	__error "for details.\n" >&2
}

# Prune error log message
__log_prune () {
	printf "\033[${lines}H\n"
	__error "There were issues with some of the FLAC files,\n" >&2
	__error "please check:\n" >&2
	__error "${cyan}${prune_errors}${normal}\n" >&2
	__error "for details.\n" >&2
}
#== .: END LOG MESSAGES :. =====================================================


#-------------------------------------------------------------------------------
# .: LOG HEADERS :.
#-------------------------------------------------------------------------------
# ReplayGain test header
__header_replaygain_test () {
	# Store header into array to be printed out below
	header_replaygain_test=(
		"################################################################################"
		"#                                                                              #"
		"#                          REPLAYGAIN TEST ERROR LOG                           #"
		"#                          -------------------------                           #"
		"#                                                                              #"
		"#   This report details the errors that may happen when testing FLAC files for #"
		"# ReplayGain compatability.  The only message displayed to your screen that is #"
		"# logged is noted below:                                                       #"
		"#                                                                              #"
		"#     [ Issue ]  :  The FLAC has a sample rate greater than 48kHz and the      #"
		"#                   version of \`flac' installed is NOT greater than 1.2.1.     #"
		"#                                                                              #"
		"#    [ Failed ]  :  The FLAC is unable to have ReplayGain applied to it        #"
		"#                   because the FLAC file turned out to be fake.               #"
		"#                                                                              #"
		"#                          -------------------------                           #"
		"#                                                                              #"
		"#                    The legend for the log file is below:                     #"
		"#                                                                              #"
		"#              FLAC FILE  :  The basename of the FLAC file                     #"
		"#     FLAC FILE LOCATION  :  The path where the FLAC file is located           #"
		"#                  ERROR  :  Message describing what went wrong with the file  #"
		"#                                                                              #"
		"################################################################################"
	)

	# Create array of current log file
	mapfile -n0 -t tmp_log_file < "${replay_test_errors}"

	# Print out log header and log array to log file, truncating old log
	printf "%s\n%s\n" \
		   "${header_replaygain_test[@]}" \
		   "${tmp_log_file[@]}" \
		   > "${replay_test_errors}"
}

# ReplayGain process header
__header_replaygain_process () {
	# Store header into array to be printed out below
	header_replaygain_add=(
		"################################################################################"
		"#                                                                              #"
		"#                          REPLAYGAIN ADD ERROR LOG                            #"
		"#                          ------------------------                            #"
		"#                                                                              #"
		"#   This report details the errors that may happen when applying ReplayGain    #"
		"# values.  The only message displayed to your screen that is logged is noted   #"
		"# below:                                                                       #"
		"#                                                                              #"
		"#    [ Failed ]  :  The directory of FLAC files is unable to have ReplayGain   #"
		"#                   values applied to them most likely because there are files #"
		"#                   with varying sample rates.                                 #"
		"#                                                                              #"
		"#                          ------------------------                            #"
		"#                                                                              #"
		"#                    The legend for the log file is below:                     #"
		"#                                                                              #"
		"#              DIRECTORY  :  Basename of the directory ReplayGain was applied  #"
		"#    FULL DIRECTORY PATH  :  Relative/absolute pathname to directory above     #"
		"#                  ERROR  :  Message describing what went wrong applying       #"
		"#                            applying ReplayGain to directory                  #"
		"#                                                                              #"
		"################################################################################"
	)

	# Create array of current log file
	mapfile -n0 -t tmp_log_file < "${replay_add_errors}"

	# Print out log header and log array to log file, truncating old log
	printf "%s\n%s\n" \
		   "${header_replaygain_add[@]}" \
		   "${tmp_log_file[@]}" \
		   > "${replay_add_errors}"
}

# Compress and verify header
__header_compress_verify () {
	# Store header into array to be printed out below
	header_compress_verify=(
		"################################################################################"
		"#                                                                              #"
		"#                         COMPRESS & VERIFY ERROR LOG                          #"
		"#                         ---------------------------                          #"
		"#                                                                              #"
		"#   This report details the errors that may happen when compressing and/or     #"
		"# verifying FLAC files.  The only message displayed to your screen that is     #"
		"# logged is noted below:                                                       #"
		"#                                                                              #"
		"#    [ Failed ]  :  The FLAC failed verification during compressing or failed  #"
		"#                   during testing.                                            #"
		"#                                                                              #"
		"#                          -------------------------                           #"
		"#                                                                              #"
		"#                    The legend for the log file is below:                     #"
		"#                                                                              #"
		"#              FLAC FILE  :  The basename of the FLAC file                     #"
		"#     FLAC FILE LOCATION  :  The path where the FLAC file is located           #"
		"#                  ERROR  :  Message describing what went wrong with the file  #"
		"#                                                                              #"
		"################################################################################"
	)

	# Create array of current log file
	mapfile -n0 -t tmp_log_file < "${verify_errors}"

	# Print out log header and log array to log file, truncating old log
	printf "%s\n%s\n" \
		   "${header_compress_verify[@]}" \
		   "${tmp_log_file[@]}" \
		   > "${verify_errors}"
}

# Test header
__header_test () {
	# Store header into array to be printed out below
	header_test=(
		"################################################################################"
		"#                                                                              #"
		"#                            TEST FLACS ERROR LOG                              #"
		"#                            --------------------                              #"
		"#   This report details the errors that may happen when testing FLAC files.    #"
		"# The only message displayed to your screen that is logged is noted below:     #"
		"#                                                                              #"
		"#    [ Failed ]  :  The FLAC failed verification during testing                #"
		"#                                                                              #"
		"#                            --------------------                              #"
		"#                                                                              #"
		"#                    The legend for the log file is below:                     #"
		"#                                                                              #"
		"#              FLAC FILE  :  The basename of the FLAC file                     #"
		"#     FLAC FILE LOCATION  :  The path where the FLAC file is located           #"
		"#                  ERROR  :  Message describing what went wrong with the file  #"
		"#                                                                              #"
		"################################################################################"
	)

	# Create array of current log file
	mapfile -n0 -t tmp_log_file < "${test_errors}"

	# Print out log header and log array to log file, truncating old log
	printf "%s\n%s\n" \
		   "${header_test[@]}" \
		   "${tmp_log_file[@]}" \
		   > "${test_errors}"
}

# auCDtect header
__header_aucdtect () {
	# Store header into array to be printed out below
	header_aucdtect=(
		"################################################################################"
		"#                                                                              #"
		"#                          AUCDTECT ERROR/REPORT LOG                           #"
		"#                          -------------------------                           #"
		"#                                                                              #"
		"#   This report details the various types issues that may happen when running  #"
		"# auCDtect.  Depending on the FLAC file, there are different messages that may #"
		"# be displayed to your screen.  The messages that are logged are noted below:  #"
		"#                                                                              #"
		"#     [ Issue ]  :  The FLAC did NOT pass auCDtect's verification with a score #"
		"#                   of 100%.                                                   #"
		"#                                                                              #"
		"#    [ Failed ]  :  The FLAC was unable to be processed by auCDtect, most      #"
		"#                   likely indicating a faulty FLAC.                           #"
		"#                                                                              #"
		"#   [ Skipped ]  :  The FLAC was skipped (not processed by auCDtect) since it  #"
		"#                   has a bit depth greater than 16.  auCDtect only supports   #"
		"#                   CD quality FLAC files (16bit or lower).                    #"
		"#                                                                              #"
		"#                          -------------------------                           #"
		"#                                                                              #"
		"#     The legend for the log file is below (some or all may be displayed):     #"
		"#                                                                              #"
		"#              FLAC FILE  :  The basename of the FLAC file                     #"
		"#                    WAV  :  The basename of the WAV file                      #"
		"#                  ERROR  :  Message describing what went wrong with the file  #"
		"#        AUCDTECT REPORT  :  auCDtect's findings on the FLAC file              #"
		"#     FLAC FILE LOCATION  :  The path where the FLAC file is located           #"
		"#      SPECTROGRAM IMAGE  :  The basename of the created spectrogram           #"
		"#   SPECTROGRAM LOCATION  :  The path where the spectrogram is located         #"
		"#                                                                              #"
		"################################################################################"
	)

	# Create array of current log file
	mapfile -n0 -t tmp_log_file < "${aucdtect_errors}"

	# Print out log header and log array to log file, truncating old log
	printf "%s\n%s\n" \
		   "${header_aucdtect[@]}" \
		   "${tmp_log_file[@]}" \
		   > "${aucdtect_errors}"
}

# MD5 check header
__header_md5_check () {
	# Store header into array to be printed out below
	header_md5_check=(
		"################################################################################"
		"#                                                                              #"
		"#                             MD5 CHECK ERROR LOG                              #"
		"#                             -------------------                              #"
		"#   This report details the errors that may happen when checking a FLAC file's #"
		"# MD5 signature.  The only message displayed to your screen that is logged is  #"
		"# noted below:                                                                 #"
		"#                                                                              #"
		"#    [ Failed ]  :  The MD5 signature could not be checked or the MD5          #"
		"#                   signature is unset, possibly indicating a faulty FLAC      #"
		"#                   file.                                                      #"
		"#                                                                              #"
		"#                             -------------------                              #"
		"#                                                                              #"
		"#                    The legend for the log file is below:                     #"
		"#                                                                              #"
		"#              FLAC FILE  :  The basename of the FLAC file                     #"
		"#     FLAC FILE LOCATION  :  The path where the FLAC file is located           #"
		"#                  ERROR  :  Message describing what went wrong with the file  #"
		"#                                                                              #"
		"################################################################################"
	)

	# Create array of current log file
	mapfile -n0 -t tmp_log_file < "${md5_errors}"

	# Print out log header and log array to log file, truncating old log
	printf "%s\n%s\n" \
		   "${header_md5_check[@]}" \
		   "${tmp_log_file[@]}" \
		   > "${md5_errors}"
}

# Retag header
__header_retag () {
	# Store header into array to be printed out below
	header_retag=(
		"################################################################################"
		"#                                                                              #"
		"#                               RETAG ERROR LOG                                #"
		"#                               ---------------                                #"
		"#   This report details the errors that may happen when retagging a FLAC file. #"
		"# The only message displayed to your screen that is logged is noted below:     #"
		"#                                                                              #"
		"#            [ Failed ]  :  The FLAC file is not a real FLAC file              #"
		"#                                                                              #"
		"#                               ---------------                                #"
		"#                                                                              #"
		"#                    The legend for the log file is below:                     #"
		"#                                                                              #"
		"#              FLAC FILE  :  The basename of the FLAC file                     #"
		"#     FLAC FILE LOCATION  :  The path where the FLAC file is located           #"
		"#                  ERROR  :  Message describing what went wrong with the file  #"
		"#                            or if there were any missing tags                 #"
		"#                                                                              #"
		"################################################################################"
	)

	# Create array of current log file
	mapfile -n0 -t tmp_log_file < "${metadata_errors}"

	# Print out log header and log array to log file, truncating old log
	printf "%s\n%s\n" \
		   "${header_retag[@]}" \
		   "${tmp_log_file[@]}" \
		   > "${metadata_errors}"
}

# Prune header
__header_prune () {
	# Store header into array to be printed out below
	header_prune=(
		"################################################################################"
		"#                                                                              #"
		"#                               PRUNE ERROR LOG                                #"
		"#                               ---------------                                #"
		"#   This report details the errors that may happen when pruning the various    #"
		"# METADATA blocks in a FLAC file.  The only message displayed to your screen   #"
		"# that is logged is noted below:                                               #"
		"#                                                                              #"
		"#            [ Failed ]  :  The FLAC file is not a real FLAC file              #"
		"#                                                                              #"
		"#                               ---------------                                #"
		"#                                                                              #"
		"#                    The legend for the log file is below:                     #"
		"#                                                                              #"
		"#              FLAC FILE  :  The basename of the FLAC file                     #"
		"#     FLAC FILE LOCATION  :  The path where the FLAC file is located           #"
		"#                  ERROR  :  Message describing what went wrong with the file  #"
		"#                                                                              #"
		"################################################################################"
	)

	# Create array of current log file
	mapfile -n0 -t tmp_log_file < "${prune_errors}"

	# Print out log header and log array to log file, truncating old log
	printf "%s\n%s\n" \
		   "${header_prune[@]}" \
		   "${tmp_log_file[@]}" \
		   > "${prune_errors}"
}
#== .: END LOG HEADERS :. ======================================================


#-------------------------------------------------------------------------------
# .: TITLE MESSAGES :.
#-------------------------------------------------------------------------------
# Compress FLACS & verify
__title_compress_flac () {
	# Obtain the current cursor row position
	__obtain_row

	printf "\033[${current_row}H ${green}*${normal} Compressing & Verifying FLAC Files :: ${cyan}[Compression: ${compression_level}]${normal}\n"
}

# Compress FLACS & no verify
__title_compress_notest_flac () {
	# Obtain the current cursor row position
	__obtain_row

	printf "\033[${current_row}H ${green}*${normal} Compressing FLAC Files :: ${cyan}[Compression: ${compression_level}]${normal}\n"
}

# Apply ReplayGain to FLACS
__title_replaygain () {
	# Obtain the current cursor row position
	__obtain_row

	printf "\033[${current_row}H ${green}*${normal} Generating & Applying ReplayGain\n"
}

# Retag FLACS
__title_retag () {
	# Special newline to ensure leftover spinner is hidden
	printf "  \n"

	__info "Retagging FLAC Files\n"
}

# Testing FLACS
__title_testing_flac () {
	# Obtain the current cursor row position
	__obtain_row

	printf "\033[${current_row}H ${green}*${normal} Testing FLAC Files\n"
}

# Validating FLACS with auCDtect
__title_aucdtect_flac () {
	# Obtain the current cursor row position
	__obtain_row

	printf "\033[${current_row}H ${green}*${normal} Validating FLAC Files with auCDtect\n"
}

# Checking MD5 of FLACS
__title_md5check_flac () {
	# Obtain the current cursor row position
	__obtain_row

	printf "\033[${current_row}H ${green}*${normal} Checking MD5 Signature\n"
}

# Pruning FLACS
__title_prune_flac () {
	# Change printed title based on whether embedded artwork is to be removed
	if [[ "${remove_artwork}" != "true" ]] ; then
		# Keep artwork
		local metadata_removed="${cyan}STREAMINFO${normal}, ${cyan}VORBIS_COMMENT${normal} and ${cyan}PICTURE${normal}"
	else
		# Remove artwork
		local metadata_removed="${cyan}STREAMINFO${normal} and ${cyan}VORBIS_COMMENT${normal}"
	fi

	# Obtain the current cursor row position
	__obtain_row

	printf "\033[${current_row}H ${green}*${normal} Pruning blocks except ${metadata_removed}\n"
}
#== .: END TITLE MESSAGES :. ===================================================


#-------------------------------------------------------------------------------
# .: SUB MESSAGES :.
#-------------------------------------------------------------------------------
# Test for ReplayGain
__sub_test_replaygain () {
	# No need to obtain the row, since it's done already after the title message
	printf "\033[${current_row};4H${green}>${normal} Testing ReplayGain\n"
}

# Adding ReplayGain values
__sub_add_replaygain () {
	# Obtain the current row
	__obtain_row

	printf "\033[${current_row};4H${green}>${normal} Adding ReplayGain\n"
}

# Analyze FLAC tags
__sub_analyze_tags () {
	printf "%s${green}%s${normal}%s${normal}%s${normal}\n" \
	"   " ">" " " "Analyze Tags"
}

# Applying new tags
__sub_applying_tags () {
	printf "%s${green}%s${normal}%s${normal}%s${normal}\n" \
	"   " ">" " " "Applying Tags"
}
#== .: END SUB MESSAGES :. =====================================================


#-------------------------------------------------------------------------------
# .: PROCESSED FILE/DIRECTORY MESSAGES :.
#-------------------------------------------------------------------------------
# Print the current FLAC file being operated on
__print_current_flac () {
	# This stores the current file number processed out of the total files:
	#  [56/213]
	number_completed="[${iteration}/${#total_flacs_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  FLACs processed and total FLACs, ie: [56/213]
	#                     11:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (6) Percentage: '  100%' or '    3%'
	max_filename_length="$(( ${columns} - ${#number_completed} - 11 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};9H%s%$(__current_length)s${magenta}%s${normal}" "${filename}" "" "${number_completed}"
}

# Print the current directory being operated on
__print_current_directory () {
	# This stores the current directory number processed out of the total
	# number of directories:
	#  [6/34]
	number_completed="[${iteration}/${#flac_directories_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  Dirs processed and total dirs, ie: [6/34]
	#                     13:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (8) Percentage: '    100%' or '      3%'
	max_filename_length="$(( ${columns} - ${#number_completed} - 13 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};11H%s%$(__current_length)s${magenta}%s${normal}" "${filename}" "" "${number_completed}"
}

# Print the current FLAC file being operated on (for sub messages)
__print_sub_current_flac () {
	# This stores the current file number processed out of the total files:
	#  [56/213]
	number_completed="[${iteration}/${#total_flacs_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  FLACs processed and total FLACs, ie: [56/213]
	#                     11:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (8) Percentage: '  100%' or '    3%'
	max_filename_length="$(( ${columns} - ${#number_completed} - 13 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};11H%s%$(__current_length)s${magenta}%s${normal}" "${filename}" "" "${number_completed}"
}

# Print the current FLAC file being operated on with skip message
__print_skip_flac () {
	# This stores the current file number processed out of the total files:
	#  [56/213]
	number_completed="[${iteration}/${#total_flacs_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  FLACs processed and total FLACs, ie: [56/213]
	#                     11:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (6) Percentage: '100%' or '  3%'
	max_filename_length="$(( ${columns} - ${#number_completed} - 11 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};4H${yellow}skip${normal}%s%$(__current_length)s${magenta}%s${normal}" " ${filename}" "" "${number_completed}"
}

# Tag ok
__print_ok_tag () {
	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#           $(__columns):  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#     total_flacs_length:  Length of the total # of FLAC files
	#                     18:  Length of:
	#                            [ ok ] (6)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( $(__columns) - ${#iteration} - total_flacs_length - 18 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${#total_flacs_array[@]}]" " ${filename} " "" "[" " " "ok" " " "]" " "
}

# Analyzing tags
__print_analyzing_tags () {
	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#           $(__columns):  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#     total_flacs_length:  Length of the total # of FLAC files
	#                     30:  Length of:
	#                            [ Analyzing Tags ] (18)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( $(__columns) - ${#iteration} - total_flacs_length - 30 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r\033[3C${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"  " "[${iteration}/${#total_flacs_array[@]}]" " ${filename} " "" "[" " " "Analyzing Tags" " " "]" " "
}

# Applying tags
__print_applying_tags () {
	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#           $(__columns):  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#     total_flacs_length:  Length of the total # of FLAC files
	#                     29:  Length of:
	#                            [ Applying Tags ] (17)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( $(__columns) - ${#iteration} - total_flacs_length - 29 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r\033[3C${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"  " "[${iteration}/${#total_flacs_array[@]}]" " ${filename} " "" "[" " " "Applying Tags" " " "]" " "
}
# Retag analyze interrupted
__print_retag_analyze_interrupt () {
	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#           $(__columns):  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#     total_flacs_length:  Length of the total # of FLAC files
	#                     27:  Length of:
	#                            [ Interrupted ] (15)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( $(__columns) - ${#iteration} - total_flacs_length - 27 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${#total_flacs_array[@]}]" " ${filename} " "" "[" " " "Interrupted" " " "]" " "
}

# Retag apply interrupted
__print_retag_apply_interrupt () {
	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#           $(__columns):  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#     total_flacs_length:  Length of the total # of FLAC files
	#                     27:  Length of:
	#                            [ Interrupted ] (15)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( $(__columns) - ${#iteration} - total_flacs_length - 27 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${#total_flacs_array[@]}]" " ${filename} " "" "[" " " "Interrupted" " " "]" " "
}

# Interrupted file
__print_interrupt () {
	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#           $(__columns):  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#     total_flacs_length:  Length of the total # of FLAC files
	#                     25:  Length of:
	#                            [ Interrupted ] (15)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( $(__columns) - ${#iteration} - total_flacs_length - 25 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${iteration}/${#total_flacs_array[@]}]" " ${filename} " "" "[" " " "Interrupted" " " "]" " "
}

# Display the filename, clearing the progress bar and display the progress
# percentage as 100% (since FLAC stops at 99%) in green
__print_progress_ok () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${green}%4s${normal}%s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"100%" " ${filename}" ""
	else
		printf "\033[${placement};4H${green}%4s${normal}%s" \
		"100%" " ${filename}"
	fi
}

# Display the filename, clearing the progress bar and display the progress
# percentage as 100% (since FLAC stops at 99%) in green (for sub messages)
__print_sub_progress_ok () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};6H${green}%4s${normal}%s%$(( max_filename_length - current_filename_length ))s" \
		"100%" " ${filename}" ""
	else
		printf "\033[${placement};6H${green}%4s${normal}%s" \
		"100%" " ${filename}"
	fi
}


# Display the filename, clearing the progress bar and display the progress as an
# error in red color
__print_progress_failed () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${red}%4s${normal}%s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"fail" " ${filename}" ""
	else
		printf "\033[${placement};4H${red}%4s${normal}%s" \
		"fail" " ${filename}"
	fi
}

# Display the filename, clearing the progress bar and display the progress as an
# error in red color (for sub messages)
__print_sub_progress_failed () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};6H${red}%4s${normal}%s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"fail" " ${filename}" ""
	else
		printf "\033[${placement};6H${red}%4s${normal}%s" \
		"fail" " ${filename}"
	fi
}

# Display the filename, clearing the progress bar and display the progress as an
# error in red color
__print_progress_issue () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${yellow}%4s${normal}%s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"chck" " ${filename}" ""
	else
		printf "\033[${placement};4H${yellow}%4s${normal}%s" \
		"chck" " ${filename}"
	fi
}

# Display the filename, clearing the progress bar and display the progress as an
# error in red color (for sub messages)
__print_sub_progress_issue () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};6H${yellow}%4s${normal}%s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"chck" " ${filename}" ""
	else
		printf "\033[${placement};6H${yellow}%4s${normal}%s" \
		"chck" " ${filename}"
	fi
}

# Display filename and current progress of operation
__print_progress () {
	# Obtain the percentage of the current operation, the was it's obtained
	# was defined earlier and stored in the below variable
	${obtain_percentage}

	# This is the length of the progress bar represented as the maxmimum
	# filename we can use.  The progress bar is displayed by taking the
	# percentage completed thus far and using the percentage to display that
	# same percentage of the filename's length (including spaces that may appear
	# after it)
	progress_bar_length=$(( ( max_filename_length * ${percent_complete} ) / 100 ))

	# If the progress bar to display is less than or equal to the filename's
	# length, print out the part of the filename that matches the percentage
	# completed, inverting the colors.  Otherwise, print out the filename,
	# inverted as well as the percentage of spacing that may be after the
	# filename (matching the percentage of completed); also inverted
	if (( progress_bar_length < current_filename_length )) ; then

		# Below takes the current filename and 'trims' off the part of the
		# filename that hasn't doesn't match the percentage length of what's
		# completed so far (trim meaning, not highlighting that portion of the
		# filename)
		printf "\033[${placement};4H${yellow}%4s${normal} ${invert}%s${normal}%s" \
		"${percent_complete}%" "${filename:0:$(( progress_bar_length + 1 ))}"
	else

		# This prints out the the filename, inverted, as well as the current
		# progress bar length.  Used only if the filename is less than the width
		# of the progress bar maximum's length
		printf "\033[${placement};4H${yellow}%4s${normal} ${invert}%s%$(( progress_bar_length - current_filename_length + 1 ))s${normal}" \
		"${percent_complete}%" "${filename}" ""
	fi
}
#== .: PROCESSED FILE/DIRECTORY MESSAGES :. ====================================


#-------------------------------------------------------------------------------
# .: TRAPS :.
#-------------------------------------------------------------------------------
# Countdown abort
__countdown_abort () {
	__newline
	__info "Control-C received, exiting. Please wait...\n"

	# Restore old stty settings, make stty happy
	# by redirecting /dev/stderr
	stty ${old_stty} < /dev/stderr

	# Restore the cursor
	printf "\033[?25h"

	exit 130
}

# ReplayGain test abort
__replaygain_test_abort () {
	# Kill running children, must come before __kill_spinner
	__kill_jobs

	# Print current FLAC file that is interrupted
	#__print_interrupt_replaygain_file

	__newline
	__info "Control-C received, generating summary. Please wait..."

	if [[ -f "${replay_test_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_replaygain_test

		# Prepend log header to log file
		__header_replaygain_test
	fi

	# Store operation status for Summary Of Operations
	testing_replaygain_complete="interrupt"

	# Display Summary Of Operations
	__operation_summary

	exit 130
}

# ReplayGain process abort
__replaygain_process_abort () {
	# Kill running children, must come before __kill_spinner
	__kill_jobs

	# Print current directory that is interrupted
	#__print_interrupt_replaygain_dir

	__newline
	__info "Control-C received, generating summary. Please wait...\n"

	if [[ -f "${replay_add_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_replaygain_process

		# Prepend log header to log file
		__header_replaygain_test
	fi

	# Store operation status for Summary Of Operations
	adding_replaygain_complete="interrupt"

	# Display Summary Of Operations
	__operation_summary

	exit 130
}

# FLAC compress abort and remove temporarily encoded files (if any)
__compress_abort () {
	# Kill running children, must come before __kill_spinner
	__kill_jobs

	# Print current FLAC file that is interrupted
	#__print_interrupt

	__newline
	__info "Control-C received, removing temporary files and\n"
	__info "generating summary. Please wait...\n"

	# Remove temporarily encoded FLAC files
	rm -f "${directory}"/**/*.tmp,fl-ac+en\'c

	if [[ -f "${verify_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_compress_verify

		# Prepend log header to log file
		__header_compress_verify
	fi

	# Store operation status for Summary Of Operations
	compress_complete="interrupt"

	# Display Summary Of Operations
	__operation_summary

	exit 130
}

# FLAC test abort
__test_abort () {
	# Kill running children, must come before __kill_spinner
	__kill_jobs

	# Print current FLAC file that is interrupted
	#__print_interrupt

	__newline
	__info "Control-C received, generating summary. Please wait...\n"

	if [[ -f "${test_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_test

		# Prepend log header to log file
		__header_test
	fi

	# Store operation status for Summary Of Operations
	test_complete="interrupt"

	# Display Summary Of Operations
	__operation_summary

	exit 130
}

# auCDtect abort.  Removes temporary WAV files (if any)
__aucdtect_abort () {
	# Kill running children, must come before __kill_spinner
	__kill_jobs

	# Print current FLAC file that is interrupted
	#__print_interrupt

	__newline
	__info "Control-C received, removing temporary files and\n"
	__info "generating summary. Please wait...\n"

	# Remove temporarily created WAV files (if any)
	rm -f "${directory}"/**/*_redoflacs_"$$".wav

	if [[ -f "${aucdtect_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_aucdtect

		# Prepend log header to log file
		__header_aucdtect
	fi

	# Store operation status for Summary Of Operations
	aucdtect_complete="interrupt"

	# Display Summary Of Operations
	__operation_summary

	exit 130
}

# MD5 check abort
__md5_check_abort () {
	# Kill running children, must come before __kill_spinner
	__kill_jobs

	# Print current FLAC file that is interrupted
	#__print_interrupt

	__newline
	__info "Control-C received, generating summary. Please wait...\n"

	if [[ -f "${md5_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_md5_check

		# Prepend log header to log file
		__header_md5_check
	fi

	# Store operation status for Summary Of Operations
	md5check_complete="interrupt"

	# Display Summary Of Operations
	__operation_summary

	exit 130
}

# Analyzing tags abort
__analyzing_tags_abort () {
	# Kill running children, must come before __kill_spinner
	__kill_jobs

	# Print current FLAC file that is interrupted
	#__print_retag_analyze_interrupt

	__newline
	__info "Control-C received, generating summary. Please wait...\n"

	# Test for DEPRECATED tag, COVERART in METADATA_ERROR log.  If it
	# exists, set coverart_warning variable to make script output
	# warning upon completion
	if [[ -f "${metadata_errors}" ]] ; then
		while read -r i ; do
			# Indentation is culled from reading in "${i}"
			# To change this, set IFS to '\n'
			if [[ "${i}" == *METADATA_BLOCK_PICTURE* ]] ; then
				coverart_warning="true"
				break
			fi
		done < "${metadata_errors}"
	fi

	if [[ -f "${metadata_errors}"  && "${coverart_warning}" == "true" ]] ; then
		# Display COVERART warning function and metadata issues
		__newline >&2 ; __coverart_warning

		# Print out log exists to STDERR
		__log_missing_tags

		# Prepend log header to log file
		__header_retag
	elif [[ -f "${metadata_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_missing_tags

		# Prepend log header to log file
		__header_retag
	fi

	# Store operation status for Summary Of Operations
	analyzing_retag_complete="interrupt"

	# Display Summary Of Operations
	__operation_summary

	exit 130
}

# Applying tags abort
__applying_tags_abort () {
	# Kill running children, must come before __kill_spinner
	__kill_jobs

	# Print current FLAC file that is interrupted
	#__print_retag_apply_interrupt

	__newline
	__info "Control-C received, generating summary. Please wait...\n"

	# Test for DEPRECATED tag, COVERART in METADATA_ERROR log.  If it
	# exists, set coverart_warning variable to make script output
	# warning upon completion
	if [[ -f "${metadata_errors}" ]] ; then
		while read -r i ; do
			# Indentation is culled from reading in "${i}"
			# To change this, set IFS to '\n'
			if [[ "${i}" == *METADATA_BLOCK_PICTURE* ]] ; then
				coverart_warning="true"
				break
			fi
		done < "${metadata_errors}"
	fi

	if [[ -f "${metadata_errors}"  && "${coverart_warning}" == "true" ]] ; then
		# Display COVERART warning function and metadata issues
		__newline >&2 ; __coverart_warning

		# Print out log exists to STDERR
		__log_missing_tags

		# Prepend log header to log file
		__header_retag
	elif [[ -f "${metadata_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_missing_tags

		# Prepend log header to log file
		__header_retag
	fi

	# Store operation status for Summary Of Operations
	applying_retag_complete="interrupt"

	# Display Summary Of Operations
	__operation_summary

	exit 130
}

# Prune FLACS abort
__prune_abort () {
	# Kill running children, must come before __kill_spinner
	__kill_jobs

	# Print current FLAC file that is interrupted
	#__print_interrupt

	__newline
	__info "Control-C received, generating summary. Please wait...\n"

	if [[ -f "${prune_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_prune

		# Prepend log header to log file
		__header_prune
	fi

	# Store operation status for Summary Of Operations
	prune_complete="interrupt"

	# Display Summary Of Operations
	__operation_summary

	exit 130
}
#== .: END TRAPS :. ============================================================


#-------------------------------------------------------------------------------
# .: VARIOUS COMMANDS :.
#-------------------------------------------------------------------------------
# Display script version
__print_version () {
	printf "%s\n" "Version ${version}"
}

# Obtain `metaflac' version information to test on.  Example:
#   metaflac 1.3.0pre1
#   -----------^
# Test only the second integer in the version string above
__metaflac_version () {
	# Obtain entire version string, example:
	#    metaflac 1.3.0pre1
	metaflac_version="$(metaflac --version)"

	# Remove first part of string including first integer, example:
	#    3.0pre1
	metaflac_version="${metaflac_version#* [[:digit:]].}"

	# Remove last part of string, leaving only the second integer, example:
	#    3
	metaflac_version="${metaflac_version%.*}"
}

# Obtain the current cursor row position
__obtain_row () {
	__lines_columns              # Obtain the lines and columns of the terminals
	exec < /dev/tty              # Set a new TTY to read in STDIN
	row_old_stty="$(stty -g)"    # Store current TTY settings
	stty raw -echo min 0         # Current TTY set at an absolute minimum

	# Print escape sequence to obtain cursor position into the new TTY
	printf "\033[6n" > /dev/tty

	# Read in escape sequence output from TTY.  The resultant output from the
	# escape sequence looks like:
	#  ^[<num>;<num>R
	#       ^------------ This is the 'row' we want to obtain
	# The read then specifies the 'R' is the delimeter to stop reading in from,
	# storing this string into the $current_row variable
	read -r -d R current_row

	# Cull the last part of the $current_row variable to form:
	#  ^[[<num>
	current_row="${current_row%%;*}"

	current_row="${current_row:2}"  # Cull the first 2 characters leaving: <num>
	stty "${row_old_stty}"          # Restore the old TTY settings
}

# Check if we need to scroll the terminal up depending on how much room is left,
# relative to the number of jobs to process.  There is the special value of ${1}
# which signifies a number to remove from the total lines to scroll.  This
# number will only occur if the number of files/directories to process is less
# than the jobs specified to run.  This allows us to _NOT_ have extra gaps in
# our output
__scroll_terminal () {
	# Obtain the differnce from the total lines available in the current
	# terminal and the current row obtained
	lines_difference=$(( lines - current_row ))

	# If the difference in lines is less than the jobs used, the terminal will
	# not have enough room for the script to place lines, so we will have to
	# non-descructively scroll the terminal up enough lines to allow for the
	# current operations to be printed correctly
	if (( lines_difference < jobs )) ; then
		# Obtain the number of lines need to equal the current number of jobs
		lines_to_scroll=$(( jobs - lines_difference ${1} ))

		# This scrolls the terminal up by the number of lines to scroll
		printf "\033[${lines_to_scroll}S"

		# The current row is now set to the difference of the lines to scroll
		current_row=$(( current_row - lines_to_scroll ))
	fi
}

# Obtain the current progress completed percentage while compressing FLAC files
__obtain_compress_percentage () {
	# Remove backspace sequences used by the FLAC command line interface
	percent_complete="${percent_complete///}"

	# Remove the first part of the line leaving only the percent integer as well
	# as other information:
	#  '0 complete, ratio=0.307'
	percent_complete="${percent_complete##*: }"

	# Remove the last part part of the percent_complete string, leaving the
	# percent stored as an integer
	percent_complete="${percent_complete##*complete, ratio=?.???}"
}

# Obtain the current progress completed percentage while testing FLAC file
__obtain_test_percentage () {
	# Remove the first part of the line to leave the resultant percent stored as
	# an integer (no '%' appended)
	percent_complete="${percent_complete##* }"
}

# Obtain the current progress completed percentage while decoding FLAC file
__obtain_decode_percentage () {
	# Remove backspace sequences used by the FLAC command line interface
	percent_complete="${percent_complete///}"

	# Remove the first part of the line leaving only the percent integer as well
	# as well as other information:
	#  'complete0
	percent_complete="${percent_complete##*: }"

	# Remove the last part part of the percent_complete string, leaving the
	# percent stored as an integer
	percent_complete="${percent_complete##*complete}"
}

# Obtain the current progress completed percentage while using auCDtect
__obtain_aucdtect_percentage () {
	# Remove the first part of the line to leave the resultant percent stored as
	# an integer (no '%' appended)
	percent_complete="${percent_complete##*[}"
}

# Obtain the current progress completed percentage while using auCDtect
__obtain_spectrogram_percentage () {
	# Remove the first part of the line leaving only the percent which is
	# represented as a floating point number:
	#  '32.3'
	percent_complete="${percent_complete##*In:}"

	# Remove the floating point part of the percentage to leave only an integer
	percent_complete="${percent_complete%%.*}"
}

# Store the position of the current job being displayed
__store_position () {
	# If the current job(s) are the first set, we'll use the iteration
	# (starting at 0 -- hence the minus 1) of the job to start
	if (( iteration <= jobs )) ; then
		printf "$(( iteration - 1 ))\n" >&7
	else
		# Print the position of the current jobs into file descriptor (7) to be
		# stored by 'read' upon starting the next job
		printf "${previous_operation_position}\n" >&7
	fi
}

# Determine abort to run based off the operation to run (via ${1})
__determine_abort () {
	case "${1}" in
		__operation_aucdtect)
			run_abort="__aucdtect_abort"
		;;
		__operation_md5_check)
			run_abort="__md5_check_abort"
		;;
		__operation_compress)
			run_abort="__compress_abort"
		;;
		__operation_test)
			run_abort="__test_abort"
		;;
		__operation_test_replaygain)
			run_abort="__replaygain_test_abort"
		;;
		__operation_replaygain_noforce|__operation_replaygain_force)
			run_abort="__replaygain_process_abort"
		;;
		__operation_analyze_tags_dont_log_coverart|__operation_analyze_tags)
			run_abort="__analyzing_tags_abort"
		;;
		__operation_set_tags)
			run_abort="__applying_tags_abort"
		;;
		__operation_prune)
			run_abort="__prune_abort"
		;;
	esac
}

# Force the creation of a new configuration file
__new_config () {
	# Check if configuration file exists based of ${EUID}.  If it doesn't
	# exist, create one
	if (( EUID == 0 )) ; then
		# User is root
		#
		# Configuration file location
		config_location="/etc/redoflacs.conf"

		# If there already is a configuration file, do not overwrite it
		if [[ -f "${config_location}" ]] ; then
			config_location="/etc/_${$}.redoflacs.conf"
		fi
	else
		# User is _NOT_ root
		#
		# Configuration file location
		config_location="${HOME}/.config/redoflacs/config"

		# If there already is a configuration file, do not overwrite it
		if [[ -f "${config_location}" ]] ; then
			config_location="${HOME}/.config/redoflacs/_${$}.config"
		fi
	fi

	# Creates the (new) configuration file
	__create_config

	# Explain to user where to find the new configuration file
	__info "A new configuration file has been created here:\n"
	__info "${cyan}${config_location}${normal}\n\n"

	__info "It's recommended to review the new configuration file\n"
	__info "and transfer over any changes you made in your old\n"
	__info "configuration file.\n\n"

	__info "After making the changes (if any), rename the new\n"
	__info "configuration file to your old configuration file\n"
	__info "name.  Here is the command you could use:\n"

	if (( EUID == 0 )) ; then
		__info "${cyan}mv${normal} ${cyan}${config_location}${normal} ${cyan}/etc/redoflacs.conf${normal}\n"
	else
		__info "${cyan}mv${normal} ${cyan}${config_location}${normal} ${cyan}${HOME}/.config/redoflacs/config${normal}\n"
	fi
}

# Create a configuration file
__create_config () {
create_config="################################################################################
#                                                                              #
#                         REDOFLACS USER CONFIGURATION                         #
#                         ----------------------------                         #
#                                                                              #
#  Any line that is _NOT_ prepended with a '#' will be interpreted as an       #
#  option (except for blank lines -- these are not interpreted)                #
#                                                                              #
#  See \`redoflacs --help\` for a detailed description of each parameter         #
#                                                                              #
################################################################################

#-------------------------------------------------------------------------------
#  :: TAGGING SECTION ::
#-------------------------------------------------------------------------------
# List the tags to be kept in each FLAC file.  The default is listed below.
#
# Another common tag not added by default is ALBUMARTIST.  Uncomment ALBUMARTIST
# below to allow script to keep this tag.

TITLE
ARTIST
#ALBUMARTIST
ALBUM
DISCNUMBER
DATE
TRACKNUMBER
TRACKTOTAL
GENRE

# The COMPRESSION tag is a custom tag to allow the script to determine which
# level of compression the FLAC file(s) has/have been compressed at.
COMPRESSION

# The RELEASETYPE tag is a custom tag the author of this script uses to
# catalogue what kind of release the album is (ie, Full Length, EP, Demo, etc.).
RELEASETYPE

# The SOURCE tag is a custom tag the author of this script uses to catalogue
# which source the album has derived from (ie, CD, Vinyl, Digital, etc.).
SOURCE

# The MASTERING tag is a custom tag the author of this script uses to catalogue
# how the album has been mastered (ie, Lossless, or Lossy).
MASTERING

# The REPLAYGAIN tags below, are added by the '-g, --replaygain' or
# '-G, --replaygain-noforce' argument.  If you want to keep the replaygain tags,
# make sure you leave these here.
REPLAYGAIN_REFERENCE_LOUDNESS
REPLAYGAIN_TRACK_GAIN
REPLAYGAIN_TRACK_PEAK
REPLAYGAIN_ALBUM_GAIN
REPLAYGAIN_ALBUM_PEAK

#== :: END TAGGING SECTION :: ==================================================

#-------------------------------------------------------------------------------
#  :: OPTIONS ::
#-------------------------------------------------------------------------------
#~~~~~~~~~~~~~~~~~~
#  REMOVE ARTWORK
#~~~~~~~~~~~~~~~~~~
# Set whether to remove embedded artwork within FLAC files.  By default, this
# script will remove any artwork it can find, whether it's in the legacy
# COVERART tag or METADATA_BLOCK_PICTURE.  Set 'remove_artwork' as 'true' to
# remove embedded artwork.  All other values are intepreted as 'false'.
remove_artwork=\"true\"

#~~~~~~~~~~~~~~~~~~~
#  SET COMPRESSION
#~~~~~~~~~~~~~~~~~~~
# Set the type of COMPRESSION to compress the FLAC files.  Numbers range from
# '1-8', with '1' being the lowest compression and 8 being the highest
# compression.  The default is '8'.
compression_level=\"8\"

#~~~~~~~~~~~~~~~~~~~~~~~
#  ERROR LOG DIRECTORY
#~~~~~~~~~~~~~~~~~~~~~~~
# Set the where you want the error logs to be placed. By default, they are
# placed in the user's HOME directory.
error_log=\"\${HOME}\"

#~~~~~~~~~~~~~~~~~~~~~~~~~
#  SPECTROGRAM DIRECTORY
#~~~~~~~~~~~~~~~~~~~~~~~~~
# Set where the created spectrogram files should be placed. By default, the
# spectrogram images will be placed in the same directory as the tested FLAC
# files. Each image will have the same name as the tested FLAC file but with
# the extension '.png'.
#
# All values for 'spectrogram_location' are interpreted as a directory.  If left
# blank, the default location will be used.
#
# An example of a user-defined location:
#    spectrogram_location=\"\${HOME}/Spectrogram_Images\"
#
# See '--help' or '-h' for more information.
spectrogram_location=\"\"

#~~~~~~~~~~~~~~~~~~~~~~~~
#  PREPEND TRACK NUMBER
#~~~~~~~~~~~~~~~~~~~~~~~~
# Change whether the '-r, --retag' operation will re-tag singular track numbers
# and track totals from:
#    [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
# to
#    [ 01, 02, 03, 04, 05, 06, 07, 08, 09 ]
#
# For example, if you had:
#    TRACKNUMBER=4
#    TRACKTOTAL=9
#
# You would end up with:
#    TRACKNUMBER=04
#    TRACKTOTAL=09
#
# This is enabled by setting 'prepend_zero' option as 'true'.  All other values
# are interpreted as 'false'.
prepend_zero=\"false\"

#== :: END OPTIONS :: ====================================== :: REVISION 1 :: =="

	# Print out the configuration file to the specified location (either system-
	# wide or local)
	printf "%s\n" "${create_config}" > "${config_location}"
}

# Parse the configuration file
__parse_config () {
	# Load configuration file into an array
	mapfile -n0 -t config_file_array < "${config_location}"

	# For each line in the configuration file, obtain only the
	# lines that are part of the configuration
	for line in "${config_file_array[@]}" ; do
		# Strip line and replace with comment _ONLY_ if the line
		# starts with a comment
		test_line="${line/##*/#}"

		# If ${test_line} does not equal a comment and if ${line}
		# is not blank, store the current line (which is either
		# a tag to keep or an option) into an array for further
		# parsing
		if [[ "${test_line}" != "#" && "${line}" != "" ]] ; then
			# Add valid configuration lines into an array
			valid_config_array+=( "${line}" )
		fi
	done

	# For each line in the configuration, store the tag fields
	# and evaluate the options as variables into the environment
	for line in "${valid_config_array[@]}" ; do
		# ${value_type} holds the key=pair for options to be
		# parsed, else the line is a tag field
		value_type="${line//*=*/}"

		# If ${value_type} is _NOT_ null, then the line parsed
		# is a tag field
		if [[ -n "${value_type}" ]] ; then
			# Store the tag field into the tags array
			tags+=( "${line}" )
		else
			# Evaluate the option
			eval "${line}"
		fi
	done
}

# Check current configuration, if the version in the script is newer
# warn user and display a countdown before starting script
__check_config_version () {
	# Check if configuration file exists based of ${EUID}.  If it doesn't
	# exist, create one
	if (( EUID == 0 )) ; then
		# User is root
		#
		# Configuration file location
		config_location="/etc/redoflacs.conf"
	else
		# User is _NOT_ root
		#
		# Configuration file location
		config_location="${HOME}/.config/redoflacs/config"
	fi

	# Load configuration file into an array
	mapfile -n0 -t config_array < "${config_location}"

	# Obtain only the last line of the config
	config_last_line="${config_array[$(( ${#config_array[@]} - 1 ))]}"

	# Remove everything from the last line, except the REVISION number
	#
	# Below leaves:
	#  '<revision number> :: =='
	user_revision="${config_last_line#*REVISION }"
	# Obtains REVISION number
	user_revision="${user_revision% ::*}"

	# Check if ${user_revision} is an integer.  If not, display countdown
	# and warn user of new config file, else test if the user revision is
	# less than the script revision
	if [[ "${user_revision}" =~ ^[[:digit:]]+$ ]] ; then
		# If ${script_revision} is greater than ${user_revision}
		# warn user and display countdown
		if (( script_revision > user_revision )) ; then
			# Display warning and countdown
			__countdown_config ; __newline 2
		fi
	else
		# Display warning and countdown
		__countdown_config ; __newline 2
	fi
}

# Determine the width/height of the terminal in
__lines_columns () {
	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r rows_columns < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with the width of terminal
	columns="${rows_columns#*columns }"
	columns="${columns%%;*}"

	# Remove superflous information from 'stty -a'
	# Ends up with the height of terminal
	lines="${rows_columns#*rows }"
	lines="${lines%%;*}"
}

# Creates filename of current FLAC and culls it if the length
# is bigger than then width of the terminal
__filename () {
	filename="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	filename="${filename//$'\n'/?}"

	# Obtain filename length.  We cannot use ${#filename} in the event there is
	# multibyte characters -- the width would not be equal to characters since
	# the characters can take up more than one block in a terminal
	current_filename_length="$(wc -L <<< "${filename}")"

	# Cull filename and add an ellipsis if the filename is too long
	if (( current_filename_length > max_filename_length )) ; then

		# Grab the current filename length after it's been culled by the maximum
		# length allowed by ${columns}
		culled_filename_length="$(wc -L <<< "${filename:0:${max_filename_length}}")"

		# Set a placeholder ${max_filename_length} to be changed in the loop
		# below
		max_length="${max_filename_length}"

		# Keep looping until the culled filename length equals the maximum
		# length allowed via ${columns}
		until (( culled_filename_length == max_filename_length )) ; do

			# Decrement placeholder ${max_length} by one (1)
			((--max_length))
			
			# Obtain the new culled filename length
			culled_filename_length="$(wc -L <<< "${filename:0:${max_length}}")"

		done

		# Set the culled filename to display slicing the correct amount of
		# characters determined from ${max_length}
		filename="${filename:0:${max_length}}… "
	else
		# Set the default filename with a gap at the end for spacing
		filename="${filename} "
	fi
}

# Display current length spacing between filename and operation message
__current_length () {
	# The current length is obtained via the length of what's printed now minus
	# the length of the filename and gaps:
	#
	#  [1234/123456] 07 - Some_FLAC_Filename.flac <- ${current_length} -> [ Operation Message ]
	#                                             ^^^^^^^^^^^^^^^^^^^^^^^
	#  ${current_filename_length}:  Length of the current filename from __filename
	#  ${max_filename_length} + 1:  Total length of what's printed minus the operation
	#                               message plus one because we do not want the ellipsis
	#                               from ${max_filename_length}, just the space/gap
	#
	# Only print out ${current_length} if the current filename length is less
	# than the maximum file length allowed
	if (( current_filename_length <= max_filename_length )) ; then
		printf %d $(( max_filename_length - current_filename_length + 1 ))
	fi
}

# Print out spinner
__spinner () {
	# Array houses various spinner incarnations
	spinner=( '|' '/' '-' '\' )

	# Run indefinitely
	while true; do
		# Print each index of the spinner array
		for i in "${spinner[@]}" ; do
			printf "\r ${cyan}%s${normal} " "${i}"

			# Sleep so the spinner isn't exceptionally fast
			sleep .1
		done
	done
}

# Start the spinner on the first file/directory being processed
__start_spinner () {
	if (( iteration == 1 )) ; then
		# Display spinner as a separate process (forked to background)
		__spinner &

		# Store spinner PID into fd '6'
		printf "%s\n" "${!}" >&6
	fi
}

# Kill spinner process
__kill_spinner () {
	# Print a newline into file descriptor 6, hiding any error output that may
	# occur if the file descriptor is NOT open yet
	{ printf "\n" >&6 ;} 2>/dev/null

	# If the file descriptor is open, obtain spinner PID and kill it
	if (( ${?} == 0 )) ; then
		# Obtain process PID of spinner
		read -u6 spinner_pid

		# Kill spinner PID
		kill "${spinner_pid}" 2>/dev/null

		# Wait on killing the spinner process, hiding STDERR to disable job
		# control output
		wait "${!}" 2>/dev/null
	fi
}

# Determine number of jobs to run via the number
# of CPUs/cores available
__find_cores () {
	# Check if /proc is mounted by comparing device numbers of
	# /proc and / and see if they don't match (ie, /proc is mounted)
	if (( $(stat -c %d /proc) == $(stat -c %d /) )) ; then
		# /proc is not mounted, default to 2 jobs
		jobs_display="(Default)"
		jobs=2
	else
		# /proc is mounted, check for cpuinfo
		if [[ ! -f /proc/cpuinfo ]] ; then
			# /proc/cpuinfo doesn't exist
			jobs_display="(Default)"
			jobs=2
		else
			# /proc/cpuinfo exists, find total number
			# of cores to use

			# Store contents of /proc/cpuinfo into
			# cores_array
			mapfile -n0 -t cores_array < /proc/cpuinfo

			# For each line, if matched string is found,
			# add processor number to jobs variable
			for i in "${cores_array[@]}" ; do
				if [[ "${i}" == processor$'\t':\ * ]] ; then
					jobs="${i#processor$'\t': }"
				fi
			done

			# Add +1 to jobs since the number of useable cores
			# starts at 0
			((jobs++))
			jobs_display="(/proc/cpuinfo)"
		fi
	fi
}

# Prints the number of newlines specified
# by ${1}
__newline () {
	newlines="${1}"

	# If ${newlines} is empty, set to 1 in order
	# to allow one newline to be printed
	if [[ -z "${newlines}" ]] ; then
		newlines="1"
	fi

	# Print the number of newlines specified
	for (( count=0; count < newlines; count++ )) ; do
		printf "\n"
	done
}

# If COVERART tag is kept and remove_artwork is set to 'true'
# display conflict and exit
__coverart_remove_conflict () {
	# Check if COVERART exists in the tag array.  Notify user
	# of its deprecation and advise against using it, preferring
	# METADATA_BLOCK_PICTURE
	for j in "${tags[@]}" ; do

		if [[ "${j}" == "COVERART" ]] ; then

			# If remove_artwork is "true" (remove the artwork), then
			# exit and warn the user you can't specify whether you want to
			# remove artwork, yet keep the COVERART tag in configuration file
			if [[ "${remove_artwork}" == "true" ]] ; then

				# Display COVERART tag warning
				__coverart_warning

				__newline >&2
				__error "It appears you have ${cyan}remove_artwork${normal} set to ${cyan}true${normal} in the\n" >&2
				__error "configuration file, yet ${cyan}COVERART${normal} is specified as one\n" >&2
				__error "(or more) of the FLAC tags to be kept. Please choose either\n" >&2
				__error "to keep album artwork (ie ${cyan}remove_artwork=\"false\"${normal}) or remove\n" >&2
				__error "the ${cyan}COVERART${normal} tag located in the configuration file.\n" >&2

				exit 1

			# COVERART was found, but artwork is to be removed,
			# so warn user of its deprecation
			else

				# Create coverart_warning variable, so script can append
				# the coverart_warning function after completion as well as
				# determine whether the script should temporarily add COVERART
				# to the tag array
				coverart_warning="true"
			fi
		fi
	done
}

# Top banner displaying invocation settings
__top_banner () {
	# If Redo Tags is called, create the necessary spacing
	if [[ "${retag_flac}" == "true" ]] ; then
		__newline 2
	fi

	# Top title line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "---------------------------------------------------"

	# Title
	printf "${normal}%s\n" \
	"                Runtime Information"

	# Bottom title line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	# Script version
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
	"                  Version " "|" " " "${version}"

	# Processes to be used
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}%s${cyan}%s${normal}\n" \
	"            Parallel Jobs " "|" " " "${jobs}" " " "${jobs_display}"

	# Log directory
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
	"            Log Directory " "|" " " "${error_log}/"

	# Configuration directory
	if (( EUID == 0 )) ; then
		# Root: System-wide configuration
		config_directory="/etc/"
	else
		# Non root: User configuration
		config_directory="~/.config/redoflacs/"
	fi
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
	"         Config Directory " "|" " " "${config_directory}"

	# Bottom banner line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	# Message indicating the searching of FLAC files
	__info "Finding FLAC files to process..."
}

# Below creates the '[ ok ]' message to print after the info
# line above.  This will be displayed when all the FLAC files
# have been mapped to an array
__processed_flacs_ok () {
	printf "${normal}%11s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}\n" \
	"" "[" " " "ok" " " "]"
}

# Create a countdown function for the metadata
# to allow user to quit script safely
__countdown_metadata () {
	# Trap SIGINT (Control-C) to abort cleanly
	trap __countdown_abort SIGINT

	# Warning message
	__error "${yellow}CAUTION!${normal} These are the tag fields that will be kept\n" >&2
	__error "when re-tagging the selected files:\n\n" >&2

	# Creates the listing of tags to be kept
	for i in "${tags[@]}" ; do
		printf "     ${i}\n" >&2
	done

	# Warning message about embedded coverart
	__newline >&2
	__error "By default, this script will ${cyan}REMOVE${normal} the legacy (deprecated)\n" >&2
	__error "${cyan}COVERART${normal} tag when re-tagging files.  Change the ${cyan}remove_artwork${normal}\n" >&2
	__error "option (in the configuration file) to ${cyan}false${normal} to keep the legacy\n" >&2
	__error "${cyan}COVERART${normal} tag, or add the ${cyan}COVERART${normal} tag to the list of tags to\n" >&2
	__error "be kept in the ${cyan}TAGGING SECTION${normal} of the configuration file.\n\n" >&2

	__error "Keep in mind, if the ${cyan}remove_artwork${normal} option is set to ${cyan}false${normal},\n" >&2
	__error "embedded artwork in the ${cyan}PICTURE${normal} block will be kept when using\n" >&2
	__error "${cyan}-p, --prune${normal} option as well.\n\n" >&2

	__warn "Waiting ${red}10${normal} seconds before starting program...\n" >&2
	__warn "Ctrl+C (Control-C) to abort...\n" >&2
	__info "Starting in: "

	# 10 second countdown
	for (( count=10; count > 0; count-- )); do
		printf "${red}%s${normal}%s" "$count" " "
		sleep 1
	done
}

# Displays a countdown after a newer config is found than what
# the user has.  Allows user to quit script before proceeding
__countdown_config () {
	# Trap SIGINT (Control-C) to abort cleanly
	trap __countdown_abort SIGINT

	# Warning message
	__info "There is a newer configuration file available!\n\n"

	__warn "It is recommended you generate a new configuration\n" >&2
	__warn "file for use with this program.\n\n" >&2

	__warn "To generate a new configuration file, run:\n" >&2
	__warn "${cyan}redoflacs --new-config${normal}\n\n" >&2

	__warn "The above command will _NOT_ overwrite your\n" >&2
	__warn "current configuration file.\n\n" >&2

	__warn "Waiting 10 seconds before starting program...\n" >&2
	__warn "Ctrl+C (Control-C) to abort...\n" >&2
	__info "Starting in: "

	# 10 second countdown
	for (( count=10; count > 0; count-- )); do
		printf "${red}%s${normal}%s" "$count" " "
		sleep 1
	done
}

# Obtain the total number of directories to process, repesented
# as ${total_directories}
__total_directories () {
	# Find all the directories in which to process the FLAC files.
	for i in "${total_flacs_array[@]}" ; do
		if [[ "${processed_directory}" != "${i%/*}" ]] ; then
			flac_directories_array+=( "${i%/*}" )
		fi
		local processed_directory="${i%/*}"
	done

	# The total number of directories in a string variable
	total_directories="${#flac_directories_array[@]}"
}

# Clear old file descriptor (3) and create a new
# FIFO that's tied to file discriptor 3, removing
# the FIFO upon completion
__clear_tmp_fd () {
	# Create temporary FIFO
	mkfifo "${tmp_fifo}"

	# Open FIFO for reading and writing on file descriptor '3'
	exec 3<>"${tmp_fifo}"

	# Remove temporary FIFO and leave just the file
	# descriptor available
	rm -f "${tmp_fifo}"
}

# Clear old file descriptor (4) and create a new
# FIFO that's tied to file discriptor 4, removing
# the FIFO upon completion.  This is ONLY for auCDtect's
# STDOUT
__create_aucdtect_fd () {
	# Set up a temporary FIFO location.  The variable
	# is set up here, to prevent it from being called
	# upon script invocation when auCDtect isn't going
	# to be run
	tmp_aucdtect_fd="/tmp/redoflacs_aucdtect_fifo_$$"

	# Create the temporary FIFO
	mkfifo "${tmp_aucdtect_fd}"

	# Open FIFO for reading and writing on file descriptor '4'
	exec 4<>"${tmp_aucdtect_fd}"

	# Remove temporary FIFO and leave just the file
	# descriptor available
	rm -f "${tmp_aucdtect_fd}"
}

# Create a new file descriptor (5) via a FIFO
__set_error_fd () {
	# Error FIFO location
	error_fifo="/tmp/redoflacs_error_fifo_$$"

	# Create temporary FIFO
	mkfifo "${error_fifo}"

	# Open FIFO for reading and writing on file descriptor '5'
	exec 5<>"${error_fifo}"

	# Remove temporary FIFO and leave just the file
	# descriptor available
	rm -f "${error_fifo}"
}

# Create spinner file descriptor (6) and create a new FIFO that's tied to file
# descriptor 6, removing the FIFO upon completion
__set_spinner_fd () {
	# Print a newline into file descriptor 6, hiding any error output that may
	# occur if the file descriptor is NOT open yet
	{ printf "\n" >&6 ;} 2>/dev/null

	# If the file descriptor isn't open, create the FIFO and open it on fd '6'
	if (( ${?} != 0 )) ; then
		# Create temporary FIFO
		mkfifo "${spinner_fifo}"

		# Open FIFO for reading and writing on file descriptor '6'
		exec 6<>"${spinner_fifo}"

		# Remove temporary FIFO and leave just the file descriptor available
		rm -f "${spinner_fifo}"

	# The file descriptor is already open, so kill the spinner and reset the fd
	else
		# Kill spinner
		__kill_spinner

		# Create temporary FIFO
		mkfifo "${spinner_fifo}"

		# Open FIFO for reading and writing on file descriptor '6'
		exec 6<>"${spinner_fifo}"

		# Remove temporary FIFO and leave just the file descriptor available
		rm -f "${spinner_fifo}"
	fi
}

# Create a new file descriptor (7) via a FIFO for use with file positioning
__set_position_fd () {
	# Position FIFO location
	position_fifo="/tmp/redoflacs_position_fifo_$$"

	# Create temporary FIFO
	mkfifo "${position_fifo}"

	# Open FIFO for reading and writing on file descriptor '7'
	exec 7<>"${position_fifo}"

	# Remove temporary FIFO and leave just the file
	# descriptor available
	rm -f "${position_fifo}"
}

# Kill any child processes
__kill_jobs () {
	# Hide error output in case there are no children to kill
	kill $(jobs -rp) 2>/dev/null

	# Wait on killing the children process, hiding STDERR to disable job control
	# output
	wait 2>/dev/null
}

# Obtain and process the positional parameters invoked
# with the script
__process_positional_parameters () {
	# If no arguments are made to the script show usage & short help
	if (( ${#} == 0 )) ; then
		__short_help
		exit 1
	fi

	# Add case where only one argument is specified
	if (( ${#} == 1 )) ; then
		case "${1}" in
			--version|-v)
				__print_version
				exit 0
			;;
			--help|-h)
				# Create the temporary file in which a man page will be
				# generated
				tmp_man_page="/tmp/redoflacs_man_$$.1"

				# Generate the man page to the above temporary location
				__long_help

				# Read the man page with 'man'
				man "${tmp_man_page}"

				# After reading, remove temporary file and exit
				rm -f "${tmp_man_page}"

				exit 0
			;;
			--new-config|-o)
				__new_config
				exit 0
			;;
			*)
				__usage >&2
				exit 1
			;;
		esac
	fi

	# Add case where two arguments are specified and the
	# arguments called are not to have anything after them
	if (( ${#} == 2 )) ; then
		case "${1}" in
			--jobs=[[:digit:]]*|-j[[:digit:]]*)
				__usage >&2
				exit 1
			;;
			--no-color|-n)
				__usage >&2
				exit 1
			;;
			--version|-v)
				__usage >&2
				exit 1
			;;
			--new-config|-o)
				__usage >&2
				exit 1
			;;
			--help|-h)
				__usage >&2
				exit 1
			;;
		esac
	fi

	# Separate the long and short style arguments into their
	# own arrays as well as capture the last non-arguements, to
	# prevent multiple directories being called
	for i in "${@}" ; do
		if [[ "${i}" == --* ]] ; then
			long_style_arguments_array+=( "${i}" )
		elif [[ "${i}" == -* ]] ; then
			short_style_arguments_array+=( "${i}" )
		else
			non_arguments_array+=( "${i}" )
		fi
	done

	# If there are 0 (zero) directories or more than 1, exit script
	if (( ${#non_arguments_array[@]} == 0 || ${#non_arguments_array[@]} > 1 )) ; then
		__usage >&2
		exit 1
	fi

	# If there were any long style arguments called, convert them
	# to short style in order for getopts to be able to process
	# them correctly (ignoring '--help', '--version', '--new-config' since
	# this is taken care of above).  Add invalid arguments to it's
	# own array
	if [[ -n "${long_style_arguments_array[@]}" ]] ; then
		for i in "${long_style_arguments_array[@]}" ; do
			case "${i}" in
				--compress)
					converted_arguments_array+=( -c )
				;;
				--compress-notest)
					converted_arguments_array+=( -C )
				;;
				--test)
					converted_arguments_array+=( -t )
				;;
				--md5check)
					converted_arguments_array+=( -m )
				;;
				--aucdtect)
					converted_arguments_array+=( -a )
				;;
				--aucdtect-spectrogram)
					converted_arguments_array+=( -A )
				;;
				--prune)
					converted_arguments_array+=( -p )
				;;
				--replaygain)
					converted_arguments_array+=( -g )
				;;
				--replaygain-noforce)
					converted_arguments_array+=( -G )
				;;
				--retag)
					converted_arguments_array+=( -r )
				;;
				--all)
					converted_arguments_array+=( -l )
				;;
				--reallyall)
					converted_arguments_array+=( -L )
				;;
				--no-color)
					converted_arguments_array+=( -n )
				;;
				--jobs=[[:digit:]]*)
					# Set number of jobs to run via the required
					# integer argument after '-j'
					jobs="${i##*=}"
				;;
				--version)
					__usage >&2
					exit 1
				;;
				--help)
					__usage >&2
					exit 1
				;;
				--new-config)
					__usage >&2
					exit 1
				;;
				*)
					# Set invalid argument into array
					invalid_arguments_array+=( "${i}" )
				;;
			esac
		done
	fi

	# If there were any short style arguments called, go through
	# them, adding the valid arguments to the "converted_arguments"
	# array and adding invalid arguments to it's own array
	if [[ -n "${short_style_arguments_array[@]}" ]] ; then
		while getopts ":LlcCtgGaAmprnj:hvo" arguments "${short_style_arguments_array[@]}" ; do
			case "${arguments}" in
				l)
					converted_arguments_array+=( -l )
				;;
				L)
					converted_arguments_array+=( -L )
				;;
				c)
					converted_arguments_array+=( -c )
				;;
				C)
					converted_arguments_array+=( -C )
				;;
				t)
					converted_arguments_array+=( -t )
				;;
				g)
					converted_arguments_array+=( -g )
				;;
				G)
					converted_arguments_array+=( -G )
				;;
				a)
					converted_arguments_array+=( -a )
				;;
				A)
					converted_arguments_array+=( -A )
				;;
				m)
					converted_arguments_array+=( -m )
				;;
				p)
					converted_arguments_array+=( -p )
				;;
				r)
					converted_arguments_array+=( -r )
				;;
				n)
					converted_arguments_array+=( -n )
				;;
				j)
					# Set number of jobs to run via the required
					# integer argument after '-j'
					jobs="${OPTARG}"

					# Do not allow jobs to be '0'
					if (( jobs == 0 )) ; then
						# Currently, this is just for '-j' so we can explicity
						# specify it
						parameter_errors_array+=( "${cyan}-j${normal} requires a non-zero integer after it (eg. ${cyan}-j11${normal})." )
					else
						converted_arguments_array+=( -j )
					fi
				;;
				h)
					converted_arguments_array+=( -h )
				;;
				v)
					converted_arguments_array+=( -v )
				;;
				o)
					converted_arguments_array+=( -o )
				;;
				:)
					# Currently, this is just for '-j' so we can explicity
					# specify it
					parameter_errors_array+=( "${cyan}-${OPTARG}${normal} requires a non-zero integer after it (eg. ${cyan}-${OPTARG}11${normal})." )
				;;
				?)
					# Set invalid argument from getopts into array using
					# ${OPTARG}
					invalid_arguments_array+=( "-${OPTARG}" )
				;;
			esac
		done
	fi

	# If there were invalid arguments called, display them and
	# exit script
	if [[ -n "${invalid_arguments_array[@]}" || -n "${parameter_errors_array[@]}" ]] ; then
		__usage >&2

		if [[ -n "${invalid_arguments_array[@]}" ]] ; then
			__newline >&2
			__error "Invalid options:" >&2

			for i in "${invalid_arguments_array[@]}" ; do
				printf " ${cyan}${i}${normal}" >&2
			done

			__newline >&2
		fi

		if [[ -n "${parameter_errors_array[@]}" ]] ; then
			__newline >&2

			for i in "${parameter_errors_array[@]}" ; do
				__error "${i}\n" >&2
			done
		fi

		exit 1
	fi

	# Run through all the converted arguments and set up the correct
	# values based on what the user called, thereby allowing the
	# script to process said values and execute the corresponding
	# functions
	for i in "${converted_arguments_array[@]}" ; do
		case "${i}" in
			-l)
				all="true"
			;;
			-L)
				reallyall="true"
			;;
			-c)
				compress_flac="true"
				compress_test="true"
			;;
			-C)
				compress_flac="true"
				skip_test="true"
			;;
			-t)
				test_flac="true"
			;;
			-g)
				replaygain_flac="true"
				# Below used only once to test for
				# command compatibility
				replaygain_force="true"
			;;
			-G)
				replaygain_flac="true"
				replaygain_noforce="true"
			;;
			-a)
				aucdtect_flac="true"
				no_spectrogram="true"
			;;
			-A)
				aucdtect_flac="true"
				create_spectrogram="true"
			;;
			-m)
				md5check_flac="true"
			;;
			-p)
				prune_flac="true"
			;;
			-r)
				retag_flac="true"
			;;
			-n)
				no_color="true"
			;;
			-j)
				# Do nothing, ${jobs} has already been stored
				# in previous getopts loop
				:
			;;
			-v)
				__usage >&2
				exit 1
			;;
			-h)
				__usage >&2
				exit 1
			;;
			-o)
				__usage >&2
				exit 1
			;;
			*)
				# Should not ever happen!
				__error "This is a BUG! Please report to:\n" >&2
				__error "${cyan}https://github.com/sirjaren/redoflacs/issues/new${normal}\n" >&2

				exit 1
			;;
		esac
	done

	# Put all the called arguments into an array
	called_arguments_array=( "${@}" )

	# Set the last argument as the directory and remove the
	# ending slash (if any) to prevent double slashes from
	# appearing because of BASH's globstar.
	#
	# This only appears if the directory chosen is the direct
	# parent directory to the FLAC files to be processed.
	#
	# BASH 4.2 allows negative indices (ie):
	#
	# directory="${called_arguments_array[-1]%/}"
	directory="${called_arguments_array[$(( ${#called_arguments_array[@]} - 1 ))]%/}"
}

# Check for missing programs vital to this script
__check_missing_programs () {
	# Check if each command can be found in $PATH
	rm_exists="$(type -P rm)"
	sleep_exists="$(type -P sleep)"
	stty_exists="$(type -P stty)"
	stat_exists="$(type -P stat)"
	mkfifo_exists="$(type -P mkfifo)"
	wc_exists="$(type -P wc)"
	metaflac_exists="$(type -P metaflac)"
	flac_exists="$(type -P flac)"

	# Go through and test if each command was found (by displaying its $PATH).  If
	# it's empty, add where you can find the package to an array to be displayed.
	if [[ -z "${rm_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}rm${normal}        ->  Part of ${cyan}coreutils${normal}" )
	fi

	if [[ -z "${sleep_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}sleep${normal}     ->  Part of ${cyan}coreutils${normal}" )
	fi

	if [[ -z "${stty_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}stty${normal}      ->  Part of ${cyan}coreutils${normal}" )
	fi

	if [[ -z "${stat_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}stat${normal}      ->  Part of ${cyan}coreutils${normal}" )
	fi

	if [[ -z "${mkfifo_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}mkfifo${normal}    ->  Part of ${cyan}coreutils${normal}" )
	fi

	if [[ -z "${wc_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}wc${normal}        ->  Part of ${cyan}coreutils${normal}" )
	fi

	if [[ -z "${metaflac_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}metaflac${normal}  ->  Part of ${cyan}flac${normal}" )
	fi

	if [[ -z "${flac_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}flac${normal}      ->  Part of ${cyan}flac${normal}" )
	fi

	# If all the programs above were found, continue with script.  Else
	# display warning and exit script, printing out which package has
	# the missing programs
	if [[ -n "${command_exists_array[@]}" ]] ; then
		__display_missing_commands_header

		# Iterate through array and print each value
		for i in "${command_exists_array[@]}" ; do
			__warn "${i}\n" >&2
		done

		exit 1
	fi

	# If auCDtect operation was specified, check
	# if auCDtect is found/installed
	if [[ "${aucdtect_flac}" == "true" ]] ; then
		aucdtect_exists="$(type -P auCDtect)"

		if [[ -z "${aucdtect_exists}" ]] ; then
			# Check alternate spelling
			aucdtect_exists="$(type -P aucdtect)"
		fi

		if [[ -z "${aucdtect_exists}" ]] ; then
			# auCDtect can't be found, exit
			__error "It appears ${cyan}auCDtect${normal} is not installed. Please verify you\n" >&2
			__error "have this program installed and can be found in ${cyan}\$PATH${normal}\n" >&2

			exit 1
		else
			# Check if auCDtect is executable and warn user if it isn't
			if [[ ! -x "${aucdtect_exists}" ]] ; then
				__error "It appears ${cyan}auCDtect${normal} is not executable.  In order to make\n" >&2
				__error "${cyan}auCDtect${normal} executable, run:\n" >&2
				__error "${cyan}chmod +x \"${aucdtect_exists}\"${normal}\n" >&2

				exit 1
			fi

			# Set up auCDtect command
			aucdtect_command="${aucdtect_exists}"
		fi
	fi

	# If "-A, --aucdtect-spectrogram" was called
	# make sure SoX is installed before starting
	if [[ "${create_spectrogram}" == "true" ]] ; then
		# Check if SoX is found/installed
		sox_exists="$(type -P sox)"

		if [[ -z "${sox_exists}" ]] ; then
			# SoX can't be found, exit
			__error "It appears ${cyan}SoX${normal} is not installed. Please verify you\n" >&2
			__error "have this program installed and can be found in ${cyan}\$PATH${normal}\n" >&2

			exit 1
		else
			# Set up SoX command
			sox_command="${sox_exists}"
		fi
	fi
}

# Check for any conflicting operations/arguments
__check_conflicting_operations () {
	# If "-l, --all" and "-L, --reallyall" are both called, warn and exit
	if [[ "${all}" == "true" && "${reallyall}" == "true" ]] ; then
		__error "Running both ${cyan}-l, --all${normal} and ${cyan}-L, --reallyall${normal} conflict!\n" >&2
		__error "Please choose one or the other.\n" >&2

		exit 1
	fi

	# If "-l, --all" or "-L, --reallyall" was called, check if arguments
	# were called that already will be performed by the above argument(s).
	# If any were called, display a warning and exit the script
	if [[ "${all}" == "true" || "${reallyall}" == "true" ]] ; then

		# Check for "-c, --compress".  If used add it to array
		if [[ "${compress_flac}" == "true" && "${skip_test}" == "false" ]] ; then
			argument_conflict_array+=( "-c, --compress" )
		# Check for "-C, --compress-notest".  If used add it to array
		elif [[ "${compress_flac}" == "true" && "${skip_test}" == "true" ]] ; then
			argument_conflict_array+=( "-C, --compress-notest" )
		fi

		# Check for "-t, --test".  If used add it to array
		if [[ "${test_flac}" == "true" ]] ; then
			argument_conflict_array+=( "-t, --test" )
		fi

		# Check for "-m, --md5check".  If used add it to array
		if [[ "${md5check_flac}" == "true" ]] ; then
			argument_conflict_array+=( "-m, --md5check" )
		fi

		# Check for "-p, --prune".  If used add it to array
		if [[ "${prune_flac}" == "true" ]] ; then
			argument_conflict_array+=( "-p, --prune" )
		fi

		# Check for "-g, --replaygain".  If used add it to array
		if [[ "${replaygain_flac}" == "true" && "${replaygain_noforce}" != "true" ]] ; then
			argument_conflict_array+=( "-g, --replaygain" )
		# Check for "-G, --replaygain-noforce".  If used add it to array
		elif [[ "${replaygain_flac}" == "true" && "${replaygain_noforce}" == "true" ]] ; then
			argument_conflict_array+=( "-G, --replaygain-noforce" )
		fi

		# Check for "-r, --retag".  If used add it to array
		if [[ "${retag_flac}" == "true" ]] ; then
			argument_conflict_array+=( "-r, --retag" )
		fi

		# If "-L, --reallyall" was called, check for the various forms of calling
		# auCDtect.  If it was called, add it to array
		if [[ "${reallyall}" == "true" ]] ; then
			if [[ "${aucdtect_flac}" == "true" && "${create_spectrogram}" == "true" ]] ; then
				argument_conflict_array+=( "-A, --aucdtect-spectrogram" )
			elif [[ "${aucdtect_flac}" == "true" && "${create_spectrogram}" != "true" ]] ; then
				argument_conflict_array+=( "-a, --aucdtect" )
			fi
		fi

		# If the array is not empty, the user called some incompatible options with
		# "-l, --all" or "-L, --reallyall", so print which options were called that
		# are incompatible and exit script
		if [[ -n "${argument_conflict_array[@]}" ]] ; then
			# "-l, --all"
			if [[ "${all}" == "true" ]] ; then
				__error "The below options conflict with ${cyan}-l, --all${normal}:\n" >&2
			# "-L, --reallyall"
			elif [[ "${reallyall}" == "true" ]] ; then
				__error "The below options conflict with ${cyan}-L, --reallyall${normal}:\n" >&2
			fi

			# Iterate through array and print each value
			for i in "${argument_conflict_array[@]}" ; do
				__error "     ${cyan}${i}${normal}\n" >&2
			done

			__error "Please remove incompatible options.\n" >&2

			exit 1
		fi
	fi

	# If "-C, --compress-notest" and "-c, --compress" are both called, warn and exit
	if [[ "${skip_test}" == "true" && "${compress_test}" == "true" ]] ; then
		__error "Running both ${cyan}-c, --compress${normal} and ${cyan}-C, --compress-notest${normal} conflict!\n" >&2
		__error "Please choose one or the other.\n" >&2
		exit 1
	fi

	# If "-c, --compress" and "-t, --test" are both called, warn and exit
	if [[ "${compress_test}" == "true" && "${test_flac}" == "true" ]] ; then
		__error "Running both ${cyan}-c, --compress${normal} and ${cyan}-t, --test${normal} conflict!\n" >&2
		__error "Please choose one or the other.\n" >&2
		exit 1
	fi

	# If "-g, --replaygain" and "-G, --replaygain-noforce" are both called, warn and exit
	if [[ "${replaygain_force}" == "true" && "${replaygain_noforce}" == "true" ]] ; then
		__error "Running both ${cyan}-g, --replaygain${normal} and ${cyan}-G, --replaygain-noforce${normal} conflict!\n" >&2
		__error "Please choose one or the other.\n" >&2
		exit 1
	fi

	# If "-a, --aucdtect" and "-A, --aucdtect-spectrogram" are both called, warn and exit
	if [[ "${no_spectrogram}" == "true"  && "${create_spectrogram}" == "true" ]] ; then
		__error "Running both ${cyan}-a, --aucdtect${normal} and ${cyan}-A, --aucdtect-spectrogram${normal} conflict!\n" >&2
		__error "Please choose one or the other.\n" >&2
		exit 1
	fi

	# If "-l, --all" or "-L, --reallyall" was called,
	# enable the various arguments to allow script to
	# run them
	if [[ "${all}" == "true" ]] ; then
		compress_flac="true"
		md5check_flac="true"
		prune_flac="true"
		replaygain_flac="true"
		retag_flac="true"
	elif [[ "${reallyall}" == "true" ]] ; then
		compress_flac="true"
		md5check_flac="true"
		prune_flac="true"
		replaygain_flac="true"
		retag_flac="true"
		aucdtect_flac="true"
		# This is needed to let script know that we want auCDtect
		# to create a spectrogram (ie "-A, --aucdtect-spectrogram")
		create_spectrogram="true"
	fi
}

# Display the summary of operations chart
__operation_summary () {
	# Build the operation line in the Summary Of Operations
	__summary_line () {
		# Set up spacing for Operation
		case "${operation}" in
			"Validate with auCDtect")
				operation_spacing="   "
			;;
			"Check MD5 Signature")
				operation_spacing="      "
			;;
			"Compress FLACS")
				operation_spacing="           "
			;;
			"Test Flacs")
				operation_spacing="               "
			;;
			"Testing ReplayGain")
				# Print the outer operation, with the sub operations
				# to follow (from the below case statement)
				printf "%s${yellow}%s${normal}%s${blue}%s${normal}\n" \
				"      " "Applying ReplayGain" " " "|" 

				# Change yellow color to cyan, but leave the yellow
				# name to keep the below case statement sane
				if [[ "${no_color}" != "true" ]] ; then
					yellow="${magenta}"
				fi

				operation="> Testing"
				operation_spacing="                "
			;;
			"Adding ReplayGain")
				operation="> Adding"
				operation_spacing="                 "
			;;
			"Analyzing Tags")
				# Print the outer operation, with the sub operations
				# to follow (from the below case statement)
				printf "%s${yellow}%s${normal}%s${blue}%s${normal}\n" \
				"          " "Retagging Files" " " "|"

				# Change yellow color to cyan, but leave the yellow
				# name to keep the below case statement sane
				if [[ "${no_color}" != "true" ]] ; then
					yellow="${magenta}"
				fi

				operation="> Analyzing"
				operation_spacing="              "
			;;
			"Applying Tags")
				operation="> Applying"
				operation_spacing="               "
			;;
			"Prune METADATA Blocks")
				operation_spacing="    "
			;;
		esac

		case "${operation_summary}" in
			"complete")
				# Set up the printed string with colors
				printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
				"${operation_spacing}" "${operation}" " " "|" " " "Operation Completed"
			;;

			"failed")
				# Add a newline into file descriptor 5 (makes one line total)
				__newline >&5

				# Store everything in fd 5 into an array.  We only grab one line
				read -u5 fail_count

				# Store array into a string
				fail_count="${fail_count[@]}"

				# If ${#fail_count} is one, change the message to singular
				if (( ${#fail_count} == 1 )) ; then
					fail_count_message="${#fail_count} File Failed"
				else
					fail_count_message="${#fail_count} Files Failed"
				fi

				# Set up the printed string with colors
				printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${red}%s${normal}\n" \
				"${operation_spacing}" "${operation}" " " "|" " " "${fail_count_message}"
			;;

			"interrupted")
				# Set up the printed string with colors
				printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
				"${operation_spacing}" "${operation}" " " "|" " " "Operation Interrupted"
			;;

			"did not run")
				# Set up the printed string with colors
				printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
				"${operation_spacing}" "${operation}" " " "|" " " "Operation Did Not Run"
			;;

			*)
				# Should not ever happen!
			;;
		esac
	}

	#---------------------------------------------------------------------------
	# .: CLEANUP SECTION :.
	#---------------------------------------------------------------------------
	# Restore old stty settings, make stty happy
	# by redirecting /dev/stderr
	stty ${old_stty} < /dev/stderr

	# Restore the cursor
	printf "\033[?25h"
	#== .: END CLEANUP SECTION :. ==============================================

	# Begin printing the table

	#if [[ "${replaygain_flac}" == "true" && -n "${adding_replaygain_complete}" ]] ; then
	#	if (( ${#flac_directories_array[@]} < jobs )) ; then
	#		summary_placement=$(( current_row + ${#flac_directories_array[@]} ))
	#	else
	#		summary_placement=$(( current_row + jobs ))
	#	fi
	#fi
#
#	if [[ "${prune_flac}" == "true" && -n "${prune_complete}" ]] ; then
#		if (( ${#total_flacs_array[@]} < jobs )) ; then
#			summary_placement=$(( current_row + ${#total_flacs_array[@]} ))
#		else
#			summary_placement=$(( current_row + jobs ))
#		fi
#	fi

	# Title
	printf "\033[$(( current_row ));2H${blue}%s${normal}\n" \
	"---------------------------------------------------"
	printf "                Summary Of Operations\n"
	printf "${normal} ${blue}-------------------------+-------------------------${normal}\n" \

	# auCDtect operations
	if [[ "${aucdtect_flac}" == "true" && "${aucdtect_complete}" == "true" ]] ; then
		operation="Validate with auCDtect"
		operation_summary="complete"
		__summary_line
	elif [[ "${aucdtect_flac}" == "true" && "${aucdtect_complete}" == "false" ]] ; then
		operation="Validate with auCDtect"
		operation_summary="failed"
		__summary_line
	elif [[ "${aucdtect_flac}" == "true" && "${aucdtect_complete}" == "interrupt" ]] ; then
		operation="Validate with auCDtect"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${aucdtect_flac}" == "true" ]] ; then
		operation="Validate with auCDtect"
		operation_summary="did not run"
		__summary_line
	fi

	# MD5 Check operations
	if [[ "${md5check_flac}" == "true" && "${md5check_complete}" == "true" ]] ; then
		operation="Check MD5 Signature"
		operation_summary="complete"
		__summary_line
	elif [[ "${md5check_flac}" == "true" && "${md5check_complete}" == "false" ]] ; then
		operation="Check MD5 Signature"
		operation_summary="failed"
		__summary_line
	elif [[ "${md5check_flac}" == "true" && "${md5check_complete}" == "interrupt" ]] ; then
		operation="Check MD5 Signature"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${md5check_flac}" == "true" ]] ; then
		operation="Check MD5 Signature"
		operation_summary="did not run"
		__summary_line
	fi

	# Compress Flacs operations
	if [[ "${compress_flac}" == "true" && "${compress_complete}" == "true" ]] ; then
		operation="Compress FLACS"
		operation_summary="complete"
		__summary_line
	elif [[ "${compress_flac}" == "true" && "${compress_complete}" == "false" ]] ; then
		operation="Compress FLACS"
		operation_summary="failed"
		__summary_line
	elif [[ "${compress_flac}" == "true" && "${compress_complete}" == "interrupt" ]] ; then
		operation="Compress FLACS"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${compress_flac}" == "true" ]] ; then
		operation="Compress FLACS"
		operation_summary="did not run"
		__summary_line
	fi

	# Test Flacs operations
	if [[ "${test_flac}" == "true" && "${test_complete}" == "true" ]] ; then
		operation="Test Flacs"
		operation_summary="complete"
		__summary_line
	elif [[ "${test_flac}" == "true" && "${test_complete}" == "false" ]] ; then
		operation="Test Flacs"
		operation_summary="failed"
		__summary_line
	elif [[ "${test_flac}" == "true" && "${test_complete}" == "interrupt" ]] ; then
		operation="Test Flacs"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${test_flac}" == "true" ]] ; then
		operation="Test Flacs"
		operation_summary="did not run"
		__summary_line
	fi

	# ReplayGain test operations
	if [[ "${replaygain_flac}" == "true" && "${testing_replaygain_complete}" == "true" ]] ; then
		operation="Testing ReplayGain"
		operation_summary="complete"
		__summary_line
	elif [[ "${replaygain_flac}" == "true" && "${testing_replaygain_complete}" == "false" ]] ; then
		operation="Testing ReplayGain"
		operation_summary="failed"
		__summary_line
	elif [[ "${replaygain_flac}" == "true" && "${testing_replaygain_complete}" == "interrupt" ]] ; then
		operation="Testing ReplayGain"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${replaygain_flac}" == "true" ]] ; then
		operation="Testing ReplayGain"
		operation_summary="did not run"
		__summary_line
	fi

	# ReplayGain apply operations
	if [[ "${replaygain_flac}" == "true" && "${adding_replaygain_complete}" == "true" ]] ; then
		operation="Adding ReplayGain"
		operation_summary="complete"
		__summary_line
	elif [[ "${replaygain_flac}" == "true" && "${adding_replaygain_complete}" == "false" ]] ; then
		operation="Adding ReplayGain"
		operation_summary="failed"
		__summary_line
	elif [[ "${replaygain_flac}" == "true" && "${adding_replaygain_complete}" == "interrupt" ]] ; then
		operation="Adding ReplayGain"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${replaygain_flac}" == "true" ]] ; then
		operation="Adding ReplayGain"
		operation_summary="did not run"
		__summary_line
	fi

	# Change ${yellow} color back to yellow (could have been
	# changed in ReplayGain operations above)
	if [[ "${no_color}" != "true" ]] ; then
		yellow="\033[33m"
	fi

	# Retag analyze operations
	if [[ "${retag_flac}" == "true" && "${analyzing_retag_complete}" == "true" ]] ; then
		operation="Analyzing Tags"
		operation_summary="complete"
		__summary_line
	elif [[ "${retag_flac}" == "true" && "${analyzing_retag_complete}" == "false" ]] ; then
		operation="Analyzing Tags"
		operation_summary="failed"
		__summary_line
	elif [[ "${retag_flac}" == "true" && "${analyzing_retag_complete}" == "interrupt" ]] ; then
		operation="Analyzing Tags"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${retag_flac}" == "true" ]] ; then
		operation="Analyzing Tags"
		operation_summary="did not run"
		__summary_line
	fi

	# Retag apply operations
	if [[ "${retag_flac}" == "true" && "${applying_retag_complete}" == "true" ]] ; then
		operation="Applying Tags"
		operation_summary="complete"
		__summary_line
	elif [[ "${retag_flac}" == "true" && "${applying_retag_complete}" == "false" ]] ; then
		operation="Applying Tags"
		operation_summary="failed"
		__summary_line
	elif [[ "${retag_flac}" == "true" && "${applying_retag_complete}" == "interrupt" ]] ; then
		operation="Applying Tags"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${retag_flac}" == "true" ]] ; then
		operation="Applying Tags"
		operation_summary="did not run"
		__summary_line
	fi

	# Change ${yellow} color back to yellow (could have been
	# changed in Retag operations above)
	if [[ "${no_color}" != "true" ]] ; then
		yellow="\033[33m"
	fi

	# Prune Flacs operations
	if [[ "${prune_flac}" == "true" && "${prune_complete}" == "true" ]] ; then
		operation="Prune METADATA Blocks"
		operation_summary="complete"
		__summary_line
	elif [[ "${prune_flac}" == "true" && "${prune_complete}" == "false" ]] ; then
		operation="Prune METADATA Blocks"
		operation_summary="failed"
		__summary_line
	elif [[ "${prune_flac}" == "true" && "${prune_complete}" == "interrupt" ]] ; then
		operation="Prune METADATA Blocks"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${prune_flac}" == "true" ]] ; then
		operation="Prune METADATA Blocks"
		operation_summary="did not run"
		__summary_line
	fi

	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"
}

# Function to run commands/operations that are by
# files _ONLY_
__run_parallel_files () {
	# Determine which function should be run in the `trap' via what is specified
	# via ${1} (eg, the operation to be run), returned as ${run_abort}
	__determine_abort "${1}"

	# Run abort function on script exit
	trap "${run_abort}" SIGINT

	# Forces iteration to start at 0, in the event that
	# multiple operations are going to be run
	iteration=0

	# This is the parallel operation to run
	# specified by ${1} when calling this function
	parallel_operation="${1}"

	# Start as many processes as determined by ${jobs}
	for i in "${total_flacs_array[@]:0:${jobs}}" ; do
		# This is the first set of jobs to run, so the placement of each file to
		# display is the current row the cursor is on plus the iteration (the
		# current file [number] being processed), which is zero-based
		placement=$((current_row + iteration))

		# Add one to the iteration to enforce we print one or more, not zero
		((iteration++))

		# Run the specified operation in the background
		"${parallel_operation}" &
	done

	# If the FLAC files to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if (( ${#total_flacs_array[@]} > jobs )) ; then

		# After each newline is read from FIFO, start a new process
		while read ; do

			# If current number of FLACs to process is less than total FLACs
			# found, add another FLAC to process
			if (( iteration < (${#total_flacs_array[@]} - 1) )) ; then
				# Set the current filename ($i) to the current file in the array
				i="${total_flacs_array[${iteration}]}"

				# Add one to the iteration
				((iteration++))

				# Grab the previous position of the recently finished previous
				# file.  This is taken from file descriptor '7', which is placed
				# there after each file is completed, to allow the script to
				# know which file was placed where.  This position is a positive
				# integer (including 0), relational to the the current row
				# which was obtained earlier
				read -u7 -r previous_operation_position

				# Since this is _NOT_ the first set of jobs to run, the
				# placement of each file to display is the current row the
				# cursor is on plus the position of the last completed location
				# of the file, which allows us to dynamically place new jobs
				# where other jobs have completed
				placement="$((current_row + previous_operation_position))"

				# Run the specified operation in the background
				"${parallel_operation}" &

			# Below is processed only if the current directory
			# is equal to the last ${flac_directories_array[@]} index
			else
				# Set the current filename ($i) to the current file in the array
				i="${total_flacs_array[${iteration}]}"

				# Add one to the iteration
				((iteration++))

				# Grab the previous position of the recently finished previous
				# file.  This is taken from file descriptor '7', which is placed
				# there after each file is completed, to allow the script to
				# know which file was placed where.  This position is a positive
				# integer (including 0), relational to the the current row
				# which was obtained earlier
				read -u7 -r previous_operation_position

				# Since this is _NOT_ the first set of jobs to run, the
				# placement of each file to display is the current row the
				# cursor is on plus the position of the last completed location
				# of the file, which allows us to dynamically place new jobs
				# where other jobs have completed
				placement="$((current_row + previous_operation_position))"

				# Run the specified operation in the background
				"${parallel_operation}" &

				# Break out of loop to prevent hanging FIFO
				break
			fi
		done <&3
	fi

	# Wait for children processes
	wait
}

# Function to run commands/operations that are by
# directory _ONLY_
__run_parallel_directories () {
	# Determine which function should be run in the `trap' via what is specified
	# via ${1} (eg, the operation to be run), returned as ${run_abort}
	__determine_abort "${1}"

	# Run abort function on script exit
	trap "${run_abort}" SIGINT

	# Forces iteration to start at 0, in the event that
	# multiple operations are going to be run
	iteration=0

	# This is the parallel operation to run
	# specified by ${1} when calling this function
	parallel_operation="${1}"

	# Start as many processes as determined by ${jobs}
	for i in "${flac_directories_array[@]:0:${jobs}}" ; do
		# This is the first set of jobs to run, so the placement of each file to
		# display is the current row the cursor is on plus the iteration (the
		# current file [number] being processed), which is zero-based
		placement=$((current_row + iteration))

		# Add one to the iteration to enforce we print one or more, not zero
		((iteration++))

		# Run the specified operation in the background
		"${parallel_operation}" &
	done

	# If the directories to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if (( ${#flac_directories_array[@]} > jobs )) ; then

		# After each newline is read from FIFO, start a new process
		while read ; do

			# If current number of directories to process is less than total
			# directories found, add another directory to process
			if (( iteration < (${#flac_directories_array[@]} - 1) )) ; then
				# Set the current directory ($i) to the current directory in the
				# array
				i="${flac_directories_array[${iteration}]}"

				# Add one to the iteration
				((iteration++))

				# Grab the previous position of the recently finished previous
				# directory.  This is taken from file descriptor '7', which is
				# placed there after each directory is completed, to allow the
				# script to know which directory was placed where.  This
				# position is a positive integer (including 0), relational to
				# the the current row which was obtained earlier
				read -u7 -r previous_operation_position

				# Since this is _NOT_ the first set of jobs to run, the
				# placement of each directory to display is the current row the
				# cursor is on plus the position of the last completed location
				# of the directory, which allows us to dynamically place new
				# jobs where other jobs have completed
				placement="$((current_row + previous_operation_position))"

				# Run the specified operation in the background
				"${parallel_operation}" &

			# Below is processed only if the current directory
			# is equal to the last ${flac_directories_array[@]} index
			else
				# Set the current directory ($i) to the current directory in the
				# array
				i="${flac_directories_array[${iteration}]}"

				# Add one to the iteration
				((iteration++))

				# Grab the previous position of the recently finished previous
				# directory.  This is taken from file descriptor '7', which is
				# placed there after each directory is completed, to allow the
				# script to know which directory was placed where.  This
				# position is a positive integer (including 0), relational to
				# the the current row which was obtained earlier
				read -u7 -r previous_operation_position

				# Since this is _NOT_ the first set of jobs to run, the
				# placement of each directory to display is the current row the
				# cursor is on plus the position of the last completed location
				# of the directory, which allows us to dynamically place new
				# jobs where other jobs have completed
				placement="$((current_row + previous_operation_position))"

				# Run the specified operation in the background
				"${parallel_operation}" &

				# Break out of loop to prevent hanging FIFO
				break
			fi
		done <&3
	fi

	# Wait for children processes
	wait
}
#== .: END VARIOUS COMMANDS :. =================================================


#-------------------------------------------------------------------------------
# .: OPERATIONS :.
#-------------------------------------------------------------------------------
# Test ReplayGain
__operation_test_replaygain () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in previous trap
	trap __kill_jobs EXIT

	# Print current FLAC being processed
	__print_sub_current_flac

	# Check if file is a FLAC file (capture output) via obtaining the sample
	# rate of the current file.  The sample rate captured will be tested against
	# later on.  Hide STDERR as we'll test the exit code instead
	current_sample_rate="$(metaflac --show-sample-rate "${i}" 2>/dev/null)"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then

		# Error with FLAC file, display failed/error
		__print_sub_progress_failed

		# Log FLAC failure
		printf "\n%s\n%s\n%s\n%s\n\n%s\n" \
			   "            FLAC FILE  :  ${i##*/}" \
			   "   FLAC FILE LOCATION  :  ${i%/*}" \
			   "                       :" \
			   "                ERROR  :  Not a real FLAC file (or empty file)." \
			   "--------------------------------------------------------------------------------" \
			   >> "${replay_test_errors}"

		# Add one to fail fd
		printf '.' >&5
	else
		# File is OK, test if sample rate is above 48kHz and the version of
		# `metaflac' installed is greater than 1.2.1
		if (( current_sample_rate > 48000 )) ; then

			# Sample rate is greater than 48kHz, so check to make sure the
			# version of `metaflac' is greater than 1.2.1
			if (( metaflac_version < 3 )) ; then
				# Old version of `metaflac' installed, display skipped
				__print_sub_progress_issue

				# The `metaflac' version installed is NOT greater than 1.2.1 so
				# skip processing current FLAC file, logging why it was skipped
				printf "\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
					   "            FLAC FILE  :  ${i##*/}" \
					   "   FLAC FILE LOCATION  :  ${i%/*}" \
					   "                       :" \
					   "                ERROR  :  FLAC file has a sample rate greater than 48kHz and was" \
					   "                       :  subsequently skipped because the version of \`flac'" \
					   "                       :  currently installed is NOT greater than 1.2.1, which" \
					   "                       :  is required to process high sample rate FLAC files." \
					   "--------------------------------------------------------------------------------" \
					   >> "${replay_test_errors}"

				# Add one to fail fd
				printf '.' >&5
			else
				# FLAC is ok, display ok
				__print_sub_progress_ok
			fi
		else
			# FLAC is ok, display ok
			__print_sub_progress_ok
		fi
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (7), to be used by the next job
	__store_position

	# Print newline into FIFO after completion
	__newline >&3
}

# Process Replaygain (only add values if missing)
__operation_replaygain_noforce () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in previous trap
	trap __kill_jobs EXIT

	# Print current directory being processed
	__print_current_directory

	# ${i} is the parent directory to the FLAC files
	# ${j} is a FLAC file -> under ${i}
	for j in "${i}"/*${flac_extension} ; do
		# Grab all of the ReplayGain tags
		mapfile -n0 -t replaygain_array < \
		<(
			metaflac \
				--show-tag=REPLAYGAIN_REFERENCE_LOUDNESS \
				--show-tag=REPLAYGAIN_TRACK_GAIN \
				--show-tag=REPLAYGAIN_TRACK_PEAK \
				--show-tag=REPLAYGAIN_ALBUM_GAIN \
				--show-tag=REPLAYGAIN_ALBUM_PEAK \
				"${j}"
		)

		# Strip out the tag fields (eg. REPLAYGAIN_TRACK_GAIN=)
		replaygain_array="${replaygain_array[@]#*=}"

		# Test if any ReplayGain values are empty (if there are less
		# than 5 values in the replaygain array)
		if (( ${#replaygain_array[@]} < 5 )) ; then
			# At _least_ one tag is missing from current file, so
			# apply new ReplayGain values
			#
			# Add ReplayGain to FLAC files under directory.  Metaflac
			# automatically removes old ReplayGain values (if any) before
			# proceeding
			metaflac --add-replay-gain "${i}"/*${flac_extension} >/dev/null 2>&1

			# Exit code 130 is SIGINT so only check for exit code '1'
			if (( ${?} == 1 )) ; then

				# Failed applyig replaygain values, display failed/error
				__print_sub_progress_failed

				# Log ReplayGain error
				printf "\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
					   "            DIRECTORY  :  ${i##*/}" \
					   "  FULL DIRECTORY PATH  :  ${i%/*}" \
					   "                       :" \
					   "                ERROR  :  There was a problem applying ReplayGain values to the" \
					   "                          FLAC files in the above directory.  The most common  " \
					   "                          reason for failure is if at least one FLAC has a" \
					   "                          different sample rate then another FLAC file in the" \
					   "                          same directory.  Album ReplayGain values cannot be" \
					   "                          to FLAC files with varying sample rates." \
					   "--------------------------------------------------------------------------------" \
					   >> "${replay_add_errors}"

				# Add one to fail fd
				printf '.' >&5

				# Placeholder variable tested after this loop
				# if the loop completes with 'break'
				broke_out_of_loop="true"

				# Break out of loop and on to next directory
				break
			else
				# FLAC is ok, display ok
				__print_sub_progress_ok
			fi
		else
			# FLAC is ok, display ok
			__print_sub_progress_ok
		fi
	done

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (7), to be used by the next job
	__store_position

	# Print newline into FIFO after completion
	__newline >&3
}

# Process ReplayGain (force new values)
__operation_replaygain_force () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in previous trap
	trap __kill_jobs EXIT

	# Print current directory being processed
	__print_current_directory

	# Add ReplayGain to FLAC files under directory
	metaflac --add-replay-gain "${i}"/*${flac_extension} >/dev/null 2>&1

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then

		# Error with FLAC file, display failed/error
		__print_sub_progress_failed

		# Log ReplayGain error
		printf "\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
			   "            DIRECTORY  :  ${i##*/}" \
			   "  FULL DIRECTORY PATH  :  ${i%/*}" \
			   "                       :" \
			   "                ERROR  :  There was a problem applying ReplayGain values to the" \
			   "                          FLAC files in the above directory.  The most common  " \
			   "                          reason for failure is if at least one FLAC has a" \
			   "                          different sample rate then another FLAC file in the" \
			   "                          same directory.  Album ReplayGain values cannot be" \
			   "                          to FLAC files with varying sample rates." \
			   "--------------------------------------------------------------------------------" \
			   >> "${replay_add_errors}"

		# Add one to fail fd
		printf '.' >&5
	else
		# FLAC is ok, display ok
		__print_sub_progress_ok
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (7), to be used by the next job
	__store_position

	# Print newline into FIFO after completion
	__newline >&3
}

# Compress FLAC files
__operation_compress () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in previous trap
	trap __kill_jobs EXIT

	# Test for COMPRESSION level in FLAC file. Hide error output since
	# we'll be verifying the FLAC file later
	COMPRESSION="$(metaflac --show-tag=COMPRESSION "${i}" 2> /dev/null)"
	COMPRESSION="${COMPRESSION#*=}"

	if (( COMPRESSION != compression_level )) ; then
		# Print current FLAC being processed
		__print_current_flac

		# This is a variable to determine which type of process is used to get
		# the current percentage during the operation
		obtain_percentage="__obtain_compress_percentage"

		# Compress FLAC file
		# Display the current file with progress completed thus far via a
		# percentage and progress bar
		flac -f -${compression_level} -V "${i}" 2> >(while read -r -d% percent_complete ; do
			__print_progress
		done) >/dev/null

		# Exit code 130 is SIGINT so only check for exit code '1'
		if (( ${?} == 1 )) ; then

			# Error with FLAC file, display failed/error
			__print_progress_failed

			# Log FLAC failure
			printf "\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
				   "            FLAC FILE  :  ${i##*/}" \
				   "   FLAC FILE LOCATION  :  ${i%/*}" \
				   "                       :" \
				   "                ERROR  :  The FLAC file failed verification during it's" \
				   "                       :  compression.  Either the FLAC file is NOT a real FLAC" \
				   "                       :  file, or it's corrupt." \
				   "--------------------------------------------------------------------------------" \
				   >> "${verify_errors}"

			# Add one to fail fd
			printf '.' >&5
		else
			metaflac \
				--remove-tag=COMPRESSION \
				--set-tag=COMPRESSION=${compression_level} "${i}"

			# FLAC is ok, display ok
			__print_progress_ok
		fi

	# If already at compression_level, test the FLAC file instead
	# or skip the file if '-C, --compress-notest' was specified
	else
		if [[ "${skip_test}" != "true" ]] ; then
			# Print current FLAC being processed
			__print_current_flac

			# This is a variable to determine which type of process is used to
			# get the current percentage during the operation
			obtain_percentage="__obtain_test_percentage"

			# Test FLAC file
			# Display the current file with progress completed thus far via a
			# percentage and progress bar
			flac -t "${i}" 2> >(while read -r -d% percent_complete ; do
				__print_progress
			done) >/dev/null

			# Exit code 130 is SIGINT so only check for exit code '1'
			if (( ${?} == 1 )) ; then

				# Error with FLAC file, display failed/error
				__print_progress_failed

				# Log FLAC failure
				printf "\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
					   "            FLAC FILE  :  ${i##*/}" \
					   "   FLAC FILE LOCATION  :  ${i%/*}" \
					   "                       :" \
					   "                ERROR  :  The FLAC file failed verification during it's" \
					   "                       :  testing.  Either the FLAC file is NOT a real FLAC" \
					   "                       :  file, or it's corrupt." \
					   "--------------------------------------------------------------------------------" \
					   >> "${verify_errors}"

				# Add one to fail fd
				printf '.' >&5
			else
				# FLAC is ok, display ok
				__print_progress_ok
			fi
		else
			# Print skipped FLAC
			__print_skip_flac
		fi
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (7), to be used by the next job
	__store_position

	# Print newline into FIFO after completion
	__newline >&3
}

# Test FLAC files
__operation_test () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in previous trap
	trap __kill_jobs EXIT

	# Print current FLAC being processed
	__print_current_flac

	# This is a variable to determine which type of process is used to get the
	# current percentage during the operation
	obtain_percentage="__obtain_test_percentage"

	# Test FLAC file
	# Display the current file with progress completed thus far via a
	# percentage and progress bar
	flac -t "${i}" 2> >(while read -r -d% percent_complete ; do
		__print_progress
	done) >/dev/null

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then

		# Error with FLAC file, display failed/error
		__print_progress_failed

		# Log FLAC failure
		printf "\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
			   "            FLAC FILE  :  ${i##*/}" \
			   "   FLAC FILE LOCATION  :  ${i%/*}" \
			   "                       :" \
			   "                ERROR  :  The FLAC file failed verification during it's" \
			   "                       :  testing.  Either the FLAC file is NOT a real FLAC" \
			   "                       :  file, or it's corrupt." \
			   "--------------------------------------------------------------------------------" \
			   >> "${test_errors}"

		# Add one to fail fd
		printf '.' >&5
	else
		# FLAC is ok, display ok
		__print_progress_ok
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (7), to be used by the next job
	__store_position

	# Print newline into FIFO after completion
	__newline >&3
}

# Test FLAC validity with auCDtect
__operation_aucdtect () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in previous trap
	trap __kill_jobs EXIT

	# Print current FLAC being processed
	__print_current_flac

	# Get the bit depth of a FLAC file, also used to check
	# if FLAC file is real.  Hide stderr output
	bits="$(metaflac --show-bps "${i}" 2> /dev/null)"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then

		# Error with FLAC file, display failed/error
		__print_progress_failed

		# Log FLAC failure
		printf "\n%s\n%s\n%s\n%s\n\n%s\n" \
			   "            FLAC FILE  :  ${i##*/}" \
			   "   FLAC FILE LOCATION  :  ${i%/*}" \
			   "                       :" \
			   "                ERROR  :  Not a real FLAC file (or empty file)." \
			   "--------------------------------------------------------------------------------" \
			   >> "${aucdtect_errors}"

		# Add one to fail fd
		printf '.' >&5

	# Skip the FLAC file if it has a bit depth greater
	# than 16 since auCDtect doesn't support audio
	# files with a higher resolution than a CD.
	elif (( bits > 16 )) ; then

		# Print skipped FLAC
		__print_skip_flac

		# Log skipped FLAC file
		printf "\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
			   "            FLAC FILE  :  ${i##*/}" \
			   "   FLAC FILE LOCATION  :  ${i%/*}" \
			   "                       :" \
			   "                ERROR  :  FLAC file has a bit depth greater than 16 and was" \
			   "                       :  subsequently skipped.  auCDtect only supports CD" \
			   "                       :  quality FLAC files (16bit or lower)." \
			   "--------------------------------------------------------------------------------" \
			   >> "${aucdtect_errors}"

		# Add one to fail fd
		printf '.' >&5

	# FLAC checks out, continue processing
	else
		# The WAV file to be created from current FLAC file
		decoded_wav="${i%${flac_extension}}_redoflacs_"$$".wav"

		# This is a variable to determine which type of process is used to get
		# the current percentage during the operation
		obtain_percentage="__obtain_decode_percentage"

		# Decompress FLAC to WAV so auCDtect can read the audio file
		# Display the current file with progress completed thus far via a
		# percentage and progress bar
		flac -d "${i}" -o "${decoded_wav}" 2> >(while read -r -d% percent_complete ; do
			__print_progress
		done) >/dev/null

		# Exit code 130 is SIGINT so only check for exit code '1'.  If FLAC file
		# failed decoding to WAV, log error, otherwise continue processing
		if (( ${?} == 1 )) ; then

			# Error with FLAC file, display failed/error
			__print_progress_failed

			# Log FLAC failure
			printf "\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
				   "            FLAC FILE  :  ${i##*/}" \
				   "   FLAC FILE LOCATION  :  ${i%/*}" \
				   "                       :" \
				   "                ERROR  :  Failed decoding FLAC file.  Please verify the FLAC" \
				   "                       :  file is not corrupt." \
				   "--------------------------------------------------------------------------------" \
				   >> "${aucdtect_errors}"

			# Add one to fail fd
			printf '.' >&5

		else
			# Decoded FLAC is ok, display ok
			__print_progress_ok

			# This is a variable to determine which type of process is used to get
			# the current percentage during the operation
			obtain_percentage="__obtain_aucdtect_percentage"

			# 'export MALLOC_CHECK_' allows the dynamic linked version of
			# `auCDTECT' to run without throwing errors
			export MALLOC_CHECK_="0"

			# The actual auCDtect command with lowest accuracy setting (for
			# speed).  STDOUT is sent to file descriptor '4'
			"${aucdtect_command}" -m40 "${decoded_wav}" 2> >(while read -r -d% percent_complete ; do
				# Display the current file with progress completed thus far via
				# a percentage and progress bar
				__print_progress
			done) >&4

			# Exit code 130 is SIGINT so only check for exit code '1'
			if (( ${?} == 1 )) ; then

				# Error with FLAC file, display failed/error
				__print_progress_failed

				# Log FLAC failure
				printf "\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
					   "            FLAC FILE  :  ${i##*/}" \
					   "   FLAC FILE LOCATION  :  ${i%/*}" \
					   "                       :" \
					   "             WAV FILE  :  ${decoded_wav##*/}" \
					   "    WAV FILE LOCATION  :  ${decoded_wav%/*}" \
					   "                       :" \
					   "                ERROR  :  auCDtect failed to analyze the decoded WAV file." \
					   "                       :  Something may have happened when decoding the above" \
					   "                       :  FLAC file.  Please verify the FLAC file is not" \
					   "                       :  corrupt." \
					   "--------------------------------------------------------------------------------" \
					   >> "${aucdtect_errors}"

				# Add one to fail fd
				printf '.' >&5

			else
				# Possible issue with FLAC file, display issue
				__print_progress_issue

				# Grab the conclusion of auCDtect's command
				# Below options prevents hanging FIFO by only reading
				# what is necessary:
				#    -s7:  Discard first seven lines from auCDtect's output
				#    -n2:  Only grab 2 lines from auCDtect's output
				#     -t:  Remove trailing newlines from auCDtect's output
				#    -u4:  Obtain auCDtect's output from file descriptor '4'
				#  array:  Store captured output into 'aucdtect_check_array'
				mapfile -s7 -n2 -t -u4 aucdtect_check_array

				# If there is an issue with the processed FLAC file, run
				# auCDtect once again with highest setting
				if [[ "${aucdtect_check_array[0]}" != "This track looks like CDDA with probability 100%" ]] ; then

					# The actual auCDtect command with highest accuracy setting.
					# STDOUT is sent to file descriptor '4'
					"${aucdtect_command}" -m0 "${decoded_wav}" 2> >(while read -r -d% percent_complete ; do
						# Display the current file with progress completed thus far via
						# a percentage and progress bar
						__print_progress
					done) >&4

					# Exit code 130 is SIGINT so only check for exit code '1'
					if (( ${?} == 1 )) ; then

						# Error with FLAC file, display failed/error
						__print_progress_failed

						# Log FLAC failure
						printf "\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
							   "            FLAC FILE  :  ${i##*/}" \
							   "   FLAC FILE LOCATION  :  ${i%/*}" \
							   "                       :" \
							   "             WAV FILE  :  ${decoded_wav##*/}" \
							   "    WAV FILE LOCATION  :  ${decoded_wav%/*}" \
							   "                       :" \
							   "                ERROR  :  auCDtect failed to analyze the decoded WAV file." \
							   "                       :  Something may have happened when decoding the above" \
							   "                       :  FLAC file.  Please verify the FLAC file is not" \
							   "                       :  corrupt." \
							   "--------------------------------------------------------------------------------" \
							   >> "${aucdtect_errors}"

						# Add one to fail fd
						printf '.' >&5

					else
						# Grab the conclusion of auCDtect's command
						# Below options prevents hanging FIFO by only reading
						# what is necessary:
						#    -s7:  Discard first seven lines from auCDtect's output
						#    -n2:  Only grab 2 lines from auCDtect's output
						#     -t:  Remove trailing newlines from auCDtect's output
						#    -u4:  Obtain auCDtect's output from file descriptor '4'
						#  array:  Store captured output into 'aucdtect_check_array'
						mapfile -s7 -n2 -t -u4 aucdtect_check_array

						# There is an issue with the processed FLAC file
						if [[ "${aucdtect_check_array[0]}" != "This track looks like CDDA with probability 100%" ]] ; then

							# If user specified '-A, --aucdtect-spectrogram', then
							# create a spectrogram with SoX and change logging accordingly
							if [[ "${create_spectrogram}" == "true" ]] ; then

								# Check whether to place spectrogram images in user-defined location
								if [[ -z "${spectrogram_location}" ]] ; then
									# Obtain basename of current FLAC file
									flac_file="${i##*/}"

									# Obtain dirname of current FLAC file
									spectrogram_dirname="${i%/*}"

									# Create the spectrogram with '.png' as the
									# file extension, placed in the same
									# directory as the current FLAC file
									spectrogram_picture="${spectrogram_dirname}/[${iteration}] ${flac_file%${flac_extension}}.png"
								else
									# Obtain basename of current FLAC file
									flac_file="${i##*/}"

									# Create the spectrogram with '.png' as the
									# file extension, placed in the user-defined
									# location
									spectrogram_picture="${spectrogram_location}/[${iteration}] ${flac_file%${flac_extension}}.png"
								fi

								# Print current FLAC being processed
								__print_current_flac

								# This is a variable to determine which type of
								# process is used to get the current percentage
								# during the operation
								obtain_percentage="__obtain_spectrogram_percentage"

								# SoX command to create the spectrogram and
								# place it in spectrogram_picture.  Use the
								# following arguments to create the highest
								# resolution spectrograms:
								#   -x 5000
								#   -y 1025
								"${sox_command}" "${decoded_wav}" \
									-S \
									-n spectrogram \
									-c '' \
									-t "${i}" \
									-p 1 \
									-z 90 \
									-Z 0 \
									-q 249 \
									-w Hann \
									-x 1800 \
									-y 513 \
									-o "${spectrogram_picture}" 2> >(
										while read -r -d% percent_complete ; do
											# Display the current file with
											# progress completed thus far via a
											# percentage and progress bar
											__print_progress
										done
									) >/dev/null

								# Error with FLAC file, display failed/error
								__print_progress_issue

								# Log auCDtect report
								printf "\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
									   "            FLAC FILE  :  ${i##*/}" \
									   "                       :" \
									   "      AUCDTECT REPORT  :  ${aucdtect_check_array[0]}" \
									   "   FLAC FILE LOCATION  :  ${i%/*}" \
									   "                       :" \
									   "    SPECTROGRAM IMAGE  :  ${spectrogram_picture##*/}" \
									   " SPECTROGRAM LOCATION  :  ${spectrogram_picture%/*}" \
									   "--------------------------------------------------------------------------------" \
									   >> "${aucdtect_errors}"

								# Add one to fail fd
								printf '.' >&5

							else
								# Error with FLAC file, display failed/error
								__print_progress_issue

								# Log auCDtect report
								printf "\n%s\n%s\n%s\n%s\n\n%s\n" \
									   "            FLAC FILE  :  ${i##*/}" \
									   "                       :" \
									   "      AUCDTECT REPORT  :  ${aucdtect_check_array[0]}" \
									   "   FLAC FILE LOCATION  :  ${i%/*}" \
									   "--------------------------------------------------------------------------------" \
									   >> "${aucdtect_errors}"

								# Add one to fail fd
								printf '.' >&5
							fi
						else
							# FLAC is ok, display ok
							__print_progress_ok
						fi
					fi
				else
					# FLAC is ok, display ok
					__print_progress_ok
				fi

				# Remove temporary WAV file
				rm "${decoded_wav}"
			fi
		fi
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (7), to be used by the next job
	__store_position

	# Print newline into FIFO after completion
	__newline >&3
}

# Check MD5 in each FLAC file
__operation_md5_check () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in previous trap
	trap __kill_jobs EXIT

	# Print current FLAC being processed
	__print_current_flac

	# Get the MD5 checksum (hide stderr output).  Also
	# used to check if FLAC file is real
	md5_sum="$(metaflac --show-md5sum "${i}" 2> /dev/null)"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then

		# Error with FLAC file, display failed/error
		__print_progress_failed

		# Log FLAC failure
		printf "\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
			   "            FLAC FILE  :  ${i##*/}" \
			   "   FLAC FILE LOCATION  :  ${i%/*}" \
			   "                       :" \
			   "                ERROR  :  The FLAC file failed verification during it's" \
			   "                       :  testing.  Either the FLAC file is NOT a real FLAC" \
			   "                       :  file, or it's corrupt." \
			   "--------------------------------------------------------------------------------" \
			   >> "${md5_errors}"

		# Add one to fail fd
		printf '.' >&5

	# FLAC file is real, check for unset MD5 checksum.  We cannot use an
	# arithmetic expression as any amount of 0's will equal the expression
	# below
	elif [[ "${md5_sum}" == "00000000000000000000000000000000" ]] ; then

		# Error with FLAC file, display failed/error
		__print_progress_failed

		# Log FLAC failure
		printf "\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
			   "            FLAC FILE  :  ${i##*/}" \
			   "   FLAC FILE LOCATION  :  ${i%/*}" \
			   "                       :" \
			   "                ERROR  :  The MD5 signature is unset (eg. a string of zeroes)." \
			   "                       :  This _may_ indicate a faulty FLAC file or the FLAC" \
			   "                       :  file was encoded with a third-party encoder which" \
			   "                       :  does not embed an MD5 signature in the STREAMINFO" \
			   "                       :  block." \
			   "--------------------------------------------------------------------------------" \
			   >> "${md5_errors}"

		# Add one to fail fd
		printf '.' >&5
	else
		# FLAC is ok, display ok
		__print_progress_ok
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (7), to be used by the next job
	__store_position

	# Print newline into FIFO after completion
	__newline >&3
}

# Analyze FLAC tags
__operation_analyze_tags () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in previous trap
	trap __kill_jobs EXIT

	# Print current FLAC being processed
	__print_analyzing_tags

	# Start spinner only if this is the first FLAC file being processed
	__start_spinner

	# Check if file is a FLAC file (variable hides output)
	check_flac="$(metaflac --show-md5sum "${i}" 2>&1)"

	# If above command return anything other than '0', log output
	if (( ${?} != 0 )) ; then

		# File is not a FLAC file, display failed
		__print_failed_flac

		# Log FLAC failure
		printf "\n%s\n%s\n%s\n%s\n\n%s\n" \
			   "            FLAC FILE  :  ${i##*/}" \
			   "   FLAC FILE LOCATION  :  ${i%/*}" \
			   "                       :" \
			   "                ERROR  :  Not a real FLAC file (or empty file)." \
			   "--------------------------------------------------------------------------------" \
			   >> "${metadata_errors}"

		# Add one to fail fd
		printf '.' >&5
	else
		# Iterate through each tag field and check if tag is missing
		for j in "${tags[@]}" ; do
			# Check if ALBUMARTIST is in tag array and apply operations on
			# the tag field if it exists
			if [[ "${j}" == "ALBUMARTIST" ]] ; then
				# ALBUMARTIST exists in tag array so allow script to check the
				# various naming conventions within the FLAC files (ie,
				# 'ALBUM ARTIST' or 'ALBUM_ARTIST')

				# "ALBUMARTIST" or "ALBUM ARTIST" or "ALBUM_ARTIST", case-insensitive
				if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${i}")" ]] ; then
					show_tag_list+=( "--show-tag=ALBUMARTIST" )

				elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${i}")" ]] ; then
					show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

				elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${i}")" ]] ; then
					show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
				fi
			else
				# Build up metaflac '--show-tag=' list
				show_tag_list+=( "--show-tag=${j}" )
			fi
		done

		# Load up all the tag values for current file
		mapfile -n0 -t metaflac_tag_array < \
		<(
			metaflac \
				"${show_tag_list[@]}" \
				"${i}"
		)

		# Take above tag values and create an associative
		# array using TAG_FIELD=TAG_VALUE as the key/value pair
		#
		# Specifically declare an empty associative array
		declare -A temp_tag_array

		# Run through the tag array from above and store
		# the values into a temporary tag array
		for tag_field_value in "${metaflac_tag_array[@]}" ; do
			# This is the tag field (eg. TITLE)
			tag_field="${tag_field_value%%=*}"

			# Enforce the tag field to be uppercase
			# ${tag_field_value} below is the tag value
			temp_tag_array+=( ["${tag_field^^}"]="${tag_field_value#*=}" )
		done

		# Run through the tags array and test each tag value from
		# ${temp_tag_array} with the currently processed tag in ${tag[@]}.  For
		# each match found, test if the tag value is null, reporting any missing
		# tags. Then remove the tag field (index) from the ${temp_tag_array}, so
		# the next iteration is faster and we can check for missing tags (tag
		# fields)
		for j in "${tags[@]}" ; do

			# If the total # of indices in the temporary tag array is above
			# 0, continue testing, else store missing tag (${j}) into the
			# missing tags array
			if (( ${#temp_tag_array[@]} > 0 )) ; then

				# Compare each tag field from the temporary array to ${j},
				# checking if they are equal and if so, check for missing
				# tag values
				for temp_tag_field in "${!temp_tag_array[@]}" ; do
					# Both tag fields are equal
					if [[ "${j}" == "${temp_tag_field}" ]] ; then
						# Check if tag value is null, logging missing tags if so
						if [[ -z "${temp_tag_array[${temp_tag_field}]}" ]] ; then
							if [[ "${file_printed}" != "true" ]] ; then
								# First instance of missing tag for current file
								missing_tags_array+=( "                ERROR  :  ${j} tag not found" )
								file_printed="true"
							else
								# If more than one missing tag in current file,
								# don't print out filename, just the missing tag
								missing_tags_array+=( "                       :  ${j} tag not found" )
							fi
						fi

						# Remove the current tag field from the temporary tag
						# array since it's been matched already
						unset -v temp_tag_array[${temp_tag_field}]

						# This variable let's the script know that the current
						# tag, ${j} has been matched up with a tag field in
						# ${temp_tag_array[@]}
						tag_match="true"

						# Break out of loop since the tag fields have been
						# matched, continuing on to the next iteration of ${j}
						break
					fi
				done

				# If there wasn't a tag field in the temporary tag array
				# ( eg. ${temp_tag_array[@]} ) that matched ${j}, the FLAC file
				# must have a missing tag, so log it by throwing the missing tag
				# into the missing tags array
				if [[ "${tag_match}" != "true" ]] ; then
					if [[ "${file_printed}" != "true" ]] ; then
						# First instance of missing tag for current file
						missing_tags_array+=( "                ERROR  :  ${j} tag not found" )
						file_printed="true"
					else
						# If more than one missing tag in current file,
						# don't print out filename, just the missing tag
						missing_tags_array+=( "                       :  ${j} tag not found" )
					fi
				fi

				# Reset the value of tag match (if any) for the next iteration
				# of ${j}
				unset -v tag_match

			# The total # of indices in the temporary tag array is 0, so
			# whatever is left in ${tags[@]} represented by ${j} is logged
			# as missing
			else
				if [[ "${file_printed}" != "true" ]] ; then
					# First instance of missing tag for current file
					missing_tags_array+=( "                ERROR  :  ${j} tag not found" )
					file_printed="true"
				else
					# If more than one missing tag in current file,
					# don't print out filename, just the missing tag
					missing_tags_array+=( "                       :  ${j} tag not found" )
				fi
			fi
		done

		# If missing_tags_array is not empty, there are missing
		# tags in the current file so log output
		if [[ -n "${missing_tags_array[@]}" ]] ; then

			# Create a temporary array housing the missing tags
			tmp_tag_array=(
				""
				"            FLAC FILE  :  ${i##*/}"
				"   FLAC FILE LOCATION  :  ${i%/*}"
				"                       :"
				"${missing_tags_array[@]}"
				""
				"--------------------------------------------------------------------------------"
			)

			# Log the missing tags
			printf "%s\n" "${tmp_tag_array[@]}" >> "${metadata_errors}"

			# Add one to fail fd
			printf '.' >&5
		fi
	fi

	# Print newline into FIFO after completion
	__newline >&3
}

# Analyze FLAC tags (not logging missing COVERART tag)
__operation_analyze_tags_dont_log_coverart () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in previous trap
	trap __kill_jobs EXIT

	# Print current FLAC being processed
	__print_analyzing_tags

	# Start spinner only if this is the first FLAC file being processed
	__start_spinner

	# Check if file is a FLAC file (variable hides output)
	check_flac="$(metaflac --show-md5sum "${i}" 2>&1)"

	# If above command return anything other than '0', log output
	if (( ${?} != 0 )) ; then

		# File is not a FLAC file, display failed
		__print_failed_flac

		# Log FLAC failure
		printf "\n%s\n%s\n%s\n%s\n\n%s\n" \
			   "            FLAC FILE  :  ${i##*/}" \
			   "   FLAC FILE LOCATION  :  ${i%/*}" \
			   "                       :" \
			   "                ERROR  :  Not a real FLAC file (or empty file)." \
			   "--------------------------------------------------------------------------------" \
			   >> "${metadata_errors}"

		# Add one to fail fd
		printf '.' >&5
	else
		# Album artwork is to be kept so preserve COVERART by adding
		# it to the tag array (temporary)
		tags+=( COVERART )

		# Iterate through each tag field and check if tag is missing (except
		# for the COVERART tag)
		for j in "${tags[@]}" ; do
			# Check if ALBUMARTIST is in tag array and apply operations on
			# the tag field if it exists
			if [[ "${j}" == "ALBUMARTIST" ]] ; then
				# ALBUMARTIST exists in tag array so allow script to check the
				# various naming conventions within the FLAC files (ie,
				# 'ALBUM ARTIST' or 'ALBUM_ARTIST')

				# "ALBUMARTIST" or "ALBUM ARTIST" or "ALBUM_ARTIST", case-insensitive
				if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${i}")" ]] ; then
					show_tag_list+=( "--show-tag=ALBUMARTIST" )

				elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${i}")" ]] ; then
					show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

				elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${i}")" ]] ; then
					show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
				fi
			else
				# Build up metaflac '--show-tag=' list
				show_tag_list+=( "--show-tag=${j}" )
			fi

			# Check if COVERART exists and is not null
			if [[ "${j}" == "COVERART" ]] ; then
				# Obtain COVERART value
				coverart_value="$(metaflac --show-tag=COVERART "${i}")"

				# If COVERART value is not null, so log it exists and that
				# COVERART tag is depcrated
				if [[ -n "${coverart_value#*=}" ]] ; then
					printf "\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
						   "            FLAC FILE  :  ${i##*/}" \
						   "   FLAC FILE LOCATION  :  ${i%/*}" \
						   "                       :" \
						   "                ERROR  :  COVERART tag is DEPRECATED in above file.  Consider" \
						   "                       :  migrating to the new format:  METADATA_BLOCK_PICTURE" \
						   "--------------------------------------------------------------------------------" \
						   >> "${metadata_errors}"

					# Add one to fail fd
					printf '.' >&5
				fi
			fi
		done

		# Load up all the tag values for current file
		mapfile -n0 -t metaflac_tag_array < \
		<(
			metaflac \
				"${show_tag_list[@]}" \
				"${i}"
		)

		# Take above tag values and create an associative
		# array using TAG_FIELD=TAG_VALUE as the key/value pair
		#
		# Specifically declare an empty associative array
		declare -A temp_tag_array

		# Run through the tag array from above and store
		# the values into a temporary tag array
		for tag_field_value in "${metaflac_tag_array[@]}" ; do
			# This is the tag field (eg. TITLE)
			tag_field="${tag_field_value%%=*}"

			# Enforce the tag field to be uppercase
			# ${tag_field_value} below is the tag value
			temp_tag_array+=( ["${tag_field^^}"]="${tag_field_value#*=}" )
		done

		# Run through the tags array and test each tag value from
		# ${temp_tag_array} with the currently processed tag in ${tag[@]}.  For
		# each match found, test if the tag value is null, reporting any missing
		# tags. Then remove the tag field (index) from the ${temp_tag_array}, so
		# the next iteration is faster and we can check for missing tags (tag
		# fields)
		for j in "${tags[@]}" ; do

			# If the total # of indices in the temporary tag array is above
			# 0, continue testing, else store missing tag (${j}) into the
			# missing tags array
			if (( ${#temp_tag_array[@]} > 0 )) ; then

				# Compare each tag field from the temporary array to ${j},
				# checking if they are equal and if so, check for missing
				# tag values.
				# Skip output of COVERART tag as this is a temporary
				# addition to the tag array (for processing legacy artwork)
				for temp_tag_field in "${!temp_tag_array[@]}" ; do
					# Both tag fields are equal
					if [[ "${j}" == "${temp_tag_field}" && "${j}" != "COVERART" ]] ; then
						# Check if tag value is null, logging missing tags if so
						if [[ -z "${temp_tag_array[${temp_tag_field}]}" ]] ; then
							if [[ "${file_printed}" != "true" ]] ; then
								# First instance of missing tag for current file
								missing_tags_array+=( "                ERROR  :  ${j} tag not found" )
								file_printed="true"
							else
								# If more than one missing tag in current file,
								# don't print out filename, just the missing tag
								missing_tags_array+=( "                       :  ${j} tag not found" )
							fi
						fi

						# Remove the current tag field from the temporary tag
						# array since it's been matched already
						unset -v temp_tag_array[${temp_tag_field}]

						# This variable let's the script know that the current
						# tag, ${j} has been matched up with a tag field in
						# ${temp_tag_array[@]}
						tag_match="true"

						# Break out of loop since the tag fields have been
						# matched, continuing on to the next iteration of ${j}
						break
					fi
				done

				# If there wasn't a tag field in the temporary tag array
				# ( eg. ${temp_tag_array[@]} ) that matched ${j}, the FLAC file
				# must have a missing tag, so log it by throwing the missing tag
				# into the missing tags array.  Also skip logging of COVERART tag
				if [[ "${tag_match}" != "true" && "${j}" != "COVERART" ]] ; then
					if [[ "${file_printed}" != "true" ]] ; then
						# First instance of missing tag for current file
						missing_tags_array+=( "                ERROR  :  ${j} tag not found" )
						file_printed="true"
					else
						# If more than one missing tag in current file,
						# don't print out filename, just the missing tag
						missing_tags_array+=( "                       :  ${j} tag not found" )
					fi
				fi

				# Reset the value of tag match (if any) for the next iteration
				# of ${j}
				unset -v tag_match

			# The total # of indices in the temporary tag array is 0, so
			# whatever is left in ${tags[@]} represented by ${j} is logged
			# as missing.  Also skip logging of COVERART tag
			elif [[ "${j}" != "COVERART" ]] ; then
				if [[ "${file_printed}" != "true" ]] ; then
					# First instance of missing tag for current file
					missing_tags_array+=( "                ERROR  :  ${j} tag not found" )
					file_printed="true"
				else
					# If more than one missing tag in current file,
					# don't print out filename, just the missing tag
					missing_tags_array+=( "                       :  ${j} tag not found" )
				fi
			fi
		done

		# If missing_tags_array is not empty, there are missing
		# tags in the current file so log output
		if [[ -n "${missing_tags_array[@]}" ]] ; then
			# Create a temporary array housing the missing tags
			tmp_tag_array=(
				""
				"            FLAC FILE  :  ${i##*/}"
				"   FLAC FILE LOCATION  :  ${i%/*}"
				"                       :"
				"${missing_tags_array[@]}"
				""
				"--------------------------------------------------------------------------------"
			)

			# Log the missing tags
			printf "%s\n" "${tmp_tag_array[@]}" >> "${metadata_errors}"

			# Add one to fail fd
			printf '.' >&5
		fi
	fi

	# Print newline into FIFO after completion
	__newline >&3
}

# Re-tag FLAC files
__operation_set_tags () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in previous trap
	trap __kill_jobs EXIT

	# Print current FLAC being processed
	__print_applying_tags

	# Start spinner only if this is the first FLAC file being processed
	__start_spinner

	# Remove and set new tags
	#
	# Iterate through the tag array and set a variable for each tag
	for j in "${tags[@]}" ; do
		# Check if ALBUMARTIST is in tag array and apply operations on
		# the tag field if it exists
		if [[ "${j}" == "ALBUMARTIST" ]] ; then
			# ALBUMARTIST exists in tag array so allow script to check the
			# various naming conventions within the FLAC files (ie,
			# 'ALBUM ARTIST' or 'ALBUM_ARTIST')

			# "ALBUMARTIST"
			if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${i}")" ]] ; then
				show_tag_list+=( "--show-tag=ALBUMARTIST" )

			elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${i}")" ]] ; then
				show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

			elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${i}")" ]] ; then
				show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
			fi
		else
			# Build up metaflac '--show-tag=' list
			show_tag_list+=( "--show-tag=${j}" )
		fi
	done

	# Load up all the tag values for current file
	mapfile -n0 -t metaflac_tag_array < \
	<(
		metaflac \
			"${show_tag_list[@]}" \
			"${i}"
	)

	# Create a copy of ${metaflac_tag_array[@]} with just the tag fields
	# and force the tag fields to be uppercase
	tag_field_array=( "${metaflac_tag_array[@]%%=*}" )
	tag_field_array=( "${tag_field_array[@]^^}" )

	# Create a copy of ${metaflac_tag_array[@]} with just the tag values
	tag_values_array=( "${metaflac_tag_array[@]#*=}" )

	# Re-create ${metaflac_tag_array[@]}, this time enforcing the tag
	# fields are uppercase
	#
	# Clear ${metaflac_tag_array[@]}
	metaflac_tag_array=()

	# If the user specified 'true' to the 'prepend_zero' option in the
	# configuration file, enforce the TRACKNUMBER and TRACKTOTAL tags to have a
	# '0' prepended before singular numbers
	if [[ "${prepend_zero}" == "true" ]] ; then

		# Prepend a '0' for TRACKNUMBER and TRACKTOTAL
		for j in "${!tag_field_array[@]}" ; do

			# Add in the tag field and value as an index
			if [[ "${tag_field_array[${j}]}" == "TRACKNUMBER" ||
				  "${tag_field_array[${j}]}" == "TRACKTOTAL" ]] ; then

				# Format tag value with '0' prepended for single values.  We
				# force arithmetic expansion and explicitly specify base 10
				# in order to prevent octal errors if the value is either '08'
				# or '09'
				prepend_tag_value="$( printf %02d $(( 10#${tag_values_array[${j}]} )) )"

				metaflac_tag_array+=(
					# Tag field (eg. TRACKNUMBER) = Tag value (eg. 03)
					"${tag_field_array[${j}]}=${prepend_tag_value}"
				)
			else
				metaflac_tag_array+=(
					# Tag field (eg. ARTIST) = Tag value (eg. Kamelot)
					"${tag_field_array[${j}]}=${tag_values_array[${j}]}"
				)
			fi
		done
	else
		# ${prepend_zero} is not set as 'true', add each tag field and tag value
		# into ${metaflac_tag_array[@]}
		for j in "${!tag_field_array[@]}" ; do

			# Add in the tag field and value as an index
			metaflac_tag_array+=(
				# Tag field (eg. ARTIST) = Tag value (eg. Kamelot)
				"${tag_field_array[${j}]}=${tag_values_array[${j}]}"
			)
		done
	fi

	# Add the saved tags back, by printing each tag field and value
	# on a separate line to STDOUT.  This will be read in by metaflac.
	# Use process substitution to allow this to finish if user
	# invokes SIGINT
	metaflac --remove-all-tags --import-tags-from=- "${i}" < \
	<(
		# This prints each tag key and value pair
		# (eg. ARTIST=Kamelot)
		printf "%s\n" "${metaflac_tag_array[@]}"
	)

	# Print newline into FIFO after completion
	__newline >&3
}

# Prune FLACS
__operation_prune () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in previous trap
	trap __kill_jobs EXIT

	# Print current FLAC being processed
	__print_current_flac

	# Check if file is a FLAC file (hide output)
	metaflac --show-md5sum "${i}" >/dev/null 2>&1

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then
		# Error with FLAC file, display failed/error
		__print_progress_failed

		# Log FLAC failure
		printf "\n%s\n%s\n%s\n%s\n\n%s\n" \
			   "            FLAC FILE  :  ${i##*/}" \
			   "   FLAC FILE LOCATION  :  ${i%/*}" \
			   "                       :" \
			   "                ERROR  :  Not a real FLAC file (or empty file)." \
			   "--------------------------------------------------------------------------------" \
			   >> "${prune_errors}"

		# Add one to fail fd
		printf '.' >&5
	else
		# Remove all information but STREAMINFO,VORBIS_COMMENTs, and
		# possibly METADATA_BLOCK_PICTURE
		metaflac --remove --dont-use-padding --except-block-type="${dont_prune_flac_metadata}" "${i}"

		# FLAC is ok, display ok
		__print_progress_ok
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (7), to be used by the next job
	__store_position

	# Print newline into FIFO after completion
	__newline >&3
}
#== .: END OPERATIONS :. =======================================================


#-------------------------------------------------------------------------------
# .: PRE-SCRIPT CHECKS :.
#-------------------------------------------------------------------------------
# Enable BASH 4 globstar
shopt -s globstar

# Version
version="0.21"

# This sets the script revision (used to compare against user revision)
script_revision="1"

# Various file extensions
flac_extension=".[Ff][Ll][Aa][Cc]"
wav_extension=".[Ww][Aa][Vv]"

# Colors on by default
blue="\033[34m"
green="\033[32m"
red="\033[31m"
cyan="\033[36m"
magenta="\033[35m"
yellow="\033[33m"
invert="\033[7m"
normal="\033[0m"

# Set arguments to null
# If enabled they will be changed to true
compress_flac=""
test_flac=""
aucdtect_flac=""
md5check_flac=""
replaygain_flac=""
retag_flac=""
prune_flac=""

# Check if user is running under Cygwin
# and if so, warn user and exit
os_name="$(uname -o)"
if [[ "${os_name}" == "Cygwin" ]] ; then
	__error "This version of redoflacs is meant to be run under\n" >&2
	__error "${cyan}UNIX/Linux/BSD${normal}.  Please use the ${cyan}Windows (Cygwin)${normal}\n" >&2
	__error "version located here:\n" >&2
	__error "${cyan}https://github.com/sirjaren/redoflacsw/tags${normal}\n" >&2

	exit 1
fi

# Check if configuration file exists based of ${EUID}.  If it doesn't
# exist, create one
if (( EUID == 0 )) ; then
	# User is root
	#
	# Configuration file location
	config_location="/etc/redoflacs.conf"

	# Check if system-wide configuration doesn't exist
	if [[ ! -f "${config_location}" ]] ; then
		# Create system-wide configuration file
		__create_config

		# Inform user of created configuration file, reminding them to check
		# it over before running program
		__info "A configuration file has been created here:\n"
		__info "${cyan}${config_location}${normal}\n\n"

		__info "Please review it before running this program.\n"

		exit 0
	else
		# Configuration file exists, parse it
		__parse_config
	fi
else
	# User is _NOT_ root
	#
	# Configuration file location
	config_location="${HOME}/.config/redoflacs/config"

	# Check if user configuration doesn't exist
	if [[ ! -f "${config_location}" ]] ; then
		# Create '.config/redoflacs' directory (if it doesn't exist)
		mkdir -p "${config_location%/*}"

		# Create user configuration file
		__create_config

		# Inform user of created configuration file, reminding them to check
		# it over before running program
		__info "A configuration file has been created here:\n"
		__info "${cyan}${config_location}${normal}\n\n"

		__info "Please review it before running this program.\n"

		exit 0
	else
		# Configuration file exists, parse it
		__parse_config
	fi
fi

# Log files with location
verify_errors="${error_log}/redoflacs_verify_errors_$$.log"
test_errors="${error_log}/redoflacs_test_errors_$$.log"
md5_errors="${error_log}/redoflacs_md5_errors_$$.log"
metadata_errors="${error_log}/redoflacs_metadata_errors_$$.log"
replay_test_errors="${error_log}/redoflacs_replaygain_test_errors_$$.log"
replay_add_errors="${error_log}/redoflacs_replaygain_add_errors_$$.log"
aucdtect_errors="${error_log}/redoflacs_aucdtect_errors_$$.log"
prune_errors="${error_log}/redoflacs_prune_errors_$$.log"

# Process positional parameters, allowing script to see
# which operations to run.  Make sure we send all the positional
# parameters called to the function, otherwise the function will
# think there aren't any positional parameters to process as it
# handles it's own positional parameters
__process_positional_parameters "${@}"

# Check if user set '-n, --no-color'.  This must come before everything (and
# after the positional parameters) to ensure color is set/unset.  The normal
# variable is always set, to reset the inverted colors (color or no-color)
# during progress bar output
if [[ "${no_color}" == "true" ]] ; then
	blue=""
	green=""
	red=""
	cyan=""
	magenta=""
	yellow=""
fi

# Make sure we are running BASH 4 or greater
if (( ${BASH_VERSION%%.*} < 4 )) ; then
	__error "You must be running ${cyan}BASH 4${normal} or greater to use\n" >&2
	__error "this program!\n" >&2
	exit 1
fi

# Check for any conflicting operations/arguments called
# at script invocation and warn user
__check_conflicting_operations

# Check for any missing programs vital for this script
# to operate correctly, and exit if any programs are found
# to be missing
__check_missing_programs

# Check whether directory exists
if [[ ! -d "${directory}" ]] ; then
	printf "  Usage: redoflacs [OPTION] [PATH_TO_FLAC(s)]...\n\n" >&2
	__error "Please specify a directory!\n" >&2

	exit 1
fi

# Check for at least 1 FLAC file
read -r find_flacs < <( printf "%s\n" "${directory}"/**/*${flac_extension} )

# No FLAC files found
if [[ ! -f "${find_flacs}" ]] ; then
	__no_flacs
	exit 1
fi

# If "-A, --aucdtect-spectrogram" was called, make sure
# spectrogram_location is a valid location, if user defined
if [[ "${create_spectrogram}" == "true" ]] ; then

	# Check if spectrogram_location is user-defined
	if [[ -n "${spectrogram_location}" ]] ; then

		# Put spectrograms in user-defined location
		# Test to make sure directory exists
		if [[ ! -d "${spectrogram_location}" ]] ; then
			__error "${cyan}${spectrogram_location}${normal} doesn't exist!\n" >&2
			__error "Please set a valid directory in the configuration file!\n" >&2

			exit 1
		fi
	fi
fi

# If ${jobs} wasn't set upon invocation, check in /proc
# to see how many jobs should be run
if [[ -z "${jobs}" ]] ; then
	__find_cores
else
	jobs_display="(User Defined)"
fi
#== .: END PRE-SCRIPT CHECKS :. ================================================


#-------------------------------------------------------------------------------
# .: START SCRIPT :.
#-------------------------------------------------------------------------------
# Store current stty settings
old_stty="$(stty -g)"

# Prevent Control-C from displaying '^C'.  May already be set
stty -ctlecho 2> /dev/null

# Hide the cursor
printf "\033[?25l"

# Check to see if config file in script is newer than user config, warning
# user if their config is older displaying a countdown before continuing
__check_config_version

# Temporary FIFO location
tmp_fifo="/tmp/redoflacs_fifo_$$"

# Temporary spinner FIFO
spinner_fifo="/tmp/redoflacs_spinner_fifo_$$"

# Set up error file descriptor '5'
__set_error_fd

# Set up position file descriptor '7'
__set_position_fd

# Display the top banner
if [[ "${retag_flac}" != "true" ]] ; then
	# Display top banner
	__top_banner
else
	# Force all the tag fields to be uppercase
	tags=( "${tags[@]^^}" )

	# Check for coverart conflicts.  Needed here
	# to allow script to exit right away if there
	# is a conflict
	__coverart_remove_conflict

	# Display a countdown before continuing
	__countdown_metadata

	# Display top banner
	__top_banner
fi

# Grab the total flacs to process
total_flacs_array=( "${directory}"/**/*${flac_extension} )

# String length of total number of flacs
total_flacs_length="${#total_flacs_array[@]}"
total_flacs_length="${#total_flacs_length}"

# This displays '[ ok ]' after 'Finding FLAC files to process...'
__processed_flacs_ok

#-------------------------------------------------------------------------------
# .: AUCDTECT :.
#-------------------------------------------------------------------------------
# The below order is probably the best bet in ensuring time
# isn't wasted on doing unnecessary operations if the
# FLAC files are corrupt or have metadata issues
if [[ "${aucdtect_flac}" == "true" ]] ; then

	# Prints title message of current operation
	__title_aucdtect_flac

	# Obtain the current row
	__obtain_row

	# If the total number of directories to process is less than jobs specified,
	# then set the number of lines to remove from the terminal scroll as the
	# difference of the number of jobs minus the total number of directories
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# This variable will be used for '__scroll_terminal' as ${1}
		remove_from_scroll="- $(( jobs - ${#total_flacs_array[@]} ))"
	fi

	# Scroll terminal, if applicable
	__scroll_terminal "${remove_from_scroll}"

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Open up a temporary file descriptor to send auCDtect's
	# STDOUT to
	__create_aucdtect_fd

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files __operation_aucdtect

	if (( ${#total_flacs_array[@]} < jobs )) ; then
		current_row=$(( current_row + ${#total_flacs_array[@]} ))
	else
		current_row=$(( current_row + jobs ))
	fi

	# Place cursor on the last line, to allow the current row to be read in
	# correctly
	printf "\033[${current_row}H"

	if [[ -f "${aucdtect_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_aucdtect

		# Prepend log header to log file
		__header_aucdtect

		# Store operation status for Summary Of Operations
		aucdtect_complete="false"

		# Display Summary Of Operations
		__operation_summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	aucdtect_complete="true"
fi
#== .: END AUCDTECT :. =========================================================


#-------------------------------------------------------------------------------
# .: MD5 CHECK :.
#-------------------------------------------------------------------------------
if [[ "${md5check_flac}" == "true" ]] ; then

	# Prints title message of current operation
	__title_md5check_flac

	# Obtain the current row
	__obtain_row

	# If the total number of directories to process is less than jobs specified,
	# then set the number of lines to remove from the terminal scroll as the
	# difference of the number of jobs minus the total number of directories
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# This variable will be used for '__scroll_terminal' as ${1}
		remove_from_scroll="- $(( jobs - ${#total_flacs_array[@]} ))"
	fi

	# Scroll terminal, if applicable
	__scroll_terminal "${remove_from_scroll}"

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files __operation_md5_check

	if (( ${#total_flacs_array[@]} < jobs )) ; then
		current_row=$(( current_row + ${#total_flacs_array[@]} ))
	else
		current_row=$(( current_row + jobs ))
	fi

	# Place cursor on the last line, to allow the current row to be read in
	# correctly
	printf "\033[${current_row}H"

	if [[ -f "${md5_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_md5_check

		# Prepend log header to log file
		__header_md5_check

		# Store operation status for Summary Of Operations
		md5check_complete="false"

		# Display Summary Of Operations
		__operation_summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	md5check_complete="true"
fi
#== .: END MD5 CHECK :. ========================================================


#-------------------------------------------------------------------------------
# .: COMPRESS/VERIFY :.
#-------------------------------------------------------------------------------
if [[ "${compress_flac}" == "true" ]] ; then

	# Set the correct title operation to print depending on what was called
	if [[ "${skip_test}" == "true" ]] ; then
		__title_compress_notest_flac
	else
		__title_compress_flac
	fi

	# Obtain the current row
	__obtain_row

	# If the total number of directories to process is less than jobs specified,
	# then set the number of lines to remove from the terminal scroll as the
	# difference of the number of jobs minus the total number of directories
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# This variable will be used for '__scroll_terminal' as ${1}
		remove_from_scroll="- $(( jobs - ${#total_flacs_array[@]} ))"
	fi

	# Scroll terminal, if applicable
	__scroll_terminal "${remove_from_scroll}"

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files __operation_compress

	if (( ${#total_flacs_array[@]} < jobs )) ; then
		current_row=$(( current_row + ${#total_flacs_array[@]} ))
	else
		current_row=$(( current_row + jobs ))
	fi

	# Place cursor on the last line, to allow the current row to be read in
	# correctly
	printf "\033[${current_row}H"

	if [[ -f "${verify_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_compress_verify

		# Prepend log header to log file
		__header_compress_verify

		# Store operation status for Summary Of Operations
		compress_complete="false"

		# Display Summary Of Operations
		__operation_summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	compress_complete="true"
fi
#== .: END COMPRESS/VERIFY :. ==================================================


#-------------------------------------------------------------------------------
# .: TEST :.
#-------------------------------------------------------------------------------
if [[ "${test_flac}" == "true" ]] ; then

	# Prints title message of current operation
	__title_testing_flac

	# Obtain the current row
	__obtain_row

	# If the total number of directories to process is less than jobs specified,
	# then set the number of lines to remove from the terminal scroll as the
	# difference of the number of jobs minus the total number of directories
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# This variable will be used for '__scroll_terminal' as ${1}
		remove_from_scroll="- $(( jobs - ${#total_flacs_array[@]} ))"
	fi

	# Scroll terminal, if applicable
	__scroll_terminal "${remove_from_scroll}"

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files __operation_test

	if (( ${#total_flacs_array[@]} < jobs )) ; then
		current_row=$(( current_row + ${#total_flacs_array[@]} ))
	else
		current_row=$(( current_row + jobs ))
	fi

	# Place cursor on the last line, to allow the current row to be read in
	# correctly
	printf "\033[${current_row}H"

	if [[ -f "${test_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_test

		# Prepend log header to log file
		__header_test

		# Store operation status for Summary Of Operations
		test_complete="false"

		# Display Summary Of Operations
		__operation_summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	test_complete="true"
fi
#== .: END TEST :. =============================================================


#-------------------------------------------------------------------------------
# .: REPLAYGAIN :.
#-------------------------------------------------------------------------------
if [[ "${replaygain_flac}" == "true" ]] ; then

	# Check if "-G, --replaygain-noforce" was called
	if [[ "${replaygain_noforce}" == "true" ]] ; then
		process_replaygain="__operation_replaygain_noforce"
	else
		process_replaygain="__operation_replaygain_force"
	fi

	# Prints title message of current operation
	__title_replaygain

	# Obtain the current row
	__obtain_row

	# Obtain `metaflac' version information to test on.  Example:
	#   metaflac 1.3.0pre1
	#   -----------^
	# Test only the second integer in the version string above
	__metaflac_version

	#---------------------------------------------------------------------------
	# .: TEST REPLAYGAIN :.
	#---------------------------------------------------------------------------
	# Prints sub message of current operation
	__sub_test_replaygain

	# Obtain the current row
	__obtain_row

	# If the total number of directories to process is less than jobs specified,
	# then set the number of lines to remove from the terminal scroll as the
	# difference of the number of jobs minus the total number of directories
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# This variable will be used for '__scroll_terminal' as ${1}
		remove_from_scroll="- $(( jobs - ${#total_flacs_array[@]} ))"
	fi

	# Scroll terminal, if applicable
	__scroll_terminal "${remove_from_scroll}"

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files __operation_test_replaygain

	if (( ${#total_flacs_array[@]} < jobs )) ; then
		current_row=$(( current_row + ${#total_flacs_array[@]} ))
	else
		current_row=$(( current_row + jobs ))
	fi

	# Place cursor on the last line, to allow the current row to be read in
	# correctly
	printf "\033[${current_row}H"

	if [[ -f "${replay_test_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_replaygain_test

		# Prepend log header to log file
		__header_replaygain_test

		# Store operation status for Summary Of Operations
		testing_replaygain_complete="false"

		# Display Summary Of Operations
		__operation_summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	testing_replaygain_complete="true"
	#== .: END TEST REPLAYGAIN :. ==============================================


	#---------------------------------------------------------------------------
	# .: PROCESS REPLAYGAIN :.
	#---------------------------------------------------------------------------
	# Make printing pretty if specified directory is '.'
	if [[ "${directory}" == "." ]] ; then
		directory="${PWD}"
	fi

	# Grab number of directories to process provided as
	# ${total_directories}
	__total_directories

	# Prints sub message of current operation
	__sub_add_replaygain

	# Obtain the current row
	__obtain_row

	# If the total number of directories to process is less than jobs specified,
	# then set the number of lines to remove from the terminal scroll as the
	# difference of the number of jobs minus the total number of directories
	if (( ${#flac_directories_array[@]} < jobs )) ; then
		# This variable will be used for '__scroll_terminal' as ${1}
		remove_from_scroll="- $(( jobs - ${#flac_directories_array[@]} ))"
	fi

	# Scroll terminal, if applicable
	__scroll_terminal "${remove_from_scroll}"

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_directories "${process_replaygain}"

	if (( ${#flac_directories_array[@]} < jobs )) ; then
		current_row=$(( current_row + ${#flac_directories_array[@]} ))
	else
		current_row=$(( current_row + jobs ))
	fi

	# Place cursor on the last line, to allow the current row to be read in
	# correctly
	printf "\033[${current_row}H"

	if [[ -f "${replay_add_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_replaygain_process

		# Prepend log header to log file
		__header_replaygain_test

		# Store operation status for Summary Of Operations
		adding_replaygain_complete="false"

		# Display Summary Of Operations
		__operation_summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	adding_replaygain_complete="true"
	#== .: END PROCESS REPLAYGAIN :. ===========================================
fi
#== .: END REPLAYGAIN :. =======================================================


#-------------------------------------------------------------------------------
# .: RETAG :.
#-------------------------------------------------------------------------------
if [[ "${retag_flac}" == "true" ]] ; then

	# If COVERART tag doesn't appear in any of the FLAC files'
	# tags, and if the user wants artwork to be kept, don't log
	# missing COVERART tags (in the event that the script adds
	# it into the tag array)
	if [[ "${coverart_warning}" != "true" && "${remove_artwork}" != "true" ]] ; then

		# Analyze tags but don't log COVERART as a missing
		# tag (if applicable)
		analyze_tags="__operation_analyze_tags_dont_log_coverart"
	else

		# Log all the missing tags found in the ${tags} array including COVERART
		# tag, regardless of whether it was added by the script or explicitly
		# chosen by the user
		analyze_tags="__operation_analyze_tags"
	fi

	# Prints title message of current operation
	__title_retag

	# Copy the tag array because we will need to use it
	# later as we are _may_ add a temporary element to the
	# tag array
	old_tags=( "${tags[@]}" )

	#---------------------------------------------------------------------------
	# .: ANALYZE TAGS :.
	#---------------------------------------------------------------------------
	# Analyze FLAC tags to ensure none are missing and/or empty

	# Set up spinner file descriptor '6'
	__set_spinner_fd

	# Prints sub message of current operation
	__sub_analyze_tags

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files "${analyze_tags}"

	# Place cursor on the last line, to allow the current row to be read in
	# correctly
	printf "\033[${current_row}H"

	# Test for DEPRECATED tag, COVERART in METADATA_ERROR log.  If it
	# exists, set coverart_warning variable to make script output
	# warning upon completion
	if [[ -f "${metadata_errors}" ]] ; then
		while read -r i ; do
			# Indentation is culled from reading in "${i}"
			# To change this, set IFS to '\n'
			if [[ "${i}" == *METADATA_BLOCK_PICTURE* ]] ; then
				coverart_warning="true"
				break
			fi
		done < "${metadata_errors}"
	fi

	if [[ -f "${metadata_errors}"  && "${coverart_warning}" == "true" ]] ; then
		# Display COVERART warning function and metadata issues
		__newline >&2 ; __coverart_warning

		# Print out log exists to STDERR
		__log_missing_tags

		# Prepend log header to log file
		__header_retag

		# Store operation status for Summary Of Operations
		analyzing_retag_complete="false"

		# Display Summary Of Operations
		__operation_summary

		exit 1
	elif [[ -f "${metadata_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_missing_tags

		# Prepend log header to log file
		__header_retag

		# Store operation status for Summary Of Operations
		analyzing_retag_complete="false"

		# Display Summary Of Operations
		__operation_summary

		exit 1
	fi

	if [[ "${last_file}" == "true" ]] ; then
		# FLAC is okay, so print only if it's the last file
		__print_ok_tag

		# Store operation status for Summary Of Operations
		analyzing_retag_complete="true"
	fi

	# Kill spinner
	__kill_spinner
	#== .: END ANALYZE TAGS :. =================================================


	#---------------------------------------------------------------------------
	# .: SET TAGS :.
	#---------------------------------------------------------------------------
	# Clear the old tags and re-tag with the kept tags

	# Restore the original tags array as the script _may_ have
	# added the COVERART tag.  This way, we ensure that the
	# COVERART tag was, in fact, temporary.
	tags=( "${old_tags[@]}" )

	# Set up spinner file descriptor '6'
	__set_spinner_fd

	# Prints sub message of current operation
	__sub_applying_tags

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files __operation_set_tags

	# Place cursor on the last line, to allow the current row to be read in
	# correctly
	printf "\033[${current_row}H"

	if [[ "${last_file}" == "true" ]] ; then
		# FLAC is okay, so print only if it's the last file
		__print_ok_tag ; __newline

		# Store operation status for Summary Of Operations
		applying_retag_complete="true"
	fi

	# Kill spinner
	__kill_spinner
	#== .: END SET TAGS :. =====================================================
fi
#== .: END RETAG :. ============================================================


#-------------------------------------------------------------------------------
# .: PRUNE :.
#-------------------------------------------------------------------------------
if [[ "${prune_flac}" == "true" ]] ; then

	# Don't remove artwork if user wants it kept.  We don't have to check
	# for the legacy COVERART tag as we are NOT removing any VORBIS_COMMENTs.
	if [[ "${remove_artwork}" == "true" ]] ; then
		# Remove artwork
		dont_prune_flac_metadata="STREAMINFO,VORBIS_COMMENT"
	else
		# Don't remove artwork
		dont_prune_flac_metadata="STREAMINFO,PICTURE,VORBIS_COMMENT"
	fi

	# Prints title message of current operation
	__title_prune_flac

	# Obtain the current row
	__obtain_row

	# If the total number of directories to process is less than jobs specified,
	# then set the number of lines to remove from the terminal scroll as the
	# difference of the number of jobs minus the total number of directories
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# This variable will be used for '__scroll_terminal' as ${1}
		remove_from_scroll="- $(( jobs - ${#total_flacs_array[@]} ))"
	fi

	# Scroll terminal, if applicable
	__scroll_terminal "${remove_from_scroll}"

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files __operation_prune

	if (( ${#total_flacs_array[@]} < jobs )) ; then
		current_row=$(( current_row + ${#total_flacs_array[@]} ))
	else
		current_row=$(( current_row + jobs ))
	fi

	# Place cursor on the last line, to allow the current row to be read in
	# correctly
	printf "\033[${current_row}H"

	if [[ -f "${prune_errors}" ]] ; then
		# Print out log exists to STDERR
		__log_prune

		# Prepend log header to log file
		__header_prune

		# Store operation status for Summary Of Operations
		prune_complete="false"

		# Display Summary Of Operations
		__operation_summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	prune_complete="true"
fi
#== .: END PRUNE :. ============================================================


# Display warning about legacy COVERART tag, if applicable
if [[ "${coverart_warning}" == "true" ]] ; then
	__coverart_warning
fi

# Display Summary Of Operations
__operation_summary
#== .: END SCRIPT :. ===========================================================
