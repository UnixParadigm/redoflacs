#!/usr/bin/env bash
#-------------------------------------------------------------------------------
# redoflacs - Parallel BASH commandline FLAC compressor, verifier, organizer,
#             analyzer, and retagger
#-------------------------------------------------------------------------------
# ~ THIS IS THE UNIX/LINUX/BSD VERSION OF REDOFLACS ~
#-------------------------------------------------------------------------------
# Copyright (C) 2010-2013  Jaren Stangret
#-------------------------------------------------------------------------------
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#-------------------------------------------------------------------------------
# You can follow development of this script on Github at:
# https://github.com/sirjaren/redoflacs
#
# Please submit requests/changes/patches and/or comments
#-------------------------------------------------------------------------------
# File Descriptors used in this script:
#    0: STDIN
#    1: STDOUT
#    2: STDERR
#    3: FIFO process manager
#    4: auCDtect's (STDOUT) output
#    5: Number of FLAC files that failed and/or had issues
#-------------------------------------------------------------------------------
# .: SCRIPT MESSAGES :.
#-------------------------------------------------------------------------------
# Bold green message
__info () {
	printf " ${green}*${normal} ${@}"
}

# Yellow message
__warn () {
	printf " ${yellow}*${normal} ${@}"
}

# Bold red message
__error () {
	printf " ${red}*${normal} ${@}"
}

# No FLACS found error message
__no_flacs () {
	__error "There are not any FLAC files to process!\n"
} >&2

# Display why COVERART tag should not be used
__coverart_warning () {
	printf "\n"
	__warn "The ${cyan}COVERART${normal} tag is deprecated and should not be\n"
	__warn "used. Instead, consider migrating over to the new format:\n"
	__warn "${cyan}METADATA_BLOCK_PICTURE${normal}, using modern tag editors. Read:\n"
	__warn "${cyan}http://wiki.xiph.org/VorbisComment#Unofficial_COVERART_field_.28deprecated.29${normal}\n"
	__warn "for more details.\n"
} >&2

# Display message that system is missing vital programs
__display_missing_commands_header () {
	__error "You seem to be missing one or more necessary programs\n"
	__error "to run this script reliably.  Below shows the program(s)\n"
	__error "missing, as well as where you can install them from:\n"
} >&2

# Display a lot of help
__long_help () {
long_help=".TH \"REDOFLACS\" 1
.SH NAME
redoflacs \\- Parallel BASH commandline FLAC compressor, verifier, organizer, analyzer, and retagger
.SH SYNOPSIS
.B redoflacs
.RI [operations]
.RI [options]
.RI [target]
.RI ...
.SH DESCRIPTION
redoflacs is a BASH commandline program providing a series of operations to help
manage and verify a user's FLAC music library.  One of the key features of
redoflacs is it's ability to process a great number of FLAC files in parallel,
using as many jobs to complete an operation as possible, very similar to 'GNU
make'.

redoflacs searches for a config file (if run as a user) in:

.br
        \\fB~/.config/redoflacs/config\\fP

.br
or (if run as root) in:

.br
        \\fB/etc/redoflacs.conf\\fP

If a config file is not found (in either place), one is created.

More information can be found at <\\fBhttps://github.com/sirjaren/redoflacs\\fP>.
.SH OPERATIONS
.TP
.BI -c, --compress
Compress the FLAC files with the user-specified level of compression defined
from the configuration file as 'compression_level' and verify the resultant
files.

The default is 8, with the range of values starting from 1 to 8 with the
smallest compression at 1, and the highest at 8.  This option will add a tag
(VORBIS_COMMENT) to all successfully verified FLAC files.  Below shows the
default COMPRESSION tag added to each successfully compressed (and verified)
FLAC file:

        COMPRESSION=8

If any FLAC files already have the defined compression_level tag (a good
indicator the files are already compressed at that level), the script will
instead test the FLAC files for any errors.  This is useful to check your entire
music library to make sure all the FLAC files are compressed at the level
specified as well as make sure they are intact (ie, not corrupt).

If any files are found to be corrupt, this script will quit upon finishing the
compression of any other files and produce an error log.
.TP
.BI -C, --compress-notest
Same as the '-c, --compress' option, but if any FLAC files already have the
defined compression_level tag, the script will skip the file and continue on to
the next without testing the FLAC file's integrity.  This is useful for checking
if all your FLAC files are compressed at the level specified.
.TP
.BI -t, --test
Same as '-c, --compress' but instead of compressing the FLAC files, this script
just verfies the integrity of them.  This option will NOT add the COMPRESSION
tag to the files.

As with the '-c, --compress' option, this will produce an error log if any FLAC
files are found to be corrupt.
.TP
.BI -a, --aucdtect
Use the auCDtect program by Oleg Berngardt and Alexander Djourik to analyze
FLAC files and check with fairly accurate precision whether the FLAC files are
lossy sourced or not.  For example, an MP3 file converted to FLAC is no longer
lossless therefore lossy sourced.

While this program isn't foolproof, it gives a good idea which FLAC files will
need further investigation (ie, a spectrogram).  This program does not work on
FLAC files which have a bit depth of more than a typical audio CD (16bit), and
will skip the files that have a higher bit depth.

If any files are found to not be perfect (ie, 100% CDDA via auCDtect), a log
will be created with the questionable FLAC files recorded in it.
.TP
.BI -A, --aucdtect-spectrogram
Same as '-a, --aucdtect' with the addition of creating a spectrogram for each
FLAC file that fails auCDtect, that is, any FLAC file that does not return 100%
CDDA from auCDtect will be scanned and a spectrogram will be created.

Any FLAC file skipped (due to having a higher bit depth than 16), will NOT have
a spectrogram created.

By default, each spectrogram will be created in the same folder as the tested
FLAC file name as follows:

        [<# of current file processed>] <filename>.png

An example of this:

        [ FLAC file (7th file processed) ]
              03 - Some FLAC File.flac

        [ Spectrogram Image ]
              [7] 03 - Some FLAC File.png

The user can change the location of where to store the created spectrogram
images by changing the value of 'spectrogram_location' defined in the
configuration file.  The location defined by the user will be tested to see if
it exists before starting the script.  If the location does NOT exist, the
script will warn the user and exit.

The created PNG file is large in resolution to best capture the FLAC file's
waveform (roughly 1800x513).

The spectrogram is created using the program SoX.  If the user tries to use this
option without having SoX installed, the script will warn the user that SoX is
missing and exit.
.TP
.BI -m, --md5check
Check the FLAC files for unset MD5 Signatures and log the output of any unset
signatures.  An unset MD5 signature doesn't necessarily mean a FLAC file is
corrupt, and MAY be repaired with a re-encoding of said FLAC file.
.TP
.BI -e, --extract-artwork
Run through each FLAC file and extract any and all artwork that's embedded
within the PICTURE block.  This is useful in the event a user wants to save any
artwork before using the '-p, --prune' option to remove the artwork.

By default, each extracted image will be placed in a subdirectory where the FLAC
file is located.  The subdirectory will have the same name as the current FLAC
being processed with a fairly unique string appended to it.  For example:

        [ Current FLAC file ]
              /path/to/music/01_file.flac

        [ Example subdirectory ]
              /path/to/music/01_file.flac_[redoflacs_art]_4342/

The user can change the location of where to store the extracted images by
changing the value of 'artwork_location' defined in the configuration file.  The
location defined by the user will be tested to see if it exists before starting
the script.  If the location does not exist, the script will warn the user and
exit.

This operation supports all the various types of embedded artwork that
\`metaflac' supports:

         0: Other
.br
         1: 32x32 pixels 'file icon' (PNG only)
.br
         2: Other file icon
.br
         3: Cover (front)
.br
         4: Cover (back)
.br
         5: Leaflet page
.br
         6: Media (e.g. label side of CD)
.br
         7: Lead artist/lead performer/soloist
.br
         8: Artist/performer
.br
         9: Conductor
.br
        10: Band/Orchestra
.br
        11: Composer
.br
        12: Lyricist/text writer
.br
        13: Recording Location
.br
        14: During recording
.br
        15: During performance
.br
        16: Movie/video screen capture
.br
        17: A bright coloured fish
.br
        18: Illustration
.br
        19: Band/artist logotype
.br
        20: Publisher/Studio logotype

If there is more than one image of the same type, this operation will append a
number after the image filename to prevent clobbering:

        [ Example subdirectory ]
              /path/to/music/01_file.flac_[redoflacs_art]_4342/

        [ More than image in subdirectory ]
              Cover (front) (1).jpg
              Cover (front) (2).jpg
              Cover (front) (3).jpg
              Cover (front) (4).jpg
              Cover (front) (5).jpg
.TP
.BI -p, --prune
Delete every METADATA block in each FLAC file except the STREAMINFO and
VORBIS_COMMENT block.  If 'remove_artwork' is not set as 'true', defined in the
configuration file, then the PICTURE block will NOT be removed.
.TP
.BI -g, --replaygain
Add ReplayGain values to FLAC files.  ReplayGain is calculated for ALBUM and
TRACK values and applied via VORBIS_COMMENTS and as such, will require the
'-r, --retag' option to have these tags kept (see '-r, --retag' option) in order
to preserve the added ReplayGain values.  The tags added are:

        REPLAYGAIN_REFERENCE_LOUDNESS
.br
        REPLAYGAIN_TRACK_GAIN
.br
        REPLAYGAIN_TRACK_PEAK
.br
        REPLAYGAIN_ALBUM_GAIN
.br
        REPLAYGAIN_ALBUM_PEAK

This option ignores any ReplayGain tags that may already be set, removing
existing values before applying new ones.

In order for ReplayGain values to be applied correctly, the script has to
determine which FLAC files to add values to by looking at the directory housing
said files.  That is, the script must add ReplayGain values by working off the
FLAC files' parent directory.  If there are some FLAC files found, the script
will move up one directory and begin applying ReplayGain values.  This is
necessary in order to get the REPLAYGAIN_ALBUM_GAIN and REPLAYGAIN_ALBUM_PEAK
values set correctly.  Without doing this, the ALBUM and TRACK values would be
identical.

If a user has many FLAC files under one directory (of different albums/artists),
the ReplayGain ALBUM values are going to be incorrect as the script will
perceive all those FLAC files to essentially be from the same album.  This is
mitigated by having each album in a separate directory.  Keep in mind,
multi-disc albums must be in separate directories in order to be processed with
different ALBUM GAIN and ALBUM PEAK values.

If there are any errors found while generating and/or applying ReplayGain
values, an error log will be produced.
.TP
.BI -G, --replaygain-noforce
Same as '-g, --replaygain' but will check for existing ReplayGain tags before
re-applying new ones.  If any one of the five ReplayGain tags are missing from
any FLAC file (mentioned above), the script will apply new values to each FLAC
file in that directory (first removing the old ReplayGain tags -- if any).

If all five ReplayGain tags are intact in every FLAC file (in a given
directory), that directory will be skipped and no new ReplayGain tags will be
added.
.TP
.BI -r, --retag
Extract the configured tags in each FLAC file and clear the rest before
retagging the file.  The default tags kept are:

        TITLE
.br
        ARTIST
.br
        ALBUM
.br
        DISCNUMBER
.br
        DATE
.br
        TRACKNUMBER
.br
        TRACKTOTAL
.br
        GENRE
.br
        COMPRESSION
.br
        RELEASETYPE
.br
        SOURCE
.br
        MASTERING
.br
        REPLAYGAIN_REFERENCE_LOUDNESS
.br
        REPLAYGAIN_TRACK_GAIN
.br
        REPLAYGAIN_TRACK_PEAK
.br
        REPLAYGAIN_ALBUM_GAIN
.br
        REPLAYGAIN_ALBUM_PEAK

If any FLAC files have missing tags (from those configured to be kept), the file
and the missing tag will be recorded in a log.

The tags that can be kept are essentially infinite, as long as the tags to be
kept are set in the TAGGING SECTION of the configuration file.

If this option is specified, a warning will appear upon script execution.  This
warning will show which of the configured TAG fields to keep when re-tagging the
FLAC files.  A countdown will appear giving the user 10 seconds to abort the
script, after which, the program will begin running it's course.
.TP
.BI -l, --all
This option is short for:

        -c, --compress
.br
        -m, --md5check
.br
        -p, --prune
.br
        -g, --replaygain
.br
        -r, --retag
.TP
.BI -L, --reallyall
This option is short for:

        -c, --compress
.br
        -m, --md5check
.br
        -p, --prune
.br
        -g, --replaygain
.br
        -r, --retag
.br
        -A, --aucdtect-spectrogram
.SH OPTIONS
.TP
.BI -j[N], --jobs[=N]
Set the number of parallel jobs to run on script invocation.  If this is not
set, this script will attempt to find the number of CPU cores available,
using the number found as the number of parallel jobs to run.

If the script is unable to find the number of CPU cores available, the number of
jobs will be set to two (2), by default.
.TP
.BI -n, --no-color
Turn off color output.
.TP
.BI -o, --new-config
Force the creation of a new configuration file.  This option does _NOT_
overwrite any existing configuration file.
.TP
.BI -v, --version
Display script version and exit.
.TP
.BI -h, --help
Shows this help message.
.SH FILES
.TP
.BI ~/.config/redoflacs/config
User configuration file.
.TP
.BI /etc/redoflacs.conf
System configuration file.
.SH BUGS
If you find a bug, please report it at:
<\\fBhttps://github.com/sirjaren/redoflacs/issues/new\\fP>
.SH AUTHOR
Jaren Stangret <sirjaren@gmail.com>
.SH THANKS
Thanks to all the people whom have provided feedback and support!
.br
.SH REVISION
[ 4 ]"

	# Print out help to temporary file which will read by 'man'
	printf "%s\n" "${long_help}" > "${tmp_man_page}"
}

# Display short help
__short_help () {
	printf " Usage: redoflacs [operations] [options] [target] ...\n"
	printf " Operations:\n"
	printf "   -c, --compress\n"
	printf "   -C, --compress-notest\n"
	printf "   -t, --test\n"
	printf "   -m, --md5check\n"
	printf "   -a, --aucdtect\n"
	printf "   -A, --aucdtect-spectrogram\n"
	printf "   -e, --extract-artwork\n"
	printf "   -p, --prune\n"
	printf "   -g, --replaygain\n"
	printf "   -G, --replaygain-noforce\n"
	printf "   -r, --retag\n"
	printf "   -l, --all\n"
	printf "   -L, --reallyall\n"
	printf " Options:\n"
	printf "   -j[N], --jobs[=N]\n"
	printf "   -n, --no-color\n"
	printf "   -o, --new-config\n"
	printf "   -v, --version\n"
	printf "   -h, --help\n"
	printf " This is the short help; for details use 'redoflacs --help' or 'redoflacs -h'\n"
}

# Display usage
__usage () {
	printf " Usage: redoflacs [operations] [options] [target] ...\n"
}
#== .: END SCRIPT MESSAGES :. ==================================================

#-------------------------------------------------------------------------------

__message_log_exists () {
	#---------------------------------------------------------------------------
	# Print out the correct operational message regarding a log file's existence
	# and what infomration that log may contain
	#
	# $1 determines the log file to use, as well as how many lines are printed
	# out to correctly set the current row.  Possible values:
	#   aucdtect          compress   extract_artwork
	#   md5_check         prune      replaygain_add
	#   replaygain_test   retag      test
	#---------------------------------------------------------------------------
	case "$1" in
		aucdtect)
			__error "Some FLAC files may be lossy sourced, please check:\n"
			current_row=$(( current_row + 4 ))
		;;
		compress)
			__error "Errors found in some FLAC files, please check:\n"
			current_row=$(( current_row + 4 ))
		;;
		extract_artwork)
			__error "There were issues with some of the FLAC files,\n"
			__error "please check:\n"
			current_row=$(( current_row + 5 ))
		;;
		md5_check)
			__error "The MD5 Signature is unset for some FLAC files or there were\n"
			__error "issues with some of the FLAC files, please check:\n"
			current_row=$(( current_row + 5 ))
		;;
		prune)
			__error "There were issues with some of the FLAC files,\n"
			__error "please check:\n"
			current_row=$(( current_row + 5 ))
		;;
		replaygain_add)
			__error "There were issues adding ReplayGain values,\n"
			__error "please check:\n"
			current_row=$(( current_row + 5 ))
		;;
		replaygain_test)
			__error "There were issues with some of the FLAC files,\n"
			__error "please check:\n"
			current_row=$(( current_row + 5 ))
		;;
		retag)
			__error "Some FLAC files have missing tags or there were\n"
			__error "issues with some of the FLAC files, please check:\n"
			current_row=$(( current_row + 5 ))
		;;
		test)
			__error "Errors found in some FLAC files, please check:\n"
			current_row=$(( current_row + 4 ))
		;;
	esac

	# Print the bottom half of the message (uniform across all operations)
	__error "${cyan}${log_file}${normal}\n"
	__error "for details.\n"
} >&2

#-------------------------------------------------------------------------------

__create_log () {
	#---------------------------------------------------------------------------
	# Take log file from the current operation, prepending a header to it as
	# as well as formatting/aligning log lines
	#
	# $1 determines the log file to create, and is any one of these values:
	#   aucdtect          compress   extract_artwork
	#   md5_check         prune      replaygain_add
	#   replaygain_test   retag      test
	#---------------------------------------------------------------------------
	# Set up local variables/arrays
	declare -a header_array        header_compress   header_extract_artwork \
               header_md5          header_prune      header_replay_add \
               header_replay_test  header_retag      header_test \
               log_array

	declare    error_msg  filename  length  line

	# Set up header array indices
	header_aucdtect=(
		"--------------------------------------------------------------------------------"
		"                           AUCDTECT ERROR/REPORT LOG"
		"                           -------------------------"
		"      This log details which FLAC files have errors when running auCDtect"
		"--------------------------------------------------------------------------------"
	)

	header_compress=(
		"--------------------------------------------------------------------------------"
		"                          COMPRESS & VERIFY ERROR LOG"
		"                          ---------------------------"
		"    This log details which FLAC files have errors when compressing and/or"
		"  verifying"
		"--------------------------------------------------------------------------------"
	)

	header_extract_artwork=(
		"--------------------------------------------------------------------------------"
		"                           EXTRACT ARTWORK ERROR LOG"
		"                           -------------------------"
		"  This log details which FLAC files have errors when extracting artwork images"
		"--------------------------------------------------------------------------------"
	)

	header_md5=(
		"--------------------------------------------------------------------------------"
		"                              MD5 CHECK ERROR LOG"
		"                              -------------------"
		"    This log details which FLAC files have errors when checking the MD5"
		"  signature"
		"--------------------------------------------------------------------------------"
	)

	header_prune=(
		"--------------------------------------------------------------------------------"
		"                                PRUNE ERROR LOG"
		"                                ---------------"
		"   This log details which FLAC files have errors when pruning METADATA blocks"
		"--------------------------------------------------------------------------------"
	)

	header_replay_add=(
		"--------------------------------------------------------------------------------"
		"                           REPLAYGAIN ADD ERROR LOG"
		"                           ------------------------"
		"    This log details which directories have FLAC files that have errors when"
		"  applying ReplayGain values"
		"--------------------------------------------------------------------------------"
	)

	header_replay_test=(
		"--------------------------------------------------------------------------------"
		"                           REPLAYGAIN TEST ERROR LOG"
		"                           -------------------------"
		"    This log details which FLAC files have errors when testing for ReplayGain"
		"  compatability"
		"--------------------------------------------------------------------------------"
	)

	header_retag=(
		"--------------------------------------------------------------------------------"
		"                                RETAG ERROR LOG"
		"                                ---------------"
		"         This log details which FLAC files have errors when retagging"
		"--------------------------------------------------------------------------------"
	)

	header_test=(
		"--------------------------------------------------------------------------------"
		"                             TEST FLACS ERROR LOG"
		"                             --------------------"
		"          This log details which FLAC files have errors when testing"
		"--------------------------------------------------------------------------------"
	)

	# Set log file and the type of header to prepend based on how this function
	# was called, via $1
	case "${1}" in
		aucdtect)         header=( "${header_aucdtect[@]}"        )  ;;
		compress)         header=( "${header_compress[@]}"        )  ;;
		extract_artwork)  header=( "${header_extract_artwork[@]}" )  ;;
		md5_check)        header=( "${header_md5[@]}"             )  ;;
		prune)            header=( "${header_prune[@]}"           )  ;;
		replaygain_add)   header=( "${header_replay_add[@]}"      )  ;;
		replaygain_test)  header=( "${header_replay_test[@]}"     )  ;;
		retag)            header=( "${header_retag[@]}"           )  ;;
		test)             header=( "${header_test[@]}"            )  ;;
	esac

	# Create array of current log file
	mapfile -n0 -t log_array < "${log_file}"

	for line in "${log_array[@]}" ; do
		# Find the longest filename in the log file, and store it's length
		#--
		# 'path/to/file.flac::::error message' -> 'path/to/file.flac'
		filename="${line%%.flac::::*}.flac"

		# Use 'wc -L' for apparent length, not number of characters
		if (( $(wc -L <<< ${filename}) > length )) ; then
			length=$(wc -L <<< ${filename})
		fi
	done

	# Log header, truncating old log
	printf "%s\n" "${header[@]}" > "${log_file}"

	for line in "${log_array[@]}" ; do
		# Left align filenames and line up error messages before appending to
		# log file
		#--
		# 'path/to/file.flac::::error message' -> 'path/to/file.flac'
		filename="${line%%.flac::::*}.flac"

		# Use 'wc -L' for apparent length, not number of characters
		filename_length=$(wc -L <<< "${filename}")

		# 'path/to/file.flac::::error message' -> 'error message'
		error_msg="${line##*.flac::::}"

		# Example line: /media/Music/Artist/Album/file.flac  ->  Error Message
		printf "%s%$((length - filename_length))s  ->  %s\n" "${filename}" "" "${error_msg}" >> "${log_file}"
	done
}

#-------------------------------------------------------------------------------

__operation_message () {
	#---------------------------------------------------------------------------
	# Print out current operation message.
	#
	# $1 determines which title message to print (if any).  Possible values:
	#   aucdtect          compress   extract_artwork
	#   md5_check         prune      replaygain
	#   retag             test
	#
	# $2 determines which sub message to print (if any).  Possible values:
	#   replaygain_add    replaygain_test
	#   retag_analyze     retag_apply
	#---------------------------------------------------------------------------
	# Set up local variables
	declare message

	# Define message to print based off of $1
	case "${1}" in
		aucdtect)         message="auCDtect Analysis"    ;;
		compress)         message="Compressing & Verifying ${magenta}[Level 8]${normal}"  ;;
		extract_artwork)  message="Extracting Artwork"   ;;
		md5_check)        message="MD5 Check"            ;;
		replaygain)       message="Generating & Applying ReplayGain"  ;;
		retag)            message="Re-Tagging"           ;;
		test)             message="Testing"              ;;
		prune)
			if [[ "${remove_artwork}" != "true" ]] ; then
				# Keep artwork
				message="Pruning All Blocks [Except: ${cyan}STREAMINFO${normal}, ${cyan}VORBIS_COMMENT${normal} & ${cyan}PICTURE${normal}"
			else
				# Remove artwork
				message="Pruning All Blocks [Except: ${cyan}STREAMINFO${normal} & ${cyan}VORBIS_COMMENT${normal}"
			fi
		;;
	esac

	# Print title message if $1 is not NULL
	[[ -n "${1}" ]] && printf "\033[$(__row)H ${green}*${normal} ${message}\n"

	# Define sub message to print based off of $2
	case "${2}" in
		replaygain_test)  message="Testing"      ;;
		replaygain_add)   message="Applying"     ;;
		retag_analyze)    message="Analyzing"    ;;
		retag_apply)      message="Re-Applying"  ;;
	esac

	# Print sub message if $2 is not NULL
	[[ -n "${2}" ]] && printf "\033[$(__row);4H${green}>${normal} ${message}\n"
}

#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# .: PROCESSED FILE/DIRECTORY MESSAGES :.
#-------------------------------------------------------------------------------
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Current Files Operated On
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Print the current FLAC file being operated on
__print_current_flac () {
	# This stores the current file number processed out of the total files:
	#  [56/213]
	number_completed="[${iteration}/${#total_flacs_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  FLACs processed and total FLACs, ie: [56/213]
	#                     11:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (6) Percentage: '  100%' or '    3%'
	max_filename_length="$(( columns - ${#number_completed} - 11 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};9H%s%$(__current_length)s${magenta}%s${normal}" \
	"${filename}" "" "${number_completed}"
}

# Print the current FLAC file being pruned
__print_current_half () {
	# This stores the current file number processed out of the total files:
	#  [56/213]
	number_completed="[${iteration}/${#total_flacs_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  FLACs processed and total FLACs, ie: [56/213]
	#                     11:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (6) Percentage: '  100%' or '    3%'
	max_filename_length="$(( columns - ${#number_completed} - 11 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};4H${yellow}%s${normal} %s%$(__current_length)s${magenta}%s${normal}" \
	" 50%" "${filename}" "" "${number_completed}"
}

# Print the current directory being operated on
__print_current_directory () {
	# This stores the current directory number processed out of the total
	# number of directories:
	#  [6/34]
	number_completed="[${iteration}/${#flac_directories_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  Dirs processed and total dirs, ie: [6/34]
	#                     13:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (8) Percentage: '    100%' or '      3%'
	max_filename_length="$(( columns - ${#number_completed} - 13 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};6H${yellow}%s${normal} %s%$(__current_length)s${magenta}%s${normal}" \
	" 50%" "${filename}" "" "${number_completed}"
}

# Print the current FLAC file being operated on (for sub messages)
__print_sub_current_flac () {
	# This stores the current file number processed out of the total files:
	#  [56/213]
	number_completed="[${iteration}/${#total_flacs_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  FLACs processed and total FLACs, ie: [56/213]
	#                     11:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (8) Percentage: '  100%' or '    3%'
	max_filename_length="$(( columns - ${#number_completed} - 13 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};11H%s%$(__current_length)s${magenta}%s${normal}" \
	"${filename}" "" "${number_completed}"
}

# Print the current FLAC file being operated on with skip message
__print_skip_flac () {
	# This stores the current file number processed out of the total files:
	#  [56/213]
	number_completed="[${iteration}/${#total_flacs_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  FLACs processed and total FLACs, ie: [56/213]
	#                     11:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (6) Percentage: '100%' or '  3%'
	max_filename_length="$(( columns - ${#number_completed} - 11 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};4H${yellow}skip${normal} %s%$(__current_length)s${magenta}%s${normal}" \
	"${filename}" "" "${number_completed}"
}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# auCDtect
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Print the current FLAC file being decoded
__print_decoding_flac () {
	# This stores the current file number processed out of the total files:
	#  [56/213]
	number_completed="[${iteration}/${#total_flacs_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  FLACs processed and total FLACs, ie: [56/213]
	#                     22:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (6) Percentage: '  100%' or '    3%'
	#                            (11) '[Decoding] '
	max_filename_length="$(( columns - ${#number_completed} - 22 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};9H${cyan}[Decoding]${normal} %s%$(__current_length)s${magenta}%s${normal}" \
	"${filename}" "" "${number_completed}"
}

# Display the filename, clearing the progress bar and display the progress
# percentage as 100% (since FLAC stops at 99%) in green
__print_decoding_ok () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${green}%s${normal} ${cyan}%s${normal} %s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"100%" "[Decoding]" "${filename}" ""
	else
		printf "\033[${placement};4H${green}%s${normal} ${cyan}%s${normal} %s" \
		"100%" "[Decoding]" "${filename}"
	fi
}

# Display the filename, clearing the progress bar and display the progress
# percentage as fail (since the file failed to decode the properly)
__print_decoding_fail () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${red}%s${normal} ${cyan}%s${normal} %s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"fail" "[Decoding]" "${filename}" ""
	else
		printf "\033[${placement};4H${red}%s${normal} ${cyan}%s${normal} %s" \
		"fail" "[Decoding]" "${filename}"
	fi
}

# Print the current FLAC file being analyzed with auCDtect [fast]
__print_current_aucdtect_fast () {
	# This stores the current file number processed out of the total files:
	#  [56/213]
	number_completed="[${iteration}/${#total_flacs_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  FLACs processed and total FLACs, ie: [56/213]
	#                     28:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (6) Percentage: '  100%' or '    3%'
	#                            (17) '[auCDtect: fast] '
	max_filename_length="$(( columns - ${#number_completed} - 28 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};9H${cyan}[auCDtect: fast]${normal} %s%$(__current_length)s${magenta}%s${normal}" "${filename}" "" "${number_completed}"
}

# Display the filename, clearing the progress bar and display the progress
# percentage as 100% (since FLAC stops at 99%) in green
__print_aucdtect_fast_ok () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${green}%4s${normal} ${cyan}%s${normal}%s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"100%" "[auCDtect: Fast]" " ${filename}" ""
	else
		printf "\033[${placement};4H${green}%4s${normal} ${cyan}%s${normal}%s" \
		"100%" "[auCDtect: Fast]" " ${filename}"
	fi
}

# Display the filename, clearing the progress bar and display the progress as an
# error in red
__print_aucdtect_fast_fail () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${red}%4s${normal} ${cyan}%s${normal}%s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"fail" "[auCDtect: Fast]" "${filename}" ""
	else
		printf "\033[${placement};4H${red}%4s${normal} ${cyan}%s${normal}%s" \
		"fail" "[auCDtect: Fast]" "${filename}"
	fi
}

# Print the current FLAC file being analyzed with auCDtect [slow]
__print_current_aucdtect_slow () {
	# This stores the current file number processed out of the total files:
	#  [56/213]
	number_completed="[${iteration}/${#total_flacs_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  FLACs processed and total FLACs, ie: [56/213]
	#                     28:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (6) Percentage: '  100%' or '    3%'
	#                            (17) '[auCDtect: slow] '
	max_filename_length="$(( columns - ${#number_completed} - 28 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};9H${cyan}[auCDtect: Slow]${normal} %s%$(__current_length)s${magenta}%s${normal}" \
	"${filename}" "" "${number_completed}"
}

# Display the filename, clearing the progress bar and display the progress
# percentage as 100% (since FLAC stops at 99%) in green
__print_aucdtect_slow_ok () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${green}%s${normal} ${cyan}%s${normal} %s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"100%" "[auCDtect: Slow]" "${filename}" ""
	else
		printf "\033[${placement};4H${green}%s${normal} ${cyan}%s${normal} %s" \
		"100%" "[auCDtect: Slow]" "${filename}"
	fi
}

# Display the filename, clearing the progress bar and display the progress as an
# error in red
__print_aucdtect_slow_fail () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${red}%s${normal} ${cyan}%s${normal} %s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"fail" "[auCDtect: Slow]" "${filename}" ""
	else
		printf "\033[${placement};4H${red}%s${normal} ${cyan}%s${normal} %s" \
		"fail" "[auCDtect: Slow]" "${filename}"
	fi
}

# Display the filename, clearing the progress bar and display the progress as an
# error in yellow color
__print_aucdtect_issue () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${yellow}%s${normal} ${cyan}%s${normal} %s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"chck" "[auCDtect: Slow]" "${filename}" ""
	else
		printf "\033[${placement};4H${yellow}%s${normal} ${cyan}%s${normal} %s" \
		"chck" "[auCDtect: Slow]" "${filename}"
	fi
}

# Print the current FLAC file, detailing a spectrogram is being created
__print_current_spectrogram () {
	# This stores the current file number processed out of the total files:
	#  [56/213]
	number_completed="[${iteration}/${#total_flacs_array[@]}]"

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#   ${#number_completed}:  FLACs processed and total FLACs, ie: [56/213]
	#                     25:  Length of:
	#                            (4) Spaces
	#                            (1) Gap and ellipsis: '…'
	#                            (6) Percentage: '  100%' or '    3%'
	#                            (14) '[Spectrogram] '
	max_filename_length="$(( columns - ${#number_completed} - 25 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\033[${placement};9H${cyan}[Spectrogram]${normal} %s%$(__current_length)s${magenta}%s${normal}" "${filename}" "" "${number_completed}"
}

# Display the filename, clearing the progress bar and display the progress as an
# error in red
__print_spectrogram_issue () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${yellow}%s${normal} ${cyan}%s${normal} %s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"chck" "[Spectrogram]" "${filename}" ""
	else
		printf "\033[${placement};4H${yellow}%s${normal} ${cyan}%s${normal} %s" \
		"chck" "[Spectrogram]" "${filename}"
	fi
}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Current file/directory with percentage completed
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Display filename and current progress of operation
__print_progress () {
	# Obtain the percentage of the current operation, the was it's obtained
	# was defined earlier and stored in the below variable
	${obtain_percentage}

	# This is the length of the progress bar represented as the maxmimum
	# filename we can use.  The progress bar is displayed by taking the
	# percentage completed thus far and using the percentage to display that
	# same percentage of the filename's length (including spaces that may appear
	# after it)
	progress_bar_length=$(( ( max_filename_length * percent_complete ) / 100 ))

	# If the progress bar to display is less than or equal to the filename's
	# length, print out the part of the filename that matches the percentage
	# completed, inverting the colors.  Otherwise, print out the filename,
	# inverted as well as the percentage of spacing that may be after the
	# filename (matching the percentage of completed); also inverted
	if (( progress_bar_length < current_filename_length )) ; then

		# Below takes the current filename and 'trims' off the part of the
		# filename that hasn't doesn't match the percentage length of what's
		# completed so far (trim meaning, not highlighting that portion of the
		# filename)
		printf "\033[${placement};4H${yellow}%4s${normal} ${invert}%s${normal}%s" \
		"${percent_complete}%" "${filename:0:$(( progress_bar_length + 1 ))}"
	else

		# This prints out the the filename, inverted, as well as the current
		# progress bar length.  Used only if the filename is less than the width
		# of the progress bar maximum's length
		printf "\033[${placement};4H${yellow}%4s${normal} ${invert}%s%$(( progress_bar_length - current_filename_length + 1 ))s${normal}" \
		"${percent_complete}%" "${filename}" ""
	fi
}

# Display filename and current progress of decoding FLAC files
__print_decoding_progress () {
	# Obtain the percentage of the current operation, the was it's obtained
	# was defined earlier and stored in the below variable
	${obtain_percentage}

	# This is the length of the progress bar represented as the maxmimum
	# filename we can use.  The progress bar is displayed by taking the
	# percentage completed thus far and using the percentage to display that
	# same percentage of the filename's length (including spaces that may appear
	# after it)
	progress_bar_length=$(( ( max_filename_length * percent_complete ) / 100 ))

	# If the progress bar to display is less than or equal to the filename's
	# length, print out the part of the filename that matches the percentage
	# completed, inverting the colors.  Otherwise, print out the filename,
	# inverted as well as the percentage of spacing that may be after the
	# filename (matching the percentage of completed); also inverted
	if (( progress_bar_length < current_filename_length )) ; then

		# Below takes the current filename and 'trims' off the part of the
		# filename that hasn't doesn't match the percentage length of what's
		# completed so far (trim meaning, not highlighting that portion of the
		# filename)
		printf "\033[${placement};4H${yellow}%4s${normal} ${cyan}%s${normal}${invert}%s${normal}%s" \
		"${percent_complete}%" "[Decoding] " "${filename:0:$(( progress_bar_length + 1 ))}"
	else

		# This prints out the the filename, inverted, as well as the current
		# progress bar length.  Used only if the filename is less than the width
		# of the progress bar maximum's length
		printf "\033[${placement};4H${yellow}%4s${normal} ${cyan}%s${normal}${invert}%s%$(( progress_bar_length - current_filename_length + 1 ))s${normal}" \
		"${percent_complete}%" "[Decoding] " "${filename}" ""
	fi
}

# Display filename and current progress of auCDtect [fast] analysis
__print_progress_aucdtect_fast () {
	# Obtain the percentage of the current operation, the was it's obtained
	# was defined earlier and stored in the below variable
	${obtain_percentage}

	# This is the length of the progress bar represented as the maxmimum
	# filename we can use.  The progress bar is displayed by taking the
	# percentage completed thus far and using the percentage to display that
	# same percentage of the filename's length (including spaces that may appear
	# after it)
	progress_bar_length=$(( ( max_filename_length * percent_complete ) / 100 ))

	# If the progress bar to display is less than or equal to the filename's
	# length, print out the part of the filename that matches the percentage
	# completed, inverting the colors.  Otherwise, print out the filename,
	# inverted as well as the percentage of spacing that may be after the
	# filename (matching the percentage of completed); also inverted
	if (( progress_bar_length < current_filename_length )) ; then

		# Below takes the current filename and 'trims' off the part of the
		# filename that hasn't doesn't match the percentage length of what's
		# completed so far (trim meaning, not highlighting that portion of the
		# filename)
		printf "\033[${placement};4H${yellow}%4s${normal} ${cyan}%s${normal}${invert}%s${normal}%s" \
		"${percent_complete}%" "[auCDtect: Fast] " "${filename:0:$(( progress_bar_length + 1 ))}"
	else

		# This prints out the the filename, inverted, as well as the current
		# progress bar length.  Used only if the filename is less than the width
		# of the progress bar maximum's length
		printf "\033[${placement};4H${yellow}%4s${normal} ${cyan}%s${normal}${invert}%s%$(( progress_bar_length - current_filename_length + 1 ))s${normal}" \
		"${percent_complete}%" "[auCDtect: Fast] " "${filename}" ""
	fi
}

# Display filename and current progress of auCDtect [slow] analysis
__print_progress_aucdtect_slow () {
	# Obtain the percentage of the current operation, the was it's obtained
	# was defined earlier and stored in the below variable
	${obtain_percentage}

	# This is the length of the progress bar represented as the maxmimum
	# filename we can use.  The progress bar is displayed by taking the
	# percentage completed thus far and using the percentage to display that
	# same percentage of the filename's length (including spaces that may appear
	# after it)
	progress_bar_length=$(( ( max_filename_length * percent_complete ) / 100 ))

	# If the progress bar to display is less than or equal to the filename's
	# length, print out the part of the filename that matches the percentage
	# completed, inverting the colors.  Otherwise, print out the filename,
	# inverted as well as the percentage of spacing that may be after the
	# filename (matching the percentage of completed); also inverted
	if (( progress_bar_length < current_filename_length )) ; then

		# Below takes the current filename and 'trims' off the part of the
		# filename that hasn't doesn't match the percentage length of what's
		# completed so far (trim meaning, not highlighting that portion of the
		# filename)
		printf "\033[${placement};4H${yellow}%4s${normal} ${cyan}%s${normal}${invert}%s${normal}%s" \
		"${percent_complete}%" "[auCDtect: Slow] " "${filename:0:$(( progress_bar_length + 1 ))}"
	else

		# This prints out the the filename, inverted, as well as the current
		# progress bar length.  Used only if the filename is less than the width
		# of the progress bar maximum's length
		printf "\033[${placement};4H${yellow}%4s${normal} ${cyan}%s${normal}${invert}%s%$(( progress_bar_length - current_filename_length + 1 ))s${normal}" \
		"${percent_complete}%" "[auCDtect: Slow] " "${filename}" ""
	fi
}

# Display filename and current progress of creating a spectrogram
__print_progress_spectrogram () {
	# Obtain the percentage of the current operation, the was it's obtained
	# was defined earlier and stored in the below variable
	${obtain_percentage}

	# This is the length of the progress bar represented as the maxmimum
	# filename we can use.  The progress bar is displayed by taking the
	# percentage completed thus far and using the percentage to display that
	# same percentage of the filename's length (including spaces that may appear
	# after it)
	progress_bar_length=$(( ( max_filename_length * percent_complete ) / 100 ))

	# If the progress bar to display is less than or equal to the filename's
	# length, print out the part of the filename that matches the percentage
	# completed, inverting the colors.  Otherwise, print out the filename,
	# inverted as well as the percentage of spacing that may be after the
	# filename (matching the percentage of completed); also inverted
	if (( progress_bar_length < current_filename_length )) ; then

		# Below takes the current filename and 'trims' off the part of the
		# filename that hasn't doesn't match the percentage length of what's
		# completed so far (trim meaning, not highlighting that portion of the
		# filename)
		printf "\033[${placement};4H${yellow}%4s${normal} ${cyan}%s${normal}${invert}%s${normal}%s" \
		"${percent_complete}%" "[Spectrogram] " "${filename:0:$(( progress_bar_length + 1 ))}"
	else

		# This prints out the the filename, inverted, as well as the current
		# progress bar length.  Used only if the filename is less than the width
		# of the progress bar maximum's length
		printf "\033[${placement};4H${yellow}%4s${normal} ${cyan}%s${normal}${invert}%s%$(( progress_bar_length - current_filename_length + 1 ))s${normal}" \
		"${percent_complete}%" "[Spectrogram] " "${filename}" ""
	fi
}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Resultant operation status
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Display the filename, clearing the progress bar and display the progress
# percentage as 100% (since FLAC stops at 99%) in green
__print_progress_ok () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${green}%4s${normal} %s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"100%" "${filename}" ""
	else
		printf "\033[${placement};4H${green}%4s${normal} %s" \
		"100%" "${filename}"
	fi
}

# Display the filename, clearing the progress bar and display the progress as an
# error in yellow color
__print_progress_issue () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${yellow}%s${normal} %s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"chck" "${filename}" ""
	else
		printf "\033[${placement};4H${yellow}%s${normal} %s" \
		"chck" "${filename}"
	fi
}

# Display the filename, clearing the progress bar and display the progress as an
# error in red color
__print_progress_failed () {
	if (( current_filename_length < max_filename_length )) ; then
		printf "\033[${placement};4H${red}%s${normal} %s%$(( max_filename_length - current_filename_length + 1 ))s" \
		"fail" "${filename}" ""
	else
		printf "\033[${placement};4H${red}%s${normal} %s" \
		"fail" "${filename}"
	fi
}

# Display the filename, clearing the progress bar and display the progress as an
# error in yellow color (for sub messages)
__print_sub_progress_issue () {
	printf "\033[${placement};6H${yellow}%s${normal} %s" \
	"chck" "${filename}"
}

# Display the filename, clearing the progress bar and display the progress
# percentage as 100% (since FLAC stops at 99%) in green (for sub messages)
__print_sub_progress_ok () {
	printf "\033[${placement};6H${green}%s${normal} %s" \
	"100%" "${filename}"
}

# Display the filename, clearing the progress bar and display the progress as an
# error in red color (for sub messages)
__print_sub_progress_failed () {
	printf "\033[${placement};6H${red}%s${normal} %s" \
	"fail" "${filename}"
}

#== .: PROCESSED FILE/DIRECTORY MESSAGES :. ====================================

#-------------------------------------------------------------------------------

__trap_sigint () {
	#---------------------------------------------------------------------------
	# Kill any children process and display the correct interrupt message when
	# a user sends SIGINT during script execution.
	#
	# $1 is where to place the cursor (row-wise) in order to not overwrite
	# files/directories displayed already.
	#
	# $2 determines which additional cleanup may need to be performed when
	# starting '__exit_cleanup'.  Possible values:
	#   aucdtect          compress        extract_artwork
	#   md5_check         prune           replaygain_add
	#   replaygain_test   retag_analyze   retag_apply
	#   test
	#---------------------------------------------------------------------------
	__kill_jobs "$(jobs -rp)"

	# If $1 is NULL, it means that the user invoked SIGINT before any operation
	# started (eg, retag countdown or config countdown)
	if [[ -n "${1}" ]] ; then
		printf "\033[${1};2H${green}*${normal} Control-C received, generating summary. Please wait...\n"
	else
		printf "\n ${green}*${normal} Control-C received, generating summary. Please wait...\n"
	fi

	__exit_cleanup "${2}"
}

#-------------------------------------------------------------------------------

__exit_cleanup () {
	#---------------------------------------------------------------------------
	# Do any additional cleanup and check for the existence of a log file before
	# exiting script.
	#
	# $1 determines which operation requires additional cleanup.  This value is
	# normally obtained from $2 in the '__trap_sigint' function.  Possible
	# values:
	#   aucdtect          compress        extract_artwork
	#   md5_check         prune           replaygain_add
	#   replaygain_test   retag_analyze   retag_apply
	#   test
	#---------------------------------------------------------------------------
	case "${1}" in
		aucdtect)
			# Remove temporarily created WAV files (if any)
			rm -f "${directory}"/**/*_redoflacs_"$$".wav
			operation_summary['Validate with auCDtect']='Operation Interrupted'
		;;
		compress)
			# Remove temporarily encoded FLAC files
			rm -f "${directory}"/**/*.tmp,fl-ac+en\'c
			operation_summary['Compress FLACs']='Operation Interrupted'
		;;
		extract_artwork)
			operation_summary['Extracting Artwork']='Operation Interrupted'
		;;
		md5_check)
			operation_summary['Check MD5 Signature']='Operation Interrupted'
		;;
		prune)
			operation_summary['Prune METADATA Blocks']='Operation Interrupted'
		;;
		replaygain_add)
			operation_summary['> Adding']='Operation Interrupted'
		;;
		replaygain_test)
			operation_summary['> Testing']='Operation Interrupted'
		;;
		retag_*)
			# Test for deprecated tag, COVERART, in log file.  If it
			# exists, set coverart_warning variable to make script output
			# warning upon completion
			if [[ -f "${log_file}" ]] ; then
				while read -r i ; do
					# Indentation is culled from reading in "${i}"
					# To change this, set IFS to '\n'
					if [[ "${i}" == *METADATA_BLOCK_PICTURE* ]] ; then
						coverart_warning="true"
						break
					fi
				done < "${log_file}"
			fi

			if [[ "$1" == 'retag_analyze' ]] ; then
				operation_summary['> Analyzing']='Operation Interrupted'
			elif [[ "$1" == 'retag_apply' ]] ; then
				operation_summary['> Applying']='Operation Interrupted'
			fi
		;;
		test)
			operation_summary['Test FLACs']='Operation Interrupted'
		;;
	esac

	if [[ -f "${log_file}"  && "${coverart_warning}" == 'true' ]] ; then
		# This block is only executed during the 'retag' operation
		#--
		# Display COVERART warning function and metadata issues
		printf "\n" >&2
		__coverart_warning

		# Print out log exists to STDERR
		__message_log_exists "$1"

		# Create and format log
		__create_log "$1"
	elif [[ -f "${log_file}" ]] ; then
		# Print out log exists to STDERR
		__message_log_exists "${1}"

		# Create and format log
		__create_log "${1}"
	fi

	# Restore old stty settings, make stty happy
	# by redirecting /dev/stderr
	stty ${old_stty} < /dev/stderr

	# Restore the cursor
	printf "\033[?25h"

	# Remove temporary FIFO and leave just the file
	# descriptor available
	rm -f "${tmp_fifo}"

	# Display Summary Of Operations
	__summary

	exit 130
}

#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# .: VARIOUS COMMANDS :.
#-------------------------------------------------------------------------------
# Display script version
__print_version () {
	printf "%s\n" "Version ${version}"
}

# Obtain `metaflac' version information to test on.  Example:
#   metaflac 1.3.0pre1
#   -----------^
# Test only the second integer in the version string above
__metaflac_version () {
	# Obtain entire version string, example:
	#    metaflac 1.3.0pre1
	metaflac_version="$(metaflac --version)"

	# Remove first part of string including first integer, example:
	#    3.0pre1
	metaflac_version="${metaflac_version#* [[:digit:]].}"

	# Remove last part of string, leaving only the second integer, example:
	#    3
	metaflac_version="${metaflac_version%.*}"
}

#-------------------------------------------------------------------------------

__kill_jobs () {
	#---------------------------------------------------------------------------
	# Kill any children process (obtained via $@), hiding any error output from
	# 'kill' and supressing the shell's notification of terminated jobs
	#---------------------------------------------------------------------------
	for pid in $@ ; do
		kill $pid 2>/dev/null
		wait $pid 2>/dev/null
	done
}

#-------------------------------------------------------------------------------

__row () {
	#---------------------------------------------------------------------------
	# Print out the current cursor row position
	#---------------------------------------------------------------------------
	exec < /dev/tty              # Set a new TTY to read in STDIN
	row_old_stty="$(stty -g)"    # Store current TTY settings
	stty raw -echo min 0         # Current TTY set at an absolute minimum

	# Print escape sequence to obtain cursor position into the new TTY
	printf "\033[6n" > /dev/tty

	# Read in escape sequence output from TTY.  The resultant output from the
	# escape sequence looks like:
	#  ^[<integer>;<integer>R
	#       ^------------ This is the 'row' we want to obtain
	# The read then specifies the 'R' is the delimeter to stop reading in from,
	# storing this string into the $current_row variable
	IFS=';' read -r -d R current_row _

	stty "${row_old_stty}"          # Restore the old TTY settings

	# Return current row position (integer)
	printf "%s" "${current_row#??}"
}

#-------------------------------------------------------------------------------

# Check if we need to scroll the terminal up depending on how much room is left,
# relative to the number of jobs to process.  There is the special value of ${1}
# which signifies a number to remove from the total lines to scroll.  This
# number will only occur if the number of files/directories to process is less
# than the jobs specified to run.  This allows us to _NOT_ have extra gaps in
# our output
__scroll_terminal () {
	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r _ _ _ _ lines _ columns _ < <(stty -a < /dev/stderr)

	# Remove semicolons from obtain columns and lines
	#--
	# Terminal width
	columns="${columns%;}"

	# Terminal height
	lines="${lines%;}"

	# If 'directory' is specified as ${1}, we will process the number of lines
	# to remove as the total number of directories, else we'll use the total
	# number of files
	if [[ "${1}" == "directory" ]] ; then
		# If the total number of directories to process is less than jobs
		# specified, then set the number of lines to remove from the terminal
		# scroll as the difference of the number of jobs minus the total number
		# of directories
		if (( ${#flac_directories_array[@]} < jobs )) ; then
			# This variable will be used for '__scroll_terminal' as ${1}
			local remove_from_scroll="$(( jobs - ${#flac_directories_array[@]} ))"
		fi
	else
		# If the total number of files to process is less than jobs specified,
		# then set the number of lines to remove from the terminal scroll as the
		# difference of the number of jobs minus the total number of files
		if (( ${#total_flacs_array[@]} < jobs )) ; then
			# This variable will be used for '__scroll_terminal' as ${1}
			local remove_from_scroll="$(( jobs - ${#total_flacs_array[@]} ))"
		fi
	fi

	# If ${remove_from_scroll} is NULL, then the remaining lines we have left is
	# the number of lines available (in the terminal) minus the row we are
	# currently on.  If ${remove_from_scroll} is _NOT_ NULL, the remaining lines
	# we have left is the same with the addition of ${remove_from_scroll}.  This
	# enforces we are able to scroll the terminal correctly in the event the user
	# specified more jobs than there are files/directories to process
	if [[ -z "${remove_from_scroll}" ]] ; then
		# Obtain the remaining lines left in the current terminal
		remaining_lines=$(( lines - $(__row) ))
	else
		# Obtain the remaining lines left in the current terminal as well as
		# adding in the the number of lines we don't want to scroll
		remaining_lines=$(( lines - $(__row) + remove_from_scroll ))
	fi

	# If the remaining lines is less than the jobs used, the terminal will not
	# have enough room for the script to place lines, so we will have to
	# non-descructively scroll the terminal up enough lines to allow for the
	# current operations to be printed correctly
	if (( remaining_lines < jobs )) ; then
		# Obtain the number of lines need to equal the current number of jobs
		local lines_to_scroll=$(( jobs - remaining_lines ))

		# This scrolls the terminal up by the number of lines to scroll
		# This can be accomplished via (not very portable):
		#   printf "\033[<integer>S"    # Doesn't work in screen/tmux
		for ((i=1 ; i<=lines_to_scroll ; i++)) ; do
			printf "\n"
		done

		# The cursor is set to the difference of the lines to scroll
		printf "\033[$(( $(__row) - lines_to_scroll ))H"
	fi
}

# Obtain the current progress completed percentage while compressing FLAC files
__obtain_compress_percentage () {
	# Remove backspace sequences used by the FLAC command line interface
	percent_complete="${percent_complete///}"

	# Remove the first part of the line leaving only the percent integer as well
	# as other information:
	#  '0 complete, ratio=0.307'
	percent_complete="${percent_complete##*: }"

	# Remove the last part part of the percent_complete string, leaving the
	# percent stored as an integer
	percent_complete="${percent_complete##*complete, ratio=?.???}"

	# Enforce an integer for ${percent_complete}, defaulting to '0' if not an
	# integer
	[[ "${percent_complete}" =~ ^[[:digit:]]+$ ]] || percent_complete=0
}

# Obtain the current progress completed percentage while testing FLAC file
__obtain_test_percentage () {
	# Remove the first part of the line to leave the resultant percent stored as
	# an integer (no '%' appended)
	percent_complete="${percent_complete##* }"

	# Enforce an integer for ${percent_complete}, defaulting to '0' if not an
	# integer
	[[ "${percent_complete}" =~ ^[[:digit:]]+$ ]] || percent_complete=0
}

# Obtain the current progress completed percentage while decoding FLAC file
__obtain_decode_percentage () {
	# Remove backspace sequences used by the FLAC command line interface
	percent_complete="${percent_complete///}"

	# Remove the first part of the line leaving only the percent integer as well
	# as well as other information:
	#  'complete0
	percent_complete="${percent_complete##*: }"

	# Remove the last part part of the percent_complete string, leaving the
	# percent stored as an integer
	percent_complete="${percent_complete##*complete}"

	# Enforce an integer for ${percent_complete}, defaulting to '0' if not an
	# integer
	[[ "${percent_complete}" =~ ^[[:digit:]]+$ ]] || percent_complete=0
}

# Obtain the current progress completed percentage while using auCDtect
__obtain_aucdtect_percentage () {
	# Remove the first part of the line to leave the resultant percent stored as
	# an integer (no '%' appended)
	percent_complete="${percent_complete##*[}"

	# Enforce an integer for ${percent_complete}, defaulting to '0' if not an
	# integer
	[[ "${percent_complete}" =~ ^[[:digit:]]+$ ]] || percent_complete=0
}

# Obtain the current progress completed percentage while using auCDtect
__obtain_spectrogram_percentage () {
	# Remove the first part of the line leaving only the percent which is
	# represented as a floating point number:
	#  '32.3'
	percent_complete="${percent_complete##*In:}"

	# Remove the floating point part of the percentage to leave only an integer
	percent_complete="${percent_complete%%.*}"

	# Enforce an integer for ${percent_complete}, defaulting to '0' if not an
	# integer
	[[ "${percent_complete}" =~ ^[[:digit:]]+$ ]] || percent_complete=0
}

# Store the position of the current job being displayed
__store_position () {
	# If the current job(s) are the first set, we'll use the iteration
	# (starting at 0 -- hence the minus 1) of the job to start
	if (( iteration <= jobs )) ; then
		printf "$(( iteration - 1 ))\n" >&3
	else
		# Print the position of the current jobs into file descriptor (3) to be
		# stored by 'read' upon starting the next job
		printf "${previous_operation_position}\n" >&3
	fi
}

# Force the creation of a new configuration file
__new_config () {
	# Check if configuration file exists based of ${EUID}.  If it doesn't
	# exist, create one
	if (( EUID == 0 )) ; then
		# User is root
		#
		# Configuration file location
		config_location="/etc/redoflacs.conf"

		# If there already is a configuration file, do not overwrite it
		if [[ -f "${config_location}" ]] ; then
			config_location="/etc/_$$.redoflacs.conf"
		fi
	else
		# User is _NOT_ root
		#
		# Configuration file location
		config_location="${HOME}/.config/redoflacs/config"

		# If there already is a configuration file, do not overwrite it
		if [[ -f "${config_location}" ]] ; then
			config_location="${HOME}/.config/redoflacs/_$$.config"
		fi
	fi

	# Creates the (new) configuration file
	__create_config

	# Explain to user where to find the new configuration file
	__info "A new configuration file has been created here:\n"
	__info "${cyan}${config_location}${normal}\n\n"

	__info "It's recommended to review the new configuration file\n"
	__info "and transfer over any changes you made in your old\n"
	__info "configuration file.\n\n"

	__info "After making the changes (if any), rename the new\n"
	__info "configuration file to your old configuration file\n"
	__info "name.  Here is the command you could use:\n"

	if (( EUID == 0 )) ; then
		__info "${cyan}mv${normal} ${cyan}${config_location}${normal} ${cyan}/etc/redoflacs.conf${normal}\n"
	else
		__info "${cyan}mv${normal} ${cyan}${config_location}${normal} ${cyan}${HOME}/.config/redoflacs/config${normal}\n"
	fi
}

# Create a configuration file
__create_config () {
create_config="################################################################################
#                                                                              #
#                         REDOFLACS USER CONFIGURATION                         #
#                         ----------------------------                         #
#                                                                              #
#  Any line that is _NOT_ prepended with a '#' will be interpreted as an       #
#  option (except for blank lines -- these are not interpreted)                #
#                                                                              #
#  See \`redoflacs --help\` for a detailed description of each parameter         #
#                                                                              #
################################################################################

#-------------------------------------------------------------------------------
#  :: TAGGING SECTION ::
#-------------------------------------------------------------------------------
# List the tags to be kept in each FLAC file.  The default is listed below.
#
# Another common tag not added by default is ALBUMARTIST.  Uncomment ALBUMARTIST
# below to allow script to keep this tag.

TITLE
ARTIST
#ALBUMARTIST
ALBUM
DISCNUMBER
DATE
TRACKNUMBER
TRACKTOTAL
GENRE

# The COMPRESSION tag is a custom tag to allow the script to determine which
# level of compression the FLAC file(s) has/have been compressed at.
COMPRESSION

# The RELEASETYPE tag is a custom tag the author of this script uses to
# catalogue what kind of release the album is (ie, Full Length, EP, Demo, etc.).
RELEASETYPE

# The SOURCE tag is a custom tag the author of this script uses to catalogue
# which source the album has derived from (ie, CD, Vinyl, Digital, etc.).
SOURCE

# The MASTERING tag is a custom tag the author of this script uses to catalogue
# how the album has been mastered (ie, Lossless, or Lossy).
MASTERING

# The REPLAYGAIN tags below, are added by the '-g, --replaygain' or
# '-G, --replaygain-noforce' argument.  If you want to keep the replaygain tags,
# make sure you leave these here.
REPLAYGAIN_REFERENCE_LOUDNESS
REPLAYGAIN_TRACK_GAIN
REPLAYGAIN_TRACK_PEAK
REPLAYGAIN_ALBUM_GAIN
REPLAYGAIN_ALBUM_PEAK

#== :: END TAGGING SECTION :: ==================================================

#-------------------------------------------------------------------------------
#  :: OPTIONS ::
#-------------------------------------------------------------------------------
#~~~~~~~~~~~~~~~~~~
#  REMOVE ARTWORK
#~~~~~~~~~~~~~~~~~~
# Set whether to remove embedded artwork within FLAC files.  By default, this
# script will remove any artwork it can find, whether it's in the legacy
# COVERART tag or METADATA_BLOCK_PICTURE.  Set 'remove_artwork' as 'true' to
# remove embedded artwork.  All other values are intepreted as 'false'.
remove_artwork=\"true\"

#~~~~~~~~~~~~~~~~~~~
#  SET COMPRESSION
#~~~~~~~~~~~~~~~~~~~
# Set the type of COMPRESSION to compress the FLAC files.  Numbers range from
# '1-8', with '1' being the lowest compression and '8' being the highest
# compression.  The default is '8'.
compression_level=\"8\"

#~~~~~~~~~~~~~~~~~~~~~~~
#  ERROR LOG DIRECTORY
#~~~~~~~~~~~~~~~~~~~~~~~
# Set the where you want the error logs to be placed.  By default, they are
# placed in the user's HOME directory.
error_log=\"\${HOME}\"

#~~~~~~~~~~~~~~~~~~~~~~~
#  AUCDTECT SKIP LOSSY
#~~~~~~~~~~~~~~~~~~~~~~~
# Set whether FLAC files should be skipped if the MASTERING tag is already set
# as 'Lossy' when analyzed with auCDtect.  Set 'skip_lossy' as 'true' to to skip
# FLAC files that have the tag: 'MASTERING=Lossy'.  All other values are
# intepreted as 'false'.
skip_lossy=\"true\"

#~~~~~~~~~~~~~~~~~~~~~~~~~
#  SPECTROGRAM DIRECTORY
#~~~~~~~~~~~~~~~~~~~~~~~~~
# Set where the created spectrogram files should be placed.  By default, the
# spectrogram images will be placed in the same directory as the tested FLAC
# files. Each image will have the same name as the tested FLAC file but with
# the extension '.png'.
#
# All values for 'spectrogram_location' are interpreted as a directory.  If left
# blank, the default location will be used.
#
# An example of a user-defined location:
#    spectrogram_location=\"\${HOME}/Spectrogram_Images\"
#
# See '--help' or '-h' for more information.
spectrogram_location=\"\"

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  EXTRACTED ARTWORK DIRECTORY
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Set where the extracted artwork images should be placed.  By default, the
# extracted images will be placed in a subdirectory where the FLAC file is
# located.  The subdirectory has the same name as the FLAC file that's processed
# with a unique string appended to it:
#
#    [ Default directory example ]
#    /path/to/music/01_file.flac                          # FLAC with artwork
#    /path/to/music/01_file.flac_[redoflacs_art]_4342/    # Example subdirectory
#
# All values for 'artwork_location' are interpreted as a directory.  If left
# blank, the default location will be used.
#
# If there is a user-defined location, the extracted images will be placed in a
# subdirectory in that location with a naming scheme similar to the above
# example, but prefaced with the current number of FLAC files being processed:
#
#    [ User-defined location ]
#    artwork_location=\"\${HOME}/artwork\"
#
#    [ FLAC file to be processed ]
#    /path/to/music/01_file.flac
#
#    [ Resultant subdirectory with extracted artwork ]
#    \${HOME}/artwork/[1] 01_file.flac_[redoflacs_art]_4342/
#
# See '--help' or '-h' for more information.
artwork_location=\"\"

#~~~~~~~~~~~~~~~~~~~~~~~~
#  PREPEND TRACK NUMBER
#~~~~~~~~~~~~~~~~~~~~~~~~
# Change whether the '-r, --retag' operation will re-tag singular track numbers
# and track totals from:
#    [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
# to
#    [ 01, 02, 03, 04, 05, 06, 07, 08, 09 ]
#
# For example, if you had:
#    TRACKNUMBER=4
#     TRACKTOTAL=9
#
# You would end up with:
#    TRACKNUMBER=04
#     TRACKTOTAL=09
#
# This is enabled by setting 'prepend_zero' option as 'true'.  All other values
# are interpreted as 'false'.
prepend_zero=\"false\"

#== :: END OPTIONS :: ====== DO NOT DELETE THIS LINE! ====== :: REVISION 2 :: =="

	# Print out the configuration file to the specified location (either system-
	# wide or local)
	printf "%s\n" "${create_config}" > "${config_location}"
}

# Parse the configuration file
__parse_config () {
	# Load configuration file into an array
	mapfile -n0 -t config_file_array < "${config_location}"

	# For each line in the configuration file, obtain only the
	# lines that are part of the configuration
	for line in "${config_file_array[@]}" ; do
		# Strip line and replace with comment _ONLY_ if the line
		# starts with a comment
		test_line="${line/##*/#}"

		# If ${test_line} does not equal a comment and if ${line}
		# is not blank, store the current line (which is either
		# a tag to keep or an option) into an array for further
		# parsing
		if [[ "${test_line}" != "#" && "${line}" != "" ]] ; then
			# Add valid configuration lines into an array
			valid_config_array+=( "${line}" )
		fi
	done

	# For each line in the configuration, store the tag fields
	# and evaluate the options as variables into the environment
	for line in "${valid_config_array[@]}" ; do
		# ${value_type} holds the key=pair for options to be
		# parsed, else the line is a tag field
		value_type="${line//*=*/}"

		# If ${value_type} is _NOT_ null, then the line parsed
		# is a tag field
		if [[ -n "${value_type}" ]] ; then
			# Store the tag field into the tags array
			tags+=( "${line}" )
		else
			# Evaluate the option
			eval "${line}"
		fi
	done
}

# Check current configuration, if the version in the script is newer
# warn user and display a countdown before starting script
__check_config_version () {
	# Check if configuration file exists based of ${EUID}.  If it doesn't
	# exist, create one
	if (( EUID == 0 )) ; then
		# User is root
		#
		# Configuration file location
		config_location="/etc/redoflacs.conf"
	else
		# User is _NOT_ root
		#
		# Configuration file location
		config_location="${HOME}/.config/redoflacs/config"
	fi

	# Load configuration file into an array
	mapfile -n0 -t config_array < "${config_location}"

	# Obtain only the last line of the config
	config_last_line="${config_array[$(( ${#config_array[@]} - 1 ))]}"

	# Remove everything from the last line, except the REVISION number
	#
	# Below leaves:
	#  '<revision number> :: =='
	user_config_revision="${config_last_line#*REVISION }"
	# Obtains REVISION number
	user_config_revision="${user_config_revision% ::*}"

	# Check if ${user_config_revision} is an integer.  If not, display countdown
	# and warn user of new config file, else test if the user config revision is
	# less than the script config revision
	if [[ "${user_config_revision}" =~ ^[[:digit:]]+$ ]] ; then
		# If ${script_config_revision} is greater than ${user_config_revision}
		# warn user and display countdown
		if (( script_config_revision > user_config_revision )) ; then
			# Display warning and countdown
			__countdown_config ; printf '\n\n'
		fi
	else
		# Display warning and countdown
		__countdown_config ; printf '\n\n'
	fi
}

# Creates filename of current FLAC and culls it if the length
# is bigger than then width of the terminal
__filename () {
	filename="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	filename="${filename//$'\n'/?}"

	# Obtain filename length.  We cannot use ${#filename} in the event there is
	# multibyte characters -- the width would not be equal to characters since
	# the characters can take up more than one block in a terminal
	current_filename_length="$(wc -L <<< "${filename}")"

	# Cull filename and add an ellipsis if the filename is too long
	if (( current_filename_length > max_filename_length )) ; then

		# Grab the current filename length after it's been culled by the maximum
		# length allowed by ${columns}
		culled_filename_length="$(wc -L <<< "${filename:0:${max_filename_length}}")"

		# Set a placeholder ${max_filename_length} to be changed in the loop
		# below
		max_length="${max_filename_length}"

		# Keep looping until the culled filename length equals the maximum
		# length allowed via ${columns}
		until (( culled_filename_length == max_filename_length )) ; do

			# Decrement placeholder ${max_length} by one (1)
			((--max_length))
			
			# Obtain the new culled filename length
			culled_filename_length="$(wc -L <<< "${filename:0:${max_length}}")"

		done

		# Set the culled filename to display slicing the correct amount of
		# characters determined from ${max_length}
		filename="${filename:0:${max_length}}… "
	else
		# Set the default filename with a gap at the end for spacing
		filename="${filename} "
	fi
}

# Display current length spacing between filename and operation message
__current_length () {
	# The current length is obtained via the length of what's printed now minus
	# the length of the filename and gaps:
	#
	#  [1234/123456] 07 - Some_FLAC_Filename.flac <- ${current_length} -> [ Operation Message ]
	#                                             ^^^^^^^^^^^^^^^^^^^^^^^
	#  ${current_filename_length}:  Length of the current filename from __filename
	#  ${max_filename_length} + 1:  Total length of what's printed minus the operation
	#                               message plus one because we do not want the ellipsis
	#                               from ${max_filename_length}, just the space/gap
	#
	# Only print out ${current_length} if the current filename length is less
	# than the maximum file length allowed
	if (( current_filename_length <= max_filename_length )) ; then
		printf %d $(( max_filename_length - current_filename_length + 1 ))
	fi
}

# Determine number of jobs to run via the number
# of CPUs/cores available
__find_cores () {
	# Check if /proc is mounted by comparing device numbers of
	# /proc and / and see if they don't match (ie, /proc is mounted)
	if (( $(stat -c %d /proc) == $(stat -c %d /) )) ; then
		# /proc is not mounted, default to 2 jobs
		jobs_display="(Default)"
		jobs=2
	else
		# /proc is mounted, check for cpuinfo
		if [[ ! -f /proc/cpuinfo ]] ; then
			# /proc/cpuinfo doesn't exist
			jobs_display="(Default)"
			jobs=2
		else
			# /proc/cpuinfo exists, find total number
			# of cores to use

			# Store contents of /proc/cpuinfo into
			# cores_array
			mapfile -n0 -t cores_array < /proc/cpuinfo

			# For each line, if matched string is found,
			# add processor number to jobs variable
			for i in "${cores_array[@]}" ; do
				if [[ "${i}" == processor$'\t':\ * ]] ; then
					jobs="${i#processor$'\t': }"
				fi
			done

			# Add +1 to jobs since the number of useable cores
			# starts at 0
			((jobs++))
			jobs_display="(/proc/cpuinfo)"
		fi
	fi
}

# If COVERART tag is kept and remove_artwork is set to 'true'
# display conflict and exit
__coverart_remove_conflict () {
	# Check if COVERART exists in the tag array.  Notify user
	# of its deprecation and advise against using it, preferring
	# METADATA_BLOCK_PICTURE
	for j in "${tags[@]}" ; do

		if [[ "${j}" == "COVERART" ]] ; then

			# If remove_artwork is "true" (remove the artwork), then
			# exit and warn the user you can't specify whether you want to
			# remove artwork, yet keep the COVERART tag in configuration file
			if [[ "${remove_artwork}" == "true" ]] ; then

				# Display COVERART tag warning
				__coverart_warning

				__error "\nIt appears you have ${cyan}remove_artwork${normal} set to ${cyan}true${normal} in the\n" >&2
				__error "configuration file, yet ${cyan}COVERART${normal} is specified as one\n" >&2
				__error "(or more) of the FLAC tags to be kept. Please choose either\n" >&2
				__error "to keep album artwork (ie ${cyan}remove_artwork=\"false\"${normal}) or remove\n" >&2
				__error "the ${cyan}COVERART${normal} tag located in the configuration file.\n" >&2

				exit 1

			# COVERART was found, but artwork is to be removed,
			# so warn user of its deprecation
			else

				# Create coverart_warning variable, so script can append
				# the coverart_warning function after completion as well as
				# determine whether the script should temporarily add COVERART
				# to the tag array
				coverart_warning="true"
			fi
		fi
	done
}

# Find all the artwork blocks in the current FLAC file, storing each instance in
# an array to be processed
__find_artwork () {
	# Grab all the PICTURE blocks from current FLAC file, storing into an array
	mapfile -n0 -t artwork_blocks < <(metaflac --list --block-type=PICTURE "${i}")

	# Run through each line obtained above (stored into an array) and parse out
	# the block type we want
	for j in "${!artwork_blocks[@]}" ; do   # We want the current index (!)

		# If the current line has shows the type of block but isn't (PICTURE),
		# then we have the correct line (block type)
		if [[ "${artwork_blocks[${j}]}" == "  type: "* ]] && [[ "${artwork_blocks[${j}]}" != "  type: 6 (PICTURE)" ]] ; then

			# Obtain the METADATA block ID (4 lines above matched line)
			artwork_block_id="${artwork_blocks[$(( j - 4 ))]##* #}"

			# Obtain the MIME type of the image stored in the METADATA block,
			# to be used as the file extension
			artwork_extension="${artwork_blocks[$(( j + 1 ))]##  MIME type: */}"

			# If the image found is 'jpeg', use 'jpg' instead for consistency
			artwork_extension="${artwork_extension/jpeg/jpg}"

			# Obtain the PICTURE type, represented as a number
			artwork_type_number="${artwork_blocks[${j}]#  type: }"
			artwork_type_number="${artwork_type_number%% *}"

			# Obtain the PICTURE type, represented as a string/description.  All
			# forward slashes '/' are converted to hyphens '-', since this
			# description will be used as part of the image filename
			artwork_type_description="${artwork_blocks[${j}]#  type: * (}"
			artwork_type_description="${artwork_type_description%)}"
			artwork_type_description="${artwork_type_description//\//-}"

			# Check the PICTURE number we obtained and store the PICTURE
			# description and image extension into it's own array.  This will
			# allow for multiple artwork images of the same type to be stored
			# successfully and extracted
			case "${artwork_type_number}" in
				0)
					# [Artwork Description] Other
					artwork_other+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				1)
					# [Artwork Description] 32x32 pixels 'file icon' (PNG only)
					artwork_file_icon+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				2)
					# [Artwork Description] Other file icon
					artwork_other_file_icon+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				3)
					# [Artwork Description] Cover (front)
					artwork_cover_front+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				4)
					# [Artwork Description] Cover (back)
					artwork_cover_back+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				5)
					# [Artwork Description] Leaflet page
					artwork_leaflet+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				6)
					# [Artwork Description] Media (e.g. label side of CD)
					artwork_media_label+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				7)
					# [Artwork Description] Lead artist/lead performer/soloist
					artwork_lead_artist+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				8)
					# [Artwork Description] Artist/performer
					artwork_artist+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				9)
					# [Artwork Description] Conductor
					artwork_conductor+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				10)
					# [Artwork Description] Band/Orchestra
					artwork_band+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				11)
					# [Artwork Description] Composer
					artwork_composer+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				12)
					# [Artwork Description] Lyricist/text writer
					artwork_lyricist+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				13)
					# [Artwork Description] Recording Location
					artwork_recording_location+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				14)
					# [Artwork Description] During recording
					artwork_during_recording+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				15)
					# [Artwork Description] During performance
					artwork_during_performance+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				16)
					# [Artwork Description] Movie/video screen capture
					artwork_movie+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				17)
					# [Artwork Description] A bright coloured fish
					artwork_fish+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				18)
					# [Artwork Description] Illustration
					artwork_illustration+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				19)
					# [Artwork Description] Band/artist logotype
					artwork_band_logo+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				20)
					# [Artwork Description] Publisher/Studio logotype
					artwork_publisher_logo+=( "${artwork_type_description}.${artwork_extension}" )
				;;
				*)
					# Shouldn't happen as the valid artwork types are only 0-20
					__error "This is a BUG! Please report to:\n" >&2
					__error "${cyan}https://github.com/sirjaren/redoflacs/issues/new${normal}\n" >&2

					exit 1
				;;
			esac
		fi
	done
}

# Extract artwork image from the specified artwork block ID in the PICTURE block
# of the current FLAC file
__extract_artwork () {
	# $@ is the name of the artwork filename with the extension
	metaflac \
		--block-number="${artwork_block_id}" \
		--export-picture-to="${artwork_directory}/${@}" \
		"${i}"
}

# Top banner displaying invocation settings
__top_banner () {
	# If Redo Tags is called, create the necessary spacing
	if [[ "${retag_flac}" == "true" ]] ; then
		printf '\n\n'
	fi

	# Top title line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "---------------------------------------------------"

	# Title
	printf "${normal}%s\n" \
	"                Runtime Information"

	# Bottom title line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	# Script version
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
	"                  Version " "|" " " "${version}"

	# Processes to be used
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}%s${cyan}%s${normal}\n" \
	"            Parallel Jobs " "|" " " "${jobs}" " " "${jobs_display}"

	# Log directory
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
	"            Log Directory " "|" " " "${error_log}/"

	# Configuration directory
	if (( EUID == 0 )) ; then
		# Root: System-wide configuration
		config_directory="/etc/"
	else
		# Non root: User configuration
		config_directory="~/.config/redoflacs/"
	fi
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
	"         Config Directory " "|" " " "${config_directory}"

	# Bottom banner line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	# Message indicating the searching of FLAC files
	__info "Finding FLAC files to process..."
}

# Below creates the '[ ok ]' message to print after the info
# line above.  This will be displayed when all the FLAC files
# have been mapped to an array
__processed_flacs_ok () {
	printf "${normal}%11s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}\n" \
	"" "[" " " "ok" " " "]"
}

# Create a countdown function for the metadata
# to allow user to quit script safely
__countdown_metadata () {
	# Trap SIGINT (Control-C) to abort cleanly
	trap __trap_sigint SIGINT

	# Warning message
	__error "${yellow}CAUTION!${normal} These are the tag fields that will be kept\n" >&2
	__error "when re-tagging the selected files:\n\n" >&2

	# Creates the listing of tags to be kept
	for i in "${tags[@]}" ; do
		printf "     ${i}\n" >&2
	done

	# Warning message about embedded coverart
	printf "\n"
	__error "By default, this script will ${cyan}REMOVE${normal} the legacy (deprecated)\n" >&2
	__error "${cyan}COVERART${normal} tag when re-tagging files.  Change the ${cyan}remove_artwork${normal}\n" >&2
	__error "option (in the configuration file) to ${cyan}false${normal} to keep the legacy\n" >&2
	__error "${cyan}COVERART${normal} tag, or add the ${cyan}COVERART${normal} tag to the list of tags to\n" >&2
	__error "be kept in the ${cyan}TAGGING SECTION${normal} of the configuration file.\n\n" >&2

	__error "Keep in mind, if the ${cyan}remove_artwork${normal} option is set to ${cyan}false${normal},\n" >&2
	__error "embedded artwork in the ${cyan}PICTURE${normal} block will be kept when using\n" >&2
	__error "${cyan}-p, --prune${normal} option as well.\n\n" >&2

	__warn "Waiting ${red}10${normal} seconds before starting program...\n" >&2
	__warn "Ctrl+C (Control-C) to abort...\n" >&2
	__info "Starting in: "

	# 10 second countdown
	for count in {10..1} ; do
		printf "${red}%s${normal}%s" "$count" " "
		read -t1 # Sleep 1
	done
}

# Displays a countdown after a newer config is found than what
# the user has.  Allows user to quit script before proceeding
__countdown_config () {
	# Trap SIGINT (Control-C) to abort cleanly
	trap __trap_sigint SIGINT

	# Warning message
	__info "There is a newer configuration file available!\n\n"

	__warn "It is recommended you generate a new configuration\n" >&2
	__warn "file for use with this program.\n\n" >&2

	__warn "To generate a new configuration file, run:\n" >&2
	__warn "${cyan}redoflacs --new-config${normal}\n\n" >&2

	__warn "The above command will _NOT_ overwrite your\n" >&2
	__warn "current configuration file.\n\n" >&2

	__warn "Waiting 10 seconds before starting program...\n" >&2
	__warn "Ctrl+C (Control-C) to abort...\n" >&2
	__info "Starting in: "

	# 10 second countdown
	for count in {10..1} ; do
		printf "${red}%s${normal}%s" "$count" " "
		read -t1 # Sleep 1
	done
}

# Obtain the total number of directories to process, repesented
# as ${total_directories}
__total_directories () {
	# Find all the directories in which to process the FLAC files.
	for i in "${total_flacs_array[@]}" ; do
		if [[ "${processed_directory}" != "${i%/*}" ]] ; then
			flac_directories_array+=( "${i%/*}" )
		fi
		local processed_directory="${i%/*}"
	done

	# The total number of directories in a string variable
	total_directories="${#flac_directories_array[@]}"
}

# Clear old file descriptor (3) and create a new
# FIFO that's tied to file discriptor 3
__clear_tmp_fd () {
	# Close FIFO (if already open)
	exec 3<&- 3>&-

	# Open FIFO for reading and writing on file descriptor '3'
	exec 3<>"${tmp_fifo}"
}

# Clear old file descriptor (4) and create a new
# FIFO that's tied to file discriptor 4, removing
# the FIFO upon completion.  This is ONLY for auCDtect's
# STDOUT
__create_aucdtect_fd () {
	# Set up a temporary FIFO location.  The variable
	# is set up here, to prevent it from being called
	# upon script invocation when auCDtect isn't going
	# to be run
	tmp_aucdtect_fd="/tmp/redoflacs_aucdtect_fifo_$$"

	# Create the temporary FIFO
	mkfifo "${tmp_aucdtect_fd}"

	# Open FIFO for reading and writing on file descriptor '4'
	exec 4<>"${tmp_aucdtect_fd}"

	# Remove temporary FIFO and leave just the file
	# descriptor available
	rm -f "${tmp_aucdtect_fd}"
}

__msg_num_issues () {
	#---------------------------------------------------------------------------
	# Display the number of issues an operation may have by reading in the
	# number of ticks from the temporary issues_count file, returning the proper
	# message for use with the Summary Of Operations table
	#---------------------------------------------------------------------------
	read -r fail_count < "${issue_ticks}"   # Read in number of issue ticks

	if (( ${#fail_count} == 1 )) ; then
		printf "%s Issue\n" "${#fail_count}"
	else
		printf "%s Issues\n" "${#fail_count}"
	fi
}

# Obtain and process the positional parameters invoked
# with the script
__process_positional_parameters () {
	# If no arguments are made to the script show usage & short help
	if (( ${#} == 0 )) ; then
		__short_help
		exit 1
	fi

	# Add case where only one argument is specified
	if (( ${#} == 1 )) ; then
		case "${1}" in
			--version|-v)
				__print_version
				exit 0
			;;
			--help|-h)
				# Create the temporary file in which a man page will be
				# generated
				tmp_man_page="/tmp/redoflacs_man_$$.1"

				# Generate the man page to the above temporary location
				__long_help

				# Read the man page with 'man'
				man "${tmp_man_page}"

				# After reading, remove temporary file and exit
				rm -f "${tmp_man_page}"

				exit 0
			;;
			--new-config|-o)
				__new_config
				exit 0
			;;
			*)
				__usage >&2
				exit 1
			;;
		esac
	fi

	# Add case where two arguments are specified and the
	# arguments called are not to have anything after them
	if (( ${#} == 2 )) ; then
		case "${1}" in
			--jobs=[[:digit:]]*|-j[[:digit:]]*)
				__usage >&2
				exit 1
			;;
			--no-color|-n)
				__usage >&2
				exit 1
			;;
			--version|-v)
				__usage >&2
				exit 1
			;;
			--new-config|-o)
				__usage >&2
				exit 1
			;;
			--help|-h)
				__usage >&2
				exit 1
			;;
		esac
	fi

	# Separate the long and short style arguments into their
	# own arrays as well as capture the last non-arguements, to
	# prevent multiple directories being called
	for i in "${@}" ; do
		if [[ "${i}" == --* ]] ; then
			long_style_arguments_array+=( "${i}" )
		elif [[ "${i}" == -* ]] ; then
			short_style_arguments_array+=( "${i}" )
		else
			non_arguments_array+=( "${i}" )
		fi
	done

	# If there are 0 (zero) directories or more than 1, exit script
	if (( ${#non_arguments_array[@]} == 0 || ${#non_arguments_array[@]} > 1 )) ; then
		__usage >&2
		exit 1
	fi

	# If there were any long style arguments called, convert them
	# to short style in order for getopts to be able to process
	# them correctly (ignoring '--help', '--version', '--new-config' since
	# this is taken care of above).  Add invalid arguments to it's
	# own array
	if [[ -n "${long_style_arguments_array[@]}" ]] ; then
		for i in "${long_style_arguments_array[@]}" ; do
			case "${i}" in
				--compress)             converted_arguments_array+=( -c )   ;;
				--compress-notest)      converted_arguments_array+=( -C )   ;;
				--test)                 converted_arguments_array+=( -t )   ;;
				--md5check)             converted_arguments_array+=( -m )   ;;
				--aucdtect)             converted_arguments_array+=( -a )   ;;
				--aucdtect-spectrogram) converted_arguments_array+=( -A )   ;;
				--extract-artwork)      converted_arguments_array+=( -e )   ;;
				--prune)                converted_arguments_array+=( -p )   ;;
				--replaygain)           converted_arguments_array+=( -g )   ;;
				--replaygain-noforce)   converted_arguments_array+=( -G )   ;;
				--retag)                converted_arguments_array+=( -r )   ;;
				--all)                  converted_arguments_array+=( -l )   ;;
				--reallyall)            converted_arguments_array+=( -L )   ;;
				--no-color)             converted_arguments_array+=( -n )   ;;

				# Set number of jobs to run via the required
				# integer argument after '-j'
				--jobs=[[:digit:]]*)    jobs="${i##*=}"                     ;;

				--version)
					__usage >&2
					exit 1
				;;
				--help)
					__usage >&2
					exit 1
				;;
				--new-config)
					__usage >&2
					exit 1
				;;
				*)
					# Set invalid argument into array
					invalid_arguments_array+=( "${i}" )
				;;
			esac
		done
	fi

	# If there were any short style arguments called, go through
	# them, adding the valid arguments to the "converted_arguments"
	# array and adding invalid arguments to it's own array
	if [[ -n "${short_style_arguments_array[@]}" ]] ; then
		while getopts ":LlcCtgGaAmeprnj:hvo" arguments "${short_style_arguments_array[@]}" ; do
			case "${arguments}" in
				l) converted_arguments_array+=( -l ) ;;
				L) converted_arguments_array+=( -L ) ;;
				c) converted_arguments_array+=( -c ) ;;
				C) converted_arguments_array+=( -C ) ;;
				t) converted_arguments_array+=( -t ) ;;
				g) converted_arguments_array+=( -g ) ;;
				G) converted_arguments_array+=( -G ) ;;
				a) converted_arguments_array+=( -a ) ;;
				A) converted_arguments_array+=( -A ) ;;
				m) converted_arguments_array+=( -m ) ;;
				e) converted_arguments_array+=( -e ) ;;
				p) converted_arguments_array+=( -p ) ;;
				r) converted_arguments_array+=( -r ) ;;
				n) converted_arguments_array+=( -n ) ;;

				j)
					# Set number of jobs to run via the required
					# integer argument after '-j'
					jobs="${OPTARG}"

					# Do not allow jobs to be '0'
					if (( jobs == 0 )) ; then
						# Currently, this is just for '-j' so we can explicity
						# specify it
						parameter_errors_array+=( "${cyan}-j${normal} requires a non-zero integer after it (eg. ${cyan}-j11${normal})." )
					else
						converted_arguments_array+=( -j )
					fi
				;;

				h) converted_arguments_array+=( -h ) ;;
				v) converted_arguments_array+=( -v ) ;;
				o) converted_arguments_array+=( -o ) ;;

				:)
					# Currently, this is just for '-j' so we can explicity
					# specify it
					parameter_errors_array+=( "${cyan}-${OPTARG}${normal} requires a non-zero integer after it (eg. ${cyan}-${OPTARG}11${normal})." )
				;;
				?)
					# Set invalid argument from getopts into array using
					# ${OPTARG}
					invalid_arguments_array+=( "-${OPTARG}" )
				;;
			esac
		done
	fi

	# If there were invalid arguments called, display them and
	# exit script
	if [[ -n "${invalid_arguments_array[@]}" || -n "${parameter_errors_array[@]}" ]] ; then
		__usage >&2

		if [[ -n "${invalid_arguments_array[@]}" ]] ; then
			__error "\nInvalid options:" >&2

			for i in "${invalid_arguments_array[@]}" ; do
				printf " ${cyan}${i}${normal}" >&2
			done

			printf '\n' >&2
		fi

		if [[ -n "${parameter_errors_array[@]}" ]] ; then
			printf '\n' >&2

			for i in "${parameter_errors_array[@]}" ; do
				__error "${i}\n" >&2
			done
		fi

		exit 1
	fi

	# Run through all the converted arguments and set up the correct
	# values based on what the user called, thereby allowing the
	# script to process said values and execute the corresponding
	# functions
	for i in "${converted_arguments_array[@]}" ; do
		case "${i}" in
			-l) all="true"                                        ;;
			-L) reallyall="true"                                  ;;
			-c) compress_flac="true"    compress_test="true"      ;;
			-C) compress_flac="true"    skip_test="true"          ;;
			-t) test_flac="true"                                  ;;
			-g) replaygain_flac="true"  replaygain_force="true"   ;;
			-G) replaygain_flac="true"  replaygain_noforce="true" ;;
			-a) aucdtect_flac="true"    no_spectrogram="true"     ;;
			-A) aucdtect_flac="true"    create_spectrogram="true" ;;
			-m) md5_check_flac="true"                              ;;
			-e) extract_artwork="true"                            ;;
			-p) prune_flac="true"                                 ;;
			-r) retag_flac="true"                                 ;;
			-n) no_color="true"                                   ;;
			-j)
				# Do nothing, ${jobs} has already been stored
				# in previous getopts loop
				:
			;;
			-v) __usage >&2
				exit 1
			;;
			-h)
				__usage >&2
				exit 1
			;;
			-o)
				__usage >&2
				exit 1
			;;
			*)
				# Should not ever happen!
				__error "This is a BUG! Please report to:\n" >&2
				__error "${cyan}https://github.com/sirjaren/redoflacs/issues/new${normal}\n" >&2

				exit 1
			;;
		esac
	done

	# Put all the called arguments into an array
	called_arguments_array=( "${@}" )

	# Set the last argument as the directory and remove the
	# ending slash (if any) to prevent double slashes from
	# appearing because of BASH's globstar.
	#
	# This only appears if the directory chosen is the direct
	# parent directory to the FLAC files to be processed.
	#
	# BASH 4.2 allows negative indices (ie):
	#
	# directory="${called_arguments_array[-1]%/}"
	directory="${called_arguments_array[$(( ${#called_arguments_array[@]} - 1 ))]%/}"
}

# Check for missing programs vital to this script
__check_missing_programs () {
	# Check if each command can be found in $PATH
	rm_exists="$(type -P rm)"
	stty_exists="$(type -P stty)"
	stat_exists="$(type -P stat)"
	mkdir_exists="$(type -P mkdir)"
	mkfifo_exists="$(type -P mkfifo)"
	wc_exists="$(type -P wc)"
	metaflac_exists="$(type -P metaflac)"
	flac_exists="$(type -P flac)"

	# Go through and test if each command was found (by displaying its $PATH).  If
	# it's empty, add where you can find the package to an array to be displayed.
	if [[ -z "${rm_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}rm${normal}        ->  Part of ${cyan}coreutils${normal}" )
	fi

	if [[ -z "${stty_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}stty${normal}      ->  Part of ${cyan}coreutils${normal}" )
	fi

	if [[ -z "${stat_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}stat${normal}      ->  Part of ${cyan}coreutils${normal}" )
	fi

	if [[ -z "${mkdir_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}mkdir${normal}     ->  Part of ${cyan}coreutils${normal}" )
	fi

	if [[ -z "${mkfifo_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}mkfifo${normal}    ->  Part of ${cyan}coreutils${normal}" )
	fi

	if [[ -z "${wc_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}wc${normal}        ->  Part of ${cyan}coreutils${normal}" )
	fi

	if [[ -z "${metaflac_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}metaflac${normal}  ->  Part of ${cyan}flac${normal}" )
	fi

	if [[ -z "${flac_exists}" ]] ; then
		command_exists_array+=( "   Missing ${cyan}flac${normal}      ->  Part of ${cyan}flac${normal}" )
	fi

	# If all the programs above were found, continue with script.  Else
	# display warning and exit script, printing out which package has
	# the missing programs
	if [[ -n "${command_exists_array[@]}" ]] ; then
		__display_missing_commands_header

		# Iterate through array and print each value
		for i in "${command_exists_array[@]}" ; do
			__warn "${i}\n" >&2
		done

		exit 1
	fi

	# If auCDtect operation was specified, check
	# if auCDtect is found/installed
	if [[ "${aucdtect_flac}" == "true" ]] ; then
		aucdtect_exists="$(type -P auCDtect)"

		if [[ -z "${aucdtect_exists}" ]] ; then
			# Check alternate spelling
			aucdtect_exists="$(type -P aucdtect)"
		fi

		if [[ -z "${aucdtect_exists}" ]] ; then
			# auCDtect can't be found, exit
			__error "It appears ${cyan}auCDtect${normal} is not installed. Please verify you\n" >&2
			__error "have this program installed and can be found in ${cyan}\$PATH${normal}\n" >&2

			exit 1
		else
			# Check if auCDtect is executable and warn user if it isn't
			if [[ ! -x "${aucdtect_exists}" ]] ; then
				__error "It appears ${cyan}auCDtect${normal} is not executable.  In order to make\n" >&2
				__error "${cyan}auCDtect${normal} executable, run:\n" >&2
				__error "${cyan}chmod +x \"${aucdtect_exists}\"${normal}\n" >&2

				exit 1
			fi

			# Set up auCDtect command
			aucdtect_command="${aucdtect_exists}"
		fi
	fi

	# If "-A, --aucdtect-spectrogram" was called
	# make sure SoX is installed before starting
	if [[ "${create_spectrogram}" == "true" ]] ; then
		# Check if SoX is found/installed
		sox_exists="$(type -P sox)"

		if [[ -z "${sox_exists}" ]] ; then
			# SoX can't be found, exit
			__error "It appears ${cyan}SoX${normal} is not installed. Please verify you\n" >&2
			__error "have this program installed and can be found in ${cyan}\$PATH${normal}\n" >&2

			exit 1
		else
			# Set up SoX command
			sox_command="${sox_exists}"
		fi
	fi
}

# Check for any conflicting operations/arguments
__check_conflicting_operations () {
	# If "-l, --all" and "-L, --reallyall" are both called, warn and exit
	if [[ "${all}" == "true" && "${reallyall}" == "true" ]] ; then
		__error "Running both ${cyan}-l, --all${normal} and ${cyan}-L, --reallyall${normal} conflict!\n" >&2
		__error "Please choose one or the other.\n" >&2

		exit 1
	fi

	# If "-l, --all" or "-L, --reallyall" was called, check if arguments
	# were called that already will be performed by the above argument(s).
	# If any were called, display a warning and exit the script
	if [[ "${all}" == "true" || "${reallyall}" == "true" ]] ; then

		# Check for "-c, --compress".  If used add it to array
		if [[ "${compress_flac}" == "true" && "${skip_test}" == "false" ]] ; then
			argument_conflict_array+=( "-c, --compress" )
		# Check for "-C, --compress-notest".  If used add it to array
		elif [[ "${compress_flac}" == "true" && "${skip_test}" == "true" ]] ; then
			argument_conflict_array+=( "-C, --compress-notest" )
		fi

		# Check for "-t, --test".  If used add it to array
		if [[ "${test_flac}" == "true" ]] ; then
			argument_conflict_array+=( "-t, --test" )
		fi

		# Check for "-m, --md5check".  If used add it to array
		if [[ "${md5_check_flac}" == "true" ]] ; then
			argument_conflict_array+=( "-m, --md5check" )
		fi

		# Check for "-p, --prune".  If used add it to array
		if [[ "${prune_flac}" == "true" ]] ; then
			argument_conflict_array+=( "-p, --prune" )
		fi

		# Check for "-g, --replaygain".  If used add it to array
		if [[ "${replaygain_flac}" == "true" && "${replaygain_noforce}" != "true" ]] ; then
			argument_conflict_array+=( "-g, --replaygain" )
		# Check for "-G, --replaygain-noforce".  If used add it to array
		elif [[ "${replaygain_flac}" == "true" && "${replaygain_noforce}" == "true" ]] ; then
			argument_conflict_array+=( "-G, --replaygain-noforce" )
		fi

		# Check for "-r, --retag".  If used add it to array
		if [[ "${retag_flac}" == "true" ]] ; then
			argument_conflict_array+=( "-r, --retag" )
		fi

		# If "-L, --reallyall" was called, check for the various forms of calling
		# auCDtect.  If it was called, add it to array
		if [[ "${reallyall}" == "true" ]] ; then
			if [[ "${aucdtect_flac}" == "true" && "${create_spectrogram}" == "true" ]] ; then
				argument_conflict_array+=( "-A, --aucdtect-spectrogram" )
			elif [[ "${aucdtect_flac}" == "true" && "${create_spectrogram}" != "true" ]] ; then
				argument_conflict_array+=( "-a, --aucdtect" )
			fi
		fi

		# If the array is not empty, the user called some incompatible options with
		# "-l, --all" or "-L, --reallyall", so print which options were called that
		# are incompatible and exit script
		if [[ -n "${argument_conflict_array[@]}" ]] ; then
			# "-l, --all"
			if [[ "${all}" == "true" ]] ; then
				__error "The below options conflict with ${cyan}-l, --all${normal}:\n" >&2
			# "-L, --reallyall"
			elif [[ "${reallyall}" == "true" ]] ; then
				__error "The below options conflict with ${cyan}-L, --reallyall${normal}:\n" >&2
			fi

			# Iterate through array and print each value
			for i in "${argument_conflict_array[@]}" ; do
				__error "     ${cyan}${i}${normal}\n" >&2
			done

			__error "Please remove incompatible options.\n" >&2

			exit 1
		fi
	fi

	# If "-C, --compress-notest" and "-c, --compress" are both called, warn and exit
	if [[ "${skip_test}" == "true" && "${compress_test}" == "true" ]] ; then
		__error "Running both ${cyan}-c, --compress${normal} and ${cyan}-C, --compress-notest${normal} conflict!\n" >&2
		__error "Please choose one or the other.\n" >&2
		exit 1
	fi

	# If "-c, --compress" and "-t, --test" are both called, warn and exit
	if [[ "${compress_test}" == "true" && "${test_flac}" == "true" ]] ; then
		__error "Running both ${cyan}-c, --compress${normal} and ${cyan}-t, --test${normal} conflict!\n" >&2
		__error "Please choose one or the other.\n" >&2
		exit 1
	fi

	# If "-g, --replaygain" and "-G, --replaygain-noforce" are both called, warn and exit
	if [[ "${replaygain_force}" == "true" && "${replaygain_noforce}" == "true" ]] ; then
		__error "Running both ${cyan}-g, --replaygain${normal} and ${cyan}-G, --replaygain-noforce${normal} conflict!\n" >&2
		__error "Please choose one or the other.\n" >&2
		exit 1
	fi

	# If "-a, --aucdtect" and "-A, --aucdtect-spectrogram" are both called, warn and exit
	if [[ "${no_spectrogram}" == "true"  && "${create_spectrogram}" == "true" ]] ; then
		__error "Running both ${cyan}-a, --aucdtect${normal} and ${cyan}-A, --aucdtect-spectrogram${normal} conflict!\n" >&2
		__error "Please choose one or the other.\n" >&2
		exit 1
	fi

	# If "-l, --all" or "-L, --reallyall" was called,
	# enable the various arguments to allow script to
	# run them
	if [[ "${all}" == "true" ]] ; then
		compress_flac="true"
		md5_check_flac="true"
		prune_flac="true"
		replaygain_flac="true"
		retag_flac="true"
	elif [[ "${reallyall}" == "true" ]] ; then
		compress_flac="true"
		md5_check_flac="true"
		prune_flac="true"
		replaygain_flac="true"
		retag_flac="true"
		aucdtect_flac="true"
		# This is needed to let script know that we want auCDtect
		# to create a spectrogram (ie "-A, --aucdtect-spectrogram")
		create_spectrogram="true"
	fi
}

# Display the summary of operations chart
__summary () {
	# Begin printing the table
	#--
	# Title
	printf "\033[$(__row);2H${blue}%s${normal}\n" \
	"---------------------------------------------------"
	printf "                Summary Of Operations\n"
	printf "${normal} ${blue}-------------------------+-------------------------${normal}\n" \

	operation_msgs=(
		'Validate with auCDtect'
		'Check MD5 Signature'
		'Compress FLACs'
		'Test FLACs'
		'> Testing'
		'> Adding'
		'> Analyzing'
		'> Applying'
		'Extracting Artwork'
		'Prune METADATA Blocks'
	)

	for key in "${operation_msgs[@]}" ; do
		if [[ -n "${operation_summary[$key]}" ]] ; then
			if [[ "${key}" == '> '* ]] ; then
				if [[ "${key}" == '> Testing' ]] ; then
					printf "${yellow}%25s ${blue}|${normal}\n" 'Applying ReplayGain'
				elif [[ "${key}" == '> Analyzing' ]] ; then
					printf "${yellow}%25s ${blue}|${normal}\n" 'Retagging FLACs'
				fi

				printf "${magenta}%25s ${blue}|${normal}" "${key}"
			else
				printf "${yellow}%25s ${blue}|${normal}" "${key}"
			fi

			case "${operation_summary[$key]}" in
				'Operation Completed')
					printf " ${green}%s${normal}\n" "${operation_summary[$key]}"
				;;
				'Operation Interrupted')
					printf " ${cyan}%s${normal}\n" "${operation_summary[$key]}"
				;;
				'Operation Did Not Run')
					printf " ${magenta}%s${normal}\n" "${operation_summary[$key]}"
				;;
				*Issue*)
					printf " ${red}%s${normal}\n" "${operation_summary[$key]}"
				;;
			esac
		fi
	done

	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	# Remove temporary FIFO and leave just the file
	# descriptor available
	rm -f "${tmp_fifo}"

	# Remove temporary FIFO and leave just the file
	# descriptor available
	rm -f "${issue_ticks}"
}

# Function to run commands/operations that are by
# files _ONLY_
__run_parallel_files () {
	# Forces iteration to start at 0, in the event that
	# multiple operations are going to be run
	iteration=0

	# This is the parallel operation to run
	# specified by ${1} when calling this function
	parallel_operation="${1}"

	row_state=$(__row)

	# Start as many processes as determined by ${jobs}
	for i in "${total_flacs_array[@]:0:${jobs}}" ; do
		# This is the first set of jobs to run, so the placement of each file to
		# display is the current row the cursor is on plus the iteration (the
		# current file [number] being processed), which is zero-based
		placement=$((row_state + iteration))

		# Add one to the iteration to enforce we print one or more, not zero
		((iteration++))

		# Run the specified operation in the background
		"${parallel_operation}" &
	done

	# If the FLAC files to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if (( ${#total_flacs_array[@]} > jobs )) ; then

		# After each newline is read from FIFO, start a new process, storing the
		# value of the line into ${previous_operation_position}, which houses
		# the previous operation's position (relative to the position _after_
		# the current row)
		while read previous_operation_position ; do

			# Since this is _NOT_ the first set of jobs to run, the
			# placement of each file to display is the current row the
			# cursor is on plus the position of the last completed location
			# of the file, which allows us to dynamically place new jobs
			# where other jobs have completed
			placement=$((row_state + previous_operation_position))

			# If current number of FLACs to process is less than total FLACs
			# found, add another FLAC to process
			if (( iteration < (${#total_flacs_array[@]} - 1) )) ; then
				# Set the current filename ($i) to the current file in the array
				i="${total_flacs_array[${iteration}]}"

				# Add one to the iteration
				((iteration++))

				# Run the specified operation in the background
				"${parallel_operation}" &

			# Below is processed only if the current FLAC file is equal to the
			# last ${total_flacs_array[@]} index
			else
				# Set the current filename ($i) to the current file in the array
				i="${total_flacs_array[${iteration}]}"

				# Add one to the iteration
				((iteration++))

				# Run the specified operation in the background
				"${parallel_operation}" &

				# Break out of loop to prevent hanging FIFO
				break
			fi
		done <&3
	fi

	# Wait for children processes
	wait
}

# Function to run commands/operations that are by
# directory _ONLY_
__run_parallel_directories () {
	# Forces iteration to start at 0, in the event that
	# multiple operations are going to be run
	iteration=0

	# This is the parallel operation to run
	# specified by ${1} when calling this function
	parallel_operation="${1}"

	row_state=$(__row)

	# Start as many processes as determined by ${jobs}
	for i in "${flac_directories_array[@]:0:${jobs}}" ; do
		# This is the first set of jobs to run, so the placement of each file to
		# display is the current row the cursor is on plus the iteration (the
		# current file [number] being processed), which is zero-based
		placement=$((row_state + iteration))

		# Add one to the iteration to enforce we print one or more, not zero
		((iteration++))

		# Run the specified operation in the background
		"${parallel_operation}" &
	done

	# If the directories to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if (( ${#flac_directories_array[@]} > jobs )) ; then

		# After each newline is read from FIFO, start a new process, storing the
		# value of the line into ${previous_operation_position}, which houses
		# the previous operation's position (relative to the position _after_
		# the current row)
		while read previous_operation_position ; do

			# Since this is _NOT_ the first set of jobs to run, the
			# placement of each directory to display is the current row the
			# cursor is on plus the position of the last completed location
			# of the directory, which allows us to dynamically place new
			# jobs where other jobs have completed
			placement="$((row_state + previous_operation_position))"

			# If current number of directories to process is less than total
			# directories found, add another directory to process
			if (( iteration < (${#flac_directories_array[@]} - 1) )) ; then
				# Set the current directory ($i) to the current directory in the
				# array
				i="${flac_directories_array[${iteration}]}"

				# Add one to the iteration
				((iteration++))

				# Run the specified operation in the background
				"${parallel_operation}" &

			# Below is processed only if the current directory
			# is equal to the last ${flac_directories_array[@]} index
			else
				# Set the current directory ($i) to the current directory in the
				# array
				i="${flac_directories_array[${iteration}]}"

				# Add one to the iteration
				((iteration++))

				# Run the specified operation in the background
				"${parallel_operation}" &

				# Break out of loop to prevent hanging FIFO
				break
			fi
		done <&3
	fi

	# Wait for children processes
	wait
}
#== .: END VARIOUS COMMANDS :. =================================================


#-------------------------------------------------------------------------------
# .: OPERATIONS :.
#-------------------------------------------------------------------------------
# Test ReplayGain
__operation_test_replaygain () {
	trap '__kill_jobs "$(jobs -rp)"' EXIT

	# Print current FLAC being processed
	__print_sub_current_flac

	# Check if file is a FLAC file (capture output) via obtaining the sample
	# rate of the current file.  The sample rate captured will be tested against
	# later on.  Hide STDERR as we'll test the exit code instead
	current_sample_rate="$(metaflac --show-sample-rate "${i}" 2>/dev/null)"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then

		# Error with FLAC file, display failed/error
		__print_sub_progress_failed

		# Log FLAC failure
		printf "%s::::Not a real FLAC file\n" "${i}" \
			>> "${log_file}"

		# Add one to fail fd
		printf '.' >> "${issue_ticks}"
	else
		# File is OK, test if sample rate is above 48kHz and the version of
		# `metaflac' installed is greater than 1.2.1
		if (( current_sample_rate > 48000 )) ; then

			# Sample rate is greater than 48kHz, so check to make sure the
			# version of `metaflac' is greater than 1.2.1
			if (( metaflac_version < 3 )) ; then
				# Old version of `metaflac' installed, display skipped
				__print_sub_progress_issue

				# The `metaflac' version installed is NOT greater than 1.2.1 so
				# skip processing current FLAC file, logging why it was skipped
				printf "%s::::FLAC 1.3.0 or higher needed for sample rates >48kHz\n" "${i}" \
					>> "${log_file}"

				# Add one to fail fd
				printf '.' >> "${issue_ticks}"
			else
				# FLAC is ok, display ok
				__print_sub_progress_ok
			fi
		else
			# FLAC is ok, display ok
			__print_sub_progress_ok
		fi
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (3), to be used by the next job, terminated by a newline to
	# indicate job completed
	__store_position
}

# Process Replaygain (only add values if missing)
__operation_replaygain_noforce () {
	trap '__kill_jobs "$(jobs -rp)"' EXIT

	# Print current directory being processed
	__print_current_directory

	# ${i} is the parent directory to the FLAC files
	# ${j} is a FLAC file -> under ${i}
	for j in "${i}"/*${flac_extension} ; do
		# Grab all of the ReplayGain tags
		mapfile -n0 -t replaygain_array < \
		<(
			metaflac \
				--show-tag=REPLAYGAIN_REFERENCE_LOUDNESS \
				--show-tag=REPLAYGAIN_TRACK_GAIN \
				--show-tag=REPLAYGAIN_TRACK_PEAK \
				--show-tag=REPLAYGAIN_ALBUM_GAIN \
				--show-tag=REPLAYGAIN_ALBUM_PEAK \
				"${j}"
		)

		# Strip out the tag fields (eg. REPLAYGAIN_TRACK_GAIN=)
		replaygain_array="${replaygain_array[@]#*=}"

		# Test if any ReplayGain values are empty (if there are less
		# than 5 values in the replaygain array)
		if (( ${#replaygain_array[@]} < 5 )) ; then
			# At _least_ one tag is missing from current file, so
			# apply new ReplayGain values
			#
			# Add ReplayGain to FLAC files under directory.  Metaflac
			# automatically removes old ReplayGain values (if any) before
			# proceeding
			metaflac --add-replay-gain "${i}"/*${flac_extension} >/dev/null 2>&1

			# Exit code 130 is SIGINT so only check for exit code '1'
			if (( ${?} == 1 )) ; then

				# Failed applyig replaygain values, display failed/error
				__print_sub_progress_failed

				# Log ReplayGain error
				printf "%s::::Corrupt FLAC(s) or differing sample rates (album ReplayGain)\n" "${i}" \
					>> "${log_file}"

				# Add one to fail fd
				printf '.' >> "${issue_ticks}"

				# Placeholder variable tested after this loop
				# if the loop completes with 'break'
				broke_out_of_loop="true"

				# Break out of loop and on to next directory
				break
			else
				# FLAC is ok, display ok
				__print_sub_progress_ok
			fi
		else
			# FLAC is ok, display ok
			__print_sub_progress_ok
		fi
	done

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (3), to be used by the next job, terminated by a newline to
	# indicate job completed
	__store_position
}

# Process ReplayGain (force new values)
__operation_replaygain_force () {
	trap '__kill_jobs "$(jobs -rp)"' EXIT

	# Print current directory being processed
	__print_current_directory

	# Add ReplayGain to FLAC files under directory
	metaflac --add-replay-gain "${i}"/*${flac_extension} >/dev/null 2>&1

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then

		# Error with FLAC file, display failed/error
		__print_sub_progress_failed

		# Log ReplayGain error
		printf "%s::::Corrupt FLAC(s) or differing sample rates (album ReplayGain)\n" "${i}" \
			>> "${log_file}"

		# Add one to fail fd
		printf '.' >> "${issue_ticks}"
	else
		# FLAC is ok, display ok
		__print_sub_progress_ok
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (3), to be used by the next job, terminated by a newline to
	# indicate job completed
	__store_position
}

# Compress FLAC files
__operation_compress () {
	trap '__kill_jobs "$(jobs -rp)"' EXIT

	# Test for COMPRESSION level in FLAC file. Hide error output since
	# we'll be verifying the FLAC file later
	COMPRESSION="$(metaflac --show-tag=COMPRESSION "${i}" 2> /dev/null)"
	COMPRESSION="${COMPRESSION#*=}"

	if (( COMPRESSION != compression_level )) ; then
		# Print current FLAC being processed
		__print_current_flac

		# This is a variable to determine which type of process is used to get
		# the current percentage during the operation
		obtain_percentage="__obtain_compress_percentage"

		# Compress FLAC file
		# Display the current file with progress completed thus far via a
		# percentage and progress bar
		flac --no-error-on-compression-fail -f -${compression_level} -V "${i}" 2> >(while read -r -d% percent_complete ; do
			__print_progress
		done) >/dev/null


		# Exit code 130 is SIGINT so only check for exit code '1'
		if (( ${?} == 1 )) ; then

			# Error with FLAC file, display failed/error
			__print_progress_failed

			# Log FLAC failure
			printf "%s::::Failed verification\n" "${i}" \
				>> "${log_file}"

			# Add one to fail fd
			printf '.' >> "${issue_ticks}"
		else
			metaflac \
				--remove-tag=COMPRESSION \
				--set-tag=COMPRESSION=${compression_level} "${i}"

			# FLAC is ok, display ok
			__print_progress_ok
		fi

	# If already at compression_level, test the FLAC file instead
	# or skip the file if '-C, --compress-notest' was specified
	else
		if [[ "${skip_test}" != "true" ]] ; then
			# Print current FLAC being processed
			__print_current_flac

			# This is a variable to determine which type of process is used to
			# get the current percentage during the operation
			obtain_percentage="__obtain_test_percentage"

			# Test FLAC file
			# Display the current file with progress completed thus far via a
			# percentage and progress bar
			flac -t "${i}" 2> >(while read -r -d% percent_complete ; do
				__print_progress
			done) >/dev/null

			# Exit code 130 is SIGINT so only check for exit code '1'
			if (( ${?} == 1 )) ; then

				# Error with FLAC file, display failed/error
				__print_progress_failed

				# Log FLAC failure
				printf "%s::::Failed verification\n" "${i}" \
					>> "${log_file}"

				# Add one to fail fd
				printf '.' >> "${issue_ticks}"
			else
				# FLAC is ok, display ok
				__print_progress_ok
			fi
		else
			# Print skipped FLAC
			__print_skip_flac
		fi
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (3), to be used by the next job, terminated by a newline to
	# indicate job completed
	__store_position
}

# Test FLAC files
__operation_test () {
	trap '__kill_jobs "$(jobs -rp)"' EXIT

	# Print current FLAC being processed
	__print_current_flac

	# This is a variable to determine which type of process is used to get the
	# current percentage during the operation
	obtain_percentage="__obtain_test_percentage"

	# Test FLAC file
	# Display the current file with progress completed thus far via a
	# percentage and progress bar
	flac -t "${i}" 2> >(while read -r -d% percent_complete ; do
		__print_progress
	done) >/dev/null

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then

		# Error with FLAC file, display failed/error
		__print_progress_failed

		# Log FLAC failure
		printf "%s::::Failed testing\n" "${i}" >> "${log_file}"

		# Add one to fail fd
		printf '.' >> "${issue_ticks}"
	else
		# FLAC is ok, display ok
		__print_progress_ok
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (3), to be used by the next job, terminated by a newline to
	# indicate job completed
	__store_position
}

# Test FLAC validity with auCDtect
__operation_aucdtect () {
	trap '__kill_jobs "$(jobs -rp)"' EXIT

	# Print current FLAC being processed
	__print_current_flac

	# Get the bit depth and MASTERING tag of a FLAC file.  Also used to check if
	# FLAC file is real.  Hide STDERR output.  The array indices are:
	#   bits_mastering[0] = bit depth (eg, 16)
	#   bits_mastering[1] = MASTERING tag value (eg, MASTERING=Lossy)
	bits_mastering=( $(metaflac --show-bps --show-tag=MASTERING "${i}" 2>/dev/null) )

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then

		# Error with FLAC file, display failed/error
		__print_progress_failed

		# Log FLAC failure
		printf "%s::::Not a real FLAC file\n" "${i}" \
			>> "${log_file}"

		# Add one to fail fd
		printf '.' >> "${issue_ticks}"

	# Skip the FLAC file if it has a bit depth greater
	# than 16 since auCDtect doesn't support audio
	# files with a higher resolution than a CD.
	elif (( ${bits_mastering[0]} > 16 )) ; then

		# Print skipped FLAC
		__print_skip_flac

		# Log skipped FLAC file
		printf "%s::::auCDtect does not support a bit depth >16\n" "${i}" \
			>> "${log_file}"

		# Add one to fail fd
		printf '.' >> "${issue_ticks}"

	# Skip the FLAC file if it already has the 'Lossy' value set for the
	# MASTERING tag.  This is only done if the value of 'skip_lossy' is 'true',
	# set in the configuration file.  We make sure to remove 'MASTERING=' before
	# testing the tag field
	elif [[ "${bits_mastering[1]#*=}" == "Lossy" ]] ; then

		# Print skipped FLAC
		__print_skip_flac

		# Log skipped FLAC file
		printf "%s::::MASTERING=Lossy value found; skipping ('skip_lossy' configuration)\n" "${i}" \
			>> "${log_file}"

		# Add one to fail fd
		printf '.' >> "${issue_ticks}"

	# FLAC checks out, continue processing
	else
		# Print current FLAC being processed
		__print_decoding_flac

		# The WAV file to be created from current FLAC file
		decoded_wav="${i%${flac_extension}}_redoflacs_"$$".wav"

		# This is a variable to determine which type of process is used to get
		# the current percentage during the operation
		obtain_percentage="__obtain_decode_percentage"

		# Decompress FLAC to WAV so auCDtect can read the audio file
		# Display the current file with progress completed thus far via a
		# percentage and progress bar
		flac -d "${i}" -o "${decoded_wav}" 2> >(while read -r -d% percent_complete ; do
			__print_decoding_progress
		done) >/dev/null

		# Exit code 130 is SIGINT so only check for exit code '1'.  If FLAC file
		# failed decoding to WAV, log error, otherwise continue processing
		if (( ${?} == 1 )) ; then

			# Error with FLAC file, display failed/error
			__print_decoding_fail

			# Log FLAC failure
			printf "%s::::Failed decoding to WAV\n" "${i}" \
				>> "${log_file}"

			# Add one to fail fd
			printf '.' >> "${issue_ticks}"

		else
			# Decoded FLAC is ok, display ok
			__print_decoding_ok

			# This is a variable to determine which type of process is used to get
			# the current percentage during the operation
			obtain_percentage="__obtain_aucdtect_percentage"

			# Print current FLAC being processed, auCDtect: fast
			__print_current_aucdtect_fast

			# 'export MALLOC_CHECK_' allows the dynamic linked version of
			# `auCDTECT' to run without throwing errors
			export MALLOC_CHECK_="0"

			# The actual auCDtect command with lowest accuracy setting (for
			# speed).  STDOUT is sent to file descriptor '4'
			"${aucdtect_command}" -m40 "${decoded_wav}" 2> >(while read -r -d% percent_complete ; do
				# Display the current file with progress completed thus far via
				# a percentage and progress bar
				__print_progress_aucdtect_fast
			done) >&4

			# Exit code 130 is SIGINT so only check for exit code '1'
			if (( ${?} == 1 )) ; then

				# Error with FLAC file, display failed/error
				__print_aucdtect_fast_fail

				# Log FLAC failure
				printf "%s::::Failed analyzing decoded FLAC\n" "${i}" \
					>> "${log_file}"

				# Add one to fail fd
				printf '.' >> "${issue_ticks}"

			else
				# Grab the conclusion of auCDtect's command
				# Below options prevents hanging FIFO by only reading
				# what is necessary:
				#    -s7:  Discard first seven lines from auCDtect's output
				#    -n2:  Only grab 2 lines from auCDtect's output
				#     -t:  Remove trailing newlines from auCDtect's output
				#    -u4:  Obtain auCDtect's output from file descriptor '4'
				#  array:  Store captured output into 'aucdtect_check_array'
				mapfile -s7 -n2 -t -u4 aucdtect_check_array

				# If there is an issue with the processed FLAC file, run
				# auCDtect once again with highest setting
				if [[ "${aucdtect_check_array[0]}" != "This track looks like CDDA with probability 100%" ]] ; then

					# Print current FLAC being processed, auCDtect: slow
					__print_current_aucdtect_slow

					# The actual auCDtect command with highest accuracy setting.
					# STDOUT is sent to file descriptor '4'
					"${aucdtect_command}" -m0 "${decoded_wav}" 2> >(while read -r -d% percent_complete ; do
						# Display the current file with progress completed thus far via
						# a percentage and progress bar
						__print_progress_aucdtect_slow
					done) >&4

					# Exit code 130 is SIGINT so only check for exit code '1'
					if (( ${?} == 1 )) ; then

						# Error with FLAC file, display failed/error
						__print_aucdtect_slow_fail

						# Log FLAC failure
						printf "%s::::Failed analyzing decoded FLAC\n" "${i}" \
							>> "${log_file}"

						# Add one to fail fd
						printf '.' >> "${issue_ticks}"

					else
						# Grab the conclusion of auCDtect's command
						# Below options prevents hanging FIFO by only reading
						# what is necessary:
						#    -s7:  Discard first seven lines from auCDtect's output
						#    -n2:  Only grab 2 lines from auCDtect's output
						#     -t:  Remove trailing newlines from auCDtect's output
						#    -u4:  Obtain auCDtect's output from file descriptor '4'
						#  array:  Store captured output into 'aucdtect_check_array'
						mapfile -s7 -n2 -t -u4 aucdtect_check_array

						# There is an issue with the processed FLAC file
						if [[ "${aucdtect_check_array[0]}" != "This track looks like CDDA with probability 100%" ]] ; then

							# If user specified '-A, --aucdtect-spectrogram', then
							# create a spectrogram with SoX and change logging accordingly
							if [[ "${create_spectrogram}" == "true" ]] ; then

								# Check whether to place spectrogram images in user-defined location
								if [[ -z "${spectrogram_location}" ]] ; then
									# Obtain basename of current FLAC file
									flac_file="${i##*/}"

									# Obtain dirname of current FLAC file
									spectrogram_dirname="${i%/*}"

									# Create the spectrogram with '.png' as the
									# file extension, placed in the same
									# directory as the current FLAC file
									spectrogram_picture="${spectrogram_dirname}/[${iteration}] ${flac_file%${flac_extension}}.png"
								else
									# Obtain basename of current FLAC file
									flac_file="${i##*/}"

									# Create the spectrogram with '.png' as the
									# file extension, placed in the user-defined
									# location
									spectrogram_picture="${spectrogram_location}/[${iteration}] ${flac_file%${flac_extension}}.png"
								fi

								# Print current FLAC being processed
								__print_current_spectrogram

								# This is a variable to determine which type of
								# process is used to get the current percentage
								# during the operation
								obtain_percentage="__obtain_spectrogram_percentage"

								# SoX command to create the spectrogram and
								# place it in spectrogram_picture.  Use the
								# following arguments to create the highest
								# resolution spectrograms:
								#   -x 5000
								#   -y 1025
								"${sox_command}" "${decoded_wav}" \
									-S \
									-n spectrogram \
									-c '' \
									-t "${i}" \
									-p 1 \
									-z 90 \
									-Z 0 \
									-q 249 \
									-w Hann \
									-x 1800 \
									-y 513 \
									-o "${spectrogram_picture}" 2> >(
										while read -r -d% percent_complete ; do
											# Display the current file with
											# progress completed thus far via a
											# percentage and progress bar
											__print_progress_spectrogram
										done
									) >/dev/null

								# Error with FLAC file, display failed/error
								__print_spectrogram_issue

								# Log auCDtect report
								printf "%s::::%s (%s)\n" "$i" "${aucdtect_check_array[0]}" "${spectrogram_picture}" \
									>> "${log_file}"

								# Add one to fail fd
								printf '.' >> "${issue_ticks}"

							else
								# Error with FLAC file, display failed/error
								__print_aucdtect_issue

								# Log auCDtect report
								printf "%s::::%s\n" "$i" "${aucdtect_check_array[0]}" \
									>> "${log_file}"

								# Add one to fail fd
								printf '.' >> "${issue_ticks}"
							fi
						else
							# FLAC is ok, display ok
							__print_aucdtect_slow_ok
						fi
					fi
				else
					# FLAC is ok, display ok
					__print_aucdtect_fast_ok
				fi

				# Remove temporary WAV file
				rm "${decoded_wav}"
			fi
		fi
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (3), to be used by the next job, terminated by a newline to
	# indicate job completed
	__store_position
}

# Check MD5 in each FLAC file
__operation_md5check () {
	trap '__kill_jobs "$(jobs -rp)"' EXIT

	# Print current FLAC being processed
	__print_current_flac

	# Get the MD5 checksum (hide stderr output).  Also
	# used to check if FLAC file is real
	md5_sum="$(metaflac --show-md5sum "${i}" 2> /dev/null)"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then

		# Error with FLAC file, display failed/error
		__print_progress_failed

		# Log FLAC failure
		printf "%s::::Not a real FLAC file\n" "${i}" \
			>> "${log_file}"

		# Add one to fail fd
		printf '.' >> "${issue_ticks}"

	# FLAC file is real, check for unset MD5 checksum.  We cannot use an
	# arithmetic expression as any amount of 0's will equal the expression
	# below
	elif [[ "${md5_sum}" == "00000000000000000000000000000000" ]] ; then

		# Error with FLAC file, display failed/error
		__print_progress_failed

		# Log FLAC failure
		printf "%s::::Unset MD5 signature (00000000000000000000000000000000)\n" "${i}" \
			>> "${log_file}"

		# Add one to fail fd
		printf '.' >> "${issue_ticks}"
	else
		# FLAC is ok, display ok
		__print_progress_ok
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (3), to be used by the next job, terminated by a newline to
	# indicate job completed
	__store_position
}

# Analyze FLAC tags
__operation_analyze_tags () {
	trap '__kill_jobs "$(jobs -rp)"' EXIT

	# Print current FLAC being processed
	__print_sub_current_flac

	# Check if file is a FLAC file (variable hides output)
	check_flac="$(metaflac --show-md5sum "${i}" 2>&1)"

	# If above command return anything other than '0', log output
	if (( ${?} != 0 )) ; then

		# Error with FLAC file, display failed/error
		__print_sub_progress_failed

		# Log FLAC failure
		printf "%s::::Not a real FLAC file\n" "${i}" \
			>> "${log_file}"

		# Add one to fail fd
		printf '.' >> "${issue_ticks}"
	else
		# Iterate through each tag field and check if tag is missing
		for j in "${tags[@]}" ; do
			# Check if ALBUMARTIST is in tag array and apply operations on
			# the tag field if it exists
			if [[ "${j}" == "ALBUMARTIST" ]] ; then
				# ALBUMARTIST exists in tag array so allow script to check the
				# various naming conventions within the FLAC files (ie,
				# 'ALBUM ARTIST' or 'ALBUM_ARTIST')

				# "ALBUMARTIST" or "ALBUM ARTIST" or "ALBUM_ARTIST", case-insensitive
				if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${i}")" ]] ; then
					show_tag_list+=( "--show-tag=ALBUMARTIST" )

				elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${i}")" ]] ; then
					show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

				elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${i}")" ]] ; then
					show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
				fi
			else
				# Build up metaflac '--show-tag=' list
				show_tag_list+=( "--show-tag=${j}" )
			fi
		done

		# Load up all the tag values for current file
		mapfile -n0 -t metaflac_tag_array < \
		<(
			metaflac \
				"${show_tag_list[@]}" \
				"${i}"
		)

		# Take above tag values and create an associative
		# array using TAG_FIELD=TAG_VALUE as the key/value pair
		#
		# Specifically declare an empty associative array
		declare -A temp_tag_array

		# Run through the tag array from above and store
		# the values into a temporary tag array
		for tag_field_value in "${metaflac_tag_array[@]}" ; do
			# This is the tag field (eg. TITLE)
			tag_field="${tag_field_value%%=*}"

			# Enforce the tag field to be uppercase
			# ${tag_field_value} below is the tag value
			temp_tag_array+=( ["${tag_field^^}"]="${tag_field_value#*=}" )
		done

		# Run through the tags array and test each tag value from
		# ${temp_tag_array} with the currently processed tag in ${tag[@]}.  For
		# each match found, test if the tag value is null, reporting any missing
		# tags. Then remove the tag field (index) from the ${temp_tag_array}, so
		# the next iteration is faster and we can check for missing tags (tag
		# fields)
		for j in "${tags[@]}" ; do

			# If the total # of indices in the temporary tag array is above
			# 0, continue testing, else store missing tag (${j}) into the
			# missing tags array
			if (( ${#temp_tag_array[@]} > 0 )) ; then

				# Compare each tag field from the temporary array to ${j},
				# checking if they are equal and if so, check for missing
				# tag values
				for temp_tag_field in "${!temp_tag_array[@]}" ; do
					# Both tag fields are equal
					if [[ "${j}" == "${temp_tag_field}" ]] ; then
						# Check if tag value is null, logging missing tags if so
						if [[ -z "${temp_tag_array[${temp_tag_field}]}" ]] ; then
							missing_tags+="${j}, "
						fi

						# Remove the current tag field from the temporary tag
						# array since it's been matched already
						unset -v temp_tag_array[${temp_tag_field}]

						# This variable let's the script know that the current
						# tag, ${j} has been matched up with a tag field in
						# ${temp_tag_array[@]}
						tag_match="true"

						# Break out of loop since the tag fields have been
						# matched, continuing on to the next iteration of ${j}
						break
					fi
				done

				# If there wasn't a tag field in the temporary tag array
				# ( eg. ${temp_tag_array[@]} ) that matched ${j}, the FLAC file
				# must have a missing tag, so log it by throwing the missing tag
				# into the missing tags array
				if [[ "${tag_match}" != "true" ]] ; then
					missing_tags+="${j}, "
				fi

				# Reset the value of tag match (if any) for the next iteration
				# of ${j}
				unset -v tag_match

			# The total # of indices in the temporary tag array is 0, so
			# whatever is left in ${tags[@]} represented by ${j} is logged
			# as missing
			else
				missing_tags+="${j}, "
			fi
		done

		# If missing_tags_array is not empty, there are missing
		# tags in the current file so log output
		if [[ -n "${missing_tags}" ]] ; then
			# FLAC file has missing tags, display failed/error
			__print_sub_progress_failed

			# Log the missing tags
			printf "%s::::Missing tags: ${missing_tags%, }\n" "${i}" \
				>> "${log_file}"

			# Add one to fail fd
			printf '.' >> "${issue_ticks}"
		else
			# FLAC is ok, display ok
			__print_sub_progress_ok
		fi
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (3), to be used by the next job, terminated by a newline to
	# indicate job completed
	__store_position
}

# Analyze FLAC tags (not logging missing COVERART tag)
__operation_analyze_tags_dont_log_coverart () {
	trap '__kill_jobs "$(jobs -rp)"' EXIT

	# Print current FLAC being processed
	__print_sub_current_flac

	# Check if file is a FLAC file (variable hides output)
	check_flac="$(metaflac --show-md5sum "${i}" 2>&1)"

	# If above command return anything other than '0', log output
	if (( ${?} != 0 )) ; then

		# Error with FLAC file, display failed/error
		__print_sub_progress_failed

		# Log FLAC failure
		printf "%s::::Not a real FLAC file\n" "${i}" \
			>> "${log_file}"

		# Add one to fail fd
		printf '.' >> "${issue_ticks}"
	else
		# Album artwork is to be kept so preserve COVERART by adding
		# it to the tag array (temporary)
		tags+=( COVERART )

		# Iterate through each tag field and check if tag is missing (except
		# for the COVERART tag)
		for j in "${tags[@]}" ; do
			# Check if ALBUMARTIST is in tag array and apply operations on
			# the tag field if it exists
			if [[ "${j}" == "ALBUMARTIST" ]] ; then
				# ALBUMARTIST exists in tag array so allow script to check the
				# various naming conventions within the FLAC files (ie,
				# 'ALBUM ARTIST' or 'ALBUM_ARTIST')

				# "ALBUMARTIST" or "ALBUM ARTIST" or "ALBUM_ARTIST", case-insensitive
				if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${i}")" ]] ; then
					show_tag_list+=( "--show-tag=ALBUMARTIST" )

				elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${i}")" ]] ; then
					show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

				elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${i}")" ]] ; then
					show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
				fi
			else
				# Build up metaflac '--show-tag=' list
				show_tag_list+=( "--show-tag=${j}" )
			fi

			# Check if COVERART exists and is not null
			if [[ "${j}" == "COVERART" ]] ; then
				# Obtain COVERART value
				coverart_value="$(metaflac --show-tag=COVERART "${i}")"

				# If COVERART value is not null, so log it exists and that
				# COVERART tag is depcrated
				if [[ -n "${coverart_value#*=}" ]] ; then

					# Error with FLAC file, display failed/error
					__print_sub_progress_failed

					printf "%s::::COVERART tag is deprecated, consider using METADATA_BLOCK_PICTURE\n" "${i}" \
						>> "${log_file}"

					# Add one to fail fd
					printf '.' >> "${issue_ticks}"
				fi
			fi
		done

		# Load up all the tag values for current file
		mapfile -n0 -t metaflac_tag_array < \
		<(
			metaflac \
				"${show_tag_list[@]}" \
				"${i}"
		)

		# Take above tag values and create an associative
		# array using TAG_FIELD=TAG_VALUE as the key/value pair
		#
		# Specifically declare an empty associative array
		declare -A temp_tag_array

		# Run through the tag array from above and store
		# the values into a temporary tag array
		for tag_field_value in "${metaflac_tag_array[@]}" ; do
			# This is the tag field (eg. TITLE)
			tag_field="${tag_field_value%%=*}"

			# Enforce the tag field to be uppercase
			# ${tag_field_value} below is the tag value
			temp_tag_array+=( ["${tag_field^^}"]="${tag_field_value#*=}" )
		done

		# Run through the tags array and test each tag value from
		# ${temp_tag_array} with the currently processed tag in ${tag[@]}.  For
		# each match found, test if the tag value is null, reporting any missing
		# tags. Then remove the tag field (index) from the ${temp_tag_array}, so
		# the next iteration is faster and we can check for missing tags (tag
		# fields)
		for j in "${tags[@]}" ; do

			# If the total # of indices in the temporary tag array is above
			# 0, continue testing, else store missing tag (${j}) into the
			# missing tags array
			if (( ${#temp_tag_array[@]} > 0 )) ; then

				# Compare each tag field from the temporary array to ${j},
				# checking if they are equal and if so, check for missing
				# tag values.
				# Skip output of COVERART tag as this is a temporary
				# addition to the tag array (for processing legacy artwork)
				for temp_tag_field in "${!temp_tag_array[@]}" ; do
					# Both tag fields are equal
					if [[ "${j}" == "${temp_tag_field}" && "${j}" != "COVERART" ]] ; then
						# Check if tag value is null, logging missing tags if so
						if [[ -z "${temp_tag_array[${temp_tag_field}]}" ]] ; then
							missing_tags+="${j}, "
						fi

						# Remove the current tag field from the temporary tag
						# array since it's been matched already
						unset -v temp_tag_array[${temp_tag_field}]

						# This variable let's the script know that the current
						# tag, ${j} has been matched up with a tag field in
						# ${temp_tag_array[@]}
						tag_match="true"

						# Break out of loop since the tag fields have been
						# matched, continuing on to the next iteration of ${j}
						break
					fi
				done

				# If there wasn't a tag field in the temporary tag array
				# ( eg. ${temp_tag_array[@]} ) that matched ${j}, the FLAC file
				# must have a missing tag, so log it by throwing the missing tag
				# into the missing tags array.  Also skip logging of COVERART tag
				if [[ "${tag_match}" != "true" && "${j}" != "COVERART" ]] ; then
					missing_tags+="${j}, "
				fi

				# Reset the value of tag match (if any) for the next iteration
				# of ${j}
				unset -v tag_match

			# The total # of indices in the temporary tag array is 0, so
			# whatever is left in ${tags[@]} represented by ${j} is logged
			# as missing.  Also skip logging of COVERART tag
			elif [[ "${j}" != "COVERART" ]] ; then
				missing_tags+="${j}, "
			fi
		done

		# If missing_tags_array is not empty, there are missing
		# tags in the current file so log output
		if [[ -n "${missing_tags}" ]] ; then
			# Error with FLAC file, display failed/error
			__print_sub_progress_failed

			# Log the missing tags
			printf "%s::::Missing tags: ${missing_tags%, }\n" "${i}" \
				>> "${log_file}"

			# Add one to fail fd
			printf '.' >> "${issue_ticks}"
		else
			# FLAC is ok, display ok
			__print_sub_progress_ok
		fi
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (3), to be used by the next job, terminated by a newline to
	# indicate job completed
	__store_position
}

# Re-tag FLAC files
__operation_set_tags () {
	trap '__kill_jobs "$(jobs -rp)"' EXIT

	# Print current FLAC being processed
	__print_sub_current_flac

	# Remove and set new tags
	#
	# Iterate through the tag array and set a variable for each tag
	for j in "${tags[@]}" ; do
		# Check if ALBUMARTIST is in tag array and apply operations on
		# the tag field if it exists
		if [[ "${j}" == "ALBUMARTIST" ]] ; then
			# ALBUMARTIST exists in tag array so allow script to check the
			# various naming conventions within the FLAC files (ie,
			# 'ALBUM ARTIST' or 'ALBUM_ARTIST')

			# "ALBUMARTIST"
			if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${i}")" ]] ; then
				show_tag_list+=( "--show-tag=ALBUMARTIST" )

			elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${i}")" ]] ; then
				show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

			elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${i}")" ]] ; then
				show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
			fi
		else
			# Build up metaflac '--show-tag=' list
			show_tag_list+=( "--show-tag=${j}" )
		fi
	done

	# Load up all the tag values for current file
	mapfile -n0 -t metaflac_tag_array < \
	<(
		metaflac \
			"${show_tag_list[@]}" \
			"${i}"
	)

	# Create a copy of ${metaflac_tag_array[@]} with just the tag fields
	# and force the tag fields to be uppercase
	tag_field_array=( "${metaflac_tag_array[@]%%=*}" )
	tag_field_array=( "${tag_field_array[@]^^}" )

	# Create a copy of ${metaflac_tag_array[@]} with just the tag values
	tag_values_array=( "${metaflac_tag_array[@]#*=}" )

	# Re-create ${metaflac_tag_array[@]}, this time enforcing the tag
	# fields are uppercase
	#
	# Clear ${metaflac_tag_array[@]}
	metaflac_tag_array=()

	# If the user specified 'true' to the 'prepend_zero' option in the
	# configuration file, enforce the TRACKNUMBER and TRACKTOTAL tags to have a
	# '0' prepended before singular numbers
	if [[ "${prepend_zero}" == "true" ]] ; then

		# Prepend a '0' for TRACKNUMBER and TRACKTOTAL
		for j in "${!tag_field_array[@]}" ; do

			# Add in the tag field and value as an index
			if [[ "${tag_field_array[${j}]}" == "TRACKNUMBER" ||
				  "${tag_field_array[${j}]}" == "TRACKTOTAL" ]] ; then

				# Format tag value with '0' prepended for single values.  We
				# force arithmetic expansion and explicitly specify base 10
				# in order to prevent octal errors if the value is either '08'
				# or '09'
				prepend_tag_value="$( printf %02d $(( 10#${tag_values_array[${j}]} )) )"

				metaflac_tag_array+=(
					# Tag field (eg. TRACKNUMBER) = Tag value (eg. 03)
					"${tag_field_array[${j}]}=${prepend_tag_value}"
				)
			else
				metaflac_tag_array+=(
					# Tag field (eg. ARTIST) = Tag value (eg. Kamelot)
					"${tag_field_array[${j}]}=${tag_values_array[${j}]}"
				)
			fi
		done
	else
		# ${prepend_zero} is not set as 'true', add each tag field and tag value
		# into ${metaflac_tag_array[@]}
		for j in "${!tag_field_array[@]}" ; do

			# Add in the tag field and value as an index
			metaflac_tag_array+=(
				# Tag field (eg. ARTIST) = Tag value (eg. Kamelot)
				"${tag_field_array[${j}]}=${tag_values_array[${j}]}"
			)
		done
	fi

	# Add the saved tags back, by printing each tag field and value
	# on a separate line to STDOUT.  This will be read in by metaflac.
	# Use process substitution to allow this to finish if user
	# invokes SIGINT
	metaflac --remove-all-tags --import-tags-from=- "${i}" < \
	<(
		# This prints each tag key and value pair
		# (eg. ARTIST=Kamelot)
		printf "%s\n" "${metaflac_tag_array[@]}"
	)

	# Display ok
	__print_sub_progress_ok

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (3), to be used by the next job, terminated by a newline to
	# indicate job completed
	__store_position
}

# Extract artwork from FLAC files
__operation_extract_artwork () {
	trap '__kill_jobs "$(jobs -rp)"' EXIT

	# Print current FLAC with artwork to be extracted
	__print_current_half

	# Check if file is a FLAC file (hide output)
	metaflac --show-md5sum "${i}" >/dev/null 2>&1

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then
		# Error with FLAC file, display failed/error
		__print_progress_failed

		# Log FLAC failure
		printf "%s::::Not a real FLAC file\n" "${i}" \
			>> "${log_file}"

		# Add one to fail fd
		printf '.' >> "${issue_ticks}"
	else
		# Find all the artwork blocks available in the current FLAC file
		__find_artwork

		# If the user chose a location to store extracted artwork, then prepend
		# a counter in front of the directory to prevent clobbering since all
		# the artwork will be housed in one directory.  Otherwise the artwork
		# will be placed in a subdirectory where the current FLAC file is
		# located
		if [[ -n "${artwork_location}" ]] ; then
			# Example: /artwork_location/[1] 01.flac_[redoflacs_art]_8792
			artwork_directory="${artwork_location}/[${iteration}] ${i##*/}_[redoflacs_art]_$$"
		else
			# Example: /path/to/current/flac/01.flac_[redoflacs_art]_8792
			artwork_directory="${i}_[redoflacs_art]_$$"
		fi

		#~~~~~~~
		# Other
		#~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_other[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_other[@]} == 1 )) ; then
				__extract_artwork "${artwork_other[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_other[@]}" ; do
					artwork_extension="${artwork_other[${art_file}]##*.}"
					__extract_artwork "${artwork_other[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# 32x32 pixels 'file icon' (PNG only)
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_file_icon[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_file_icon[@]} == 1 )) ; then
				__extract_artwork "${artwork_file_icon[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_file_icon[@]}" ; do
					artwork_extension="${artwork_file_icon[${art_file}]##*.}"
					__extract_artwork "${artwork_file_icon[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~
		# Other file icon
		#~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_other_file_icon[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_other_file_icon[@]} == 1 )) ; then
				__extract_artwork "${artwork_other_file_icon[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_other_file_icon[@]}" ; do
					artwork_extension="${artwork_other_file_icon[${art_file}]##*.}"
					__extract_artwork "${artwork_other_file_icon[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~
		# Cover (front)
		#~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_cover_front[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_cover_front[@]} == 1 )) ; then
				__extract_artwork "${artwork_cover_front[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_cover_front[@]}" ; do
					artwork_extension="${artwork_cover_front[${art_file}]##*.}"
					__extract_artwork "${artwork_cover_front[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~
		# Cover (back)
		#~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_cover_back[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_cover_back[@]} == 1 )) ; then
				__extract_artwork "${artwork_cover_back[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_cover_back[@]}" ; do
					artwork_extension="${artwork_cover_back[${art_file}]##*.}"
					__extract_artwork "${artwork_cover_back[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~
		# Leaflet page
		#~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_leaflet[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_leaflet[@]} == 1 )) ; then
				__extract_artwork "${artwork_leaflet[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_leaflet[@]}" ; do
					artwork_extension="${artwork_leaflet[${art_file}]##*.}"
					__extract_artwork "${artwork_leaflet[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Media (e.g. label side of CD)
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_media_label[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_media_label[@]} == 1 )) ; then
				__extract_artwork "${artwork_media_label[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_media_label[@]}" ; do
					artwork_extension="${artwork_media_label[${art_file}]##*.}"
					__extract_artwork "${artwork_media_label[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Lead artist/lead performer/soloist
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_lead_artist[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_lead_artist[@]} == 1 )) ; then
				__extract_artwork "${artwork_lead_artist[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_lead_artist[@]}" ; do
					artwork_extension="${artwork_lead_artist[${art_file}]##*.}"
					__extract_artwork "${artwork_lead_artist[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~~
		# Artist/performer
		#~~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_artist[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_artist[@]} == 1 )) ; then
				__extract_artwork "${artwork_artist[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_artist[@]}" ; do
					artwork_extension="${artwork_artist[${art_file}]##*.}"
					__extract_artwork "${artwork_artist[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~
		# Conductor
		#~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_conductor[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_conductor[@]} == 1 )) ; then
				__extract_artwork "${artwork_conductor[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_conductor[@]}" ; do
					artwork_extension="${artwork_conductor[${art_file}]##*.}"
					__extract_artwork "${artwork_conductor[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~
		# Band/Orchestra
		#~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_band[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_band[@]} == 1 )) ; then
				__extract_artwork "${artwork_band[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_band[@]}" ; do
					artwork_extension="${artwork_band[${art_file}]##*.}"
					__extract_artwork "${artwork_band[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~
		# Composer
		#~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_composer[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_composer[@]} == 1 )) ; then
				__extract_artwork "${artwork_composer[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_composer[@]}" ; do
					artwork_extension="${artwork_composer[${art_file}]##*.}"
					__extract_artwork "${artwork_composer[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~~~~~~
		# Lyricist/text writer
		#~~~~~~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_lyricist[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_lyricist[@]} == 1 )) ; then
				__extract_artwork "${artwork_lyricist[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_lyricist[@]}" ; do
					artwork_extension="${artwork_lyricist[${art_file}]##*.}"
					__extract_artwork "${artwork_lyricist[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~~~~
		# Recording Location
		#~~~~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_recording_location[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_recording_location[@]} == 1 )) ; then
				__extract_artwork "${artwork_recording_location[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_recording_location[@]}" ; do
					artwork_extension="${artwork_recording_location[${art_file}]##*.}"
					__extract_artwork "${artwork_recording_location[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~~
		# During recording
		#~~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_during_recording[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_during_recording[@]} == 1 )) ; then
				__extract_artwork "${artwork_during_recording[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_during_recording[@]}" ; do
					artwork_extension="${artwork_during_recording[${art_file}]##*.}"
					__extract_artwork "${artwork_during_recording[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~~~~
		# During performance
		#~~~~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_during_performance[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_during_performance[@]} == 1 )) ; then
				__extract_artwork "${artwork_during_performance[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_during_performance[@]}" ; do
					artwork_extension="${artwork_during_performance[${art_file}]##*.}"
					__extract_artwork "${artwork_during_performance[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Movie/video screen capture
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_movie[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_movie[@]} == 1 )) ; then
				__extract_artwork "${artwork_movie[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_movie[@]}" ; do
					artwork_extension="${artwork_movie[${art_file}]##*.}"
					__extract_artwork "${artwork_movie[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~~~~~~~~
		# A bright coloured fish
		#~~~~~~~~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_fish[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_fish[@]} == 1 )) ; then
				__extract_artwork "${artwork_fish[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_fish[@]}" ; do
					artwork_extension="${artwork_fish[${art_file}]##*.}"
					__extract_artwork "${artwork_fish[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~
		# Illustration
		#~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_illustration[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_illustration[@]} == 1 )) ; then
				__extract_artwork "${artwork_illustration[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_illustration[@]}" ; do
					artwork_extension="${artwork_illustration[${art_file}]##*.}"
					__extract_artwork "${artwork_illustration[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~~~~~~
		# Band/artist logotype
		#~~~~~~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_band_logo[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_band_logo[@]} == 1 )) ; then
				__extract_artwork "${artwork_band_logo[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_band_logo[@]}" ; do
					artwork_extension="${artwork_band_logo[${art_file}]##*.}"
					__extract_artwork "${artwork_band_logo[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Publisher/Studio logotype
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Only extact the artwork if any was found
		if [[ -n "${artwork_publisher_logo[@]}" ]] ; then
			# Create the directory where extracted artwork will be placed
			mkdir -p "${artwork_directory}"

			# If there was only one image for the given artwork type, then
			# extract it, otherwise make sure to add a number at the end of the
			# image in case there is more than one to prevent clobbering
			if (( ${#artwork_publisher_logo[@]} == 1 )) ; then
				__extract_artwork "${artwork_publisher_logo[0]}"
			else

				# Run through the images found in the file for the given artwork
				# type, stripping the extension, adding a number indicating
				# image number was found and appending the extension back before
				# extracting the images
				for art_file in "${!artwork_publisher_logo[@]}" ; do
					artwork_extension="${artwork_publisher_logo[${art_file}]##*.}"
					__extract_artwork "${artwork_publisher_logo[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
				done
			fi
		fi

		# Unset all the arrays used so we don't pollute other files
		unset -v \
			artwork_other \
			artwork_file_icon \
			artwork_other_file_icon \
			artwork_cover_front \
			artwork_cover_back \
			artwork_leaflet \
			artwork_media_label \
			artwork_lead_artist \
			artwork_artist \
			artwork_conductor \
			artwork_band \
			artwork_composer \
			artwork_lyricist \
			artwork_recording_location \
			artwork_during_recording \
			artwork_during_performance \
			artwork_movie \
			artwork_fish \
			artwork_illustration \
			artwork_band_logo \
			artwork_publisher_logo

		# FLAC is ok, display ok
		__print_progress_ok
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (3), to be used by the next job, terminated by a newline to
	# indicate job completed
	__store_position
}

# Prune FLACS
__operation_prune () {
	trap '__kill_jobs "$(jobs -rp)"' EXIT

	# Print current FLAC being pruned
	__print_current_half

	# Check if file is a FLAC file (hide output)
	metaflac --show-md5sum "${i}" >/dev/null 2>&1

	# Exit code 130 is SIGINT so only check for exit code '1'
	if (( ${?} == 1 )) ; then
		# Error with FLAC file, display failed/error
		__print_progress_failed

		# Log FLAC failure
		printf "%s::::Not a real FLAC file\n" "${i}" \
			>> "${log_file}"

		# Add one to fail fd
		printf '.' >> ${issue_ticks}
	else
		# Remove all information but STREAMINFO,VORBIS_COMMENTs, and
		# possibly METADATA_BLOCK_PICTURE
		metaflac --remove --dont-use-padding --except-block-type="${dont_prune_flac_metadata}" "${i}"

		# FLAC is ok, display ok
		__print_progress_ok
	fi

	# Store the position of where the line of the FLAC file is displayed in file
	# descriptor (3), to be used by the next job, terminated by a newline to
	# indicate job completed
	__store_position
}
#== .: END OPERATIONS :. =======================================================


#-------------------------------------------------------------------------------
# .: PRE-SCRIPT CHECKS :.
#-------------------------------------------------------------------------------
# Enable BASH 4 globstar
shopt -s globstar

# Version
version="0.22"

# This sets the script configuration revision (used to compare against the user
# configuration revision)
script_config_revision="2"

# Set FLAC extension for easy use later
flac_extension=".[Ff][Ll][Aa][Cc]"

# Colors on by default
blue="\033[34m"
green="\033[32m"
red="\033[31m"
cyan="\033[36m"
magenta="\033[35m"
yellow="\033[33m"
invert="\033[7m"
normal="\033[0m"

# Set arguments to null
# If enabled they will be changed to true
compress_flac=""
test_flac=""
aucdtect_flac=""
md5_check_flac=""
replaygain_flac=""
retag_flac=""
extract_artwork=""
prune_flac=""

# Check if user is running under Cygwin
# and if so, warn user and exit
os_name="$(uname -o)"
if [[ "${os_name}" == "Cygwin" ]] ; then
	__error "This version of redoflacs is meant to be run under\n" >&2
	__error "${cyan}UNIX/Linux/BSD${normal}.  Please use the ${cyan}Windows (Cygwin)${normal}\n" >&2
	__error "version located here:\n" >&2
	__error "${cyan}https://github.com/sirjaren/redoflacsw/tags${normal}\n" >&2

	exit 1
fi

# Check if configuration file exists based of ${EUID}.  If it doesn't
# exist, create one
if (( EUID == 0 )) ; then
	# User is root
	#
	# Configuration file location
	config_location="/etc/redoflacs.conf"

	# Check if system-wide configuration doesn't exist
	if [[ ! -f "${config_location}" ]] ; then
		# Create system-wide configuration file
		__create_config

		# Inform user of created configuration file, reminding them to check
		# it over before running program
		__info "A configuration file has been created here:\n"
		__info "${cyan}${config_location}${normal}\n\n"

		__info "Please review it before running this program.\n"

		exit 0
	else
		# Configuration file exists, parse it
		__parse_config
	fi
else
	# User is _NOT_ root
	#
	# Configuration file location
	config_location="${HOME}/.config/redoflacs/config"

	# Check if user configuration doesn't exist
	if [[ ! -f "${config_location}" ]] ; then
		# Create '.config/redoflacs' directory (if it doesn't exist)
		mkdir -p "${config_location%/*}"

		# Create user configuration file
		__create_config

		# Inform user of created configuration file, reminding them to check
		# it over before running program
		__info "A configuration file has been created here:\n"
		__info "${cyan}${config_location}${normal}\n\n"

		__info "Please review it before running this program.\n"

		exit 0
	else
		# Configuration file exists, parse it
		__parse_config
	fi
fi

# Generate log file location
#--
# Ensure we don't overwrite an existing log file by incrementing the current
# PID by 1 until the log file, that's to be set, doesn't exist
pid="$$"
log_file="${error_log}/redoflacs_${pid}.log"

until [[ ! -f "${log_file}" ]] ; do
	log_file="${error_log}/redoflacs_log_$((pid++)).log"
done

# Process positional parameters, allowing script to see
# which operations to run.  Make sure we send all the positional
# parameters called to the function, otherwise the function will
# think there aren't any positional parameters to process as it
# handles it's own positional parameters
__process_positional_parameters "${@}"

# Check if user set '-n, --no-color'.  This must come before everything (and
# after the positional parameters) to ensure color is set/unset.  The normal
# variable is always set, to reset the inverted colors (color or no-color)
# during progress bar output
if [[ "${no_color}" == "true" ]] ; then
	blue=""
	green=""
	red=""
	cyan=""
	magenta=""
	yellow=""
fi

# Make sure we are running BASH 4 or greater
if (( ${BASH_VERSION%%.*} < 4 )) ; then
	__error "You must be running ${cyan}BASH 4${normal} or greater to use\n" >&2
	__error "this program!\n" >&2
	exit 1
fi

# Check for any conflicting operations/arguments called
# at script invocation and warn user
__check_conflicting_operations

# For each operation that was chosen, set up operation_summary array
declare -A operation_summary
if [[ "${aucdtect_flac}" == "true" ]] ; then
	operation_summary['Validate with auCDtect']='Operation Did Not Run'
fi

if [[ "${md5_check_flac}" == "true" ]] ; then
	operation_summary['Check MD5 Signature']='Operation Did Not Run'
fi

if [[ "${compress_flac}" == "true" ]] ; then
	operation_summary['Compress FLACs']='Operation Did Not Run'
fi

if [[ "${test_flac}" == "true" ]] ; then
	operation_summary['Test FLACs']='Operation Did Not Run'
fi

if [[ "${replaygain_flac}" == "true" ]] ; then
	operation_summary['> Testing']='Operation Did Not Run'
	operation_summary['> Adding']='Operation Did Not Run'
fi

if [[ "${retag_flac}" == "true" ]] ; then
	operation_summary['> Analyzing']='Operation Did Not Run'
	operation_summary['> Applying']='Operation Did Not Run'
fi

if [[ "${extract_artwork}" == "true" ]] ; then
	operation_summary['Extracting Artwork']='Operation Did Not Run'
fi

if [[ "${prune_flac}" == "true" ]] ; then
	operation_summary['Prune METADATA Blocks']='Operation Did Not Run'
fi

# Check for any missing programs vital for this script
# to operate correctly, and exit if any programs are found
# to be missing
__check_missing_programs

# Check whether directory exists
if [[ ! -d "${directory}" ]] ; then
	printf "  Usage: redoflacs [OPTION] [PATH_TO_FLAC(s)]...\n\n" >&2
	__error "Please specify a directory!\n" >&2

	exit 1
fi

# Check for at least 1 FLAC file
read -r find_flacs < <( printf "%s\n" "${directory}"/**/*${flac_extension} )

# No FLAC files found
if [[ ! -f "${find_flacs}" ]] ; then
	__no_flacs
	exit 1
fi

# If "-e, --extract-artwork" was called, make sure artwork_location is a valid
# location, if user-defined
if [[ "${extract_artwork}" == "true" ]] ; then

	# Check if artwork_location is user-defined
	if [[ -n "${artwork_location}" ]] ; then

		# Put extracted artwork in user-defined location, testing to make sure
		# the directory exists
		if [[ ! -d "${artwork_location}" ]] ; then
			__error "${cyan}${artwork_location}${normal} doesn't exist!\n" >&2
			__error "Please set a valid directory in the configuration file!\n" >&2

			exit 1
		fi
	fi
fi

# If "-A, --aucdtect-spectrogram" was called, make sure spectrogram_location is
# a valid location, if user-defined
if [[ "${create_spectrogram}" == "true" ]] ; then

	# Check if spectrogram_location is user-defined
	if [[ -n "${spectrogram_location}" ]] ; then

		# Put spectrograms in user-defined location, testing to make sure the
		# directory exists
		if [[ ! -d "${spectrogram_location}" ]] ; then
			__error "${cyan}${spectrogram_location}${normal} doesn't exist!\n" >&2
			__error "Please set a valid directory in the configuration file!\n" >&2

			exit 1
		fi
	fi
fi

# If ${jobs} wasn't set upon invocation, check in /proc
# to see how many jobs should be run
if [[ -z "${jobs}" ]] ; then
	__find_cores
else
	jobs_display="(User Defined)"
fi
#== .: END PRE-SCRIPT CHECKS :. ================================================


#-------------------------------------------------------------------------------
# .: START SCRIPT :.
#-------------------------------------------------------------------------------
# Store current stty settings
old_stty="$(stty -g)"

# Prevent Control-C from displaying '^C'.  May already be set
stty -ctlecho 2> /dev/null

# Hide the cursor
printf "\033[?25l"

# Check to see if config file in script is newer than user config, warning
# user if their config is older displaying a countdown before continuing
__check_config_version

# Temporary FIFO location
tmp_fifo="/tmp/redoflacs_fifo_$$"

mkfifo "${tmp_fifo}"

# File where a tick is placed for each issue found
issue_ticks="/tmp/redoflacs_issue_file_$$"

# Display the top banner
if [[ "${retag_flac}" != "true" ]] ; then
	# Display top banner
	__top_banner
else
	# Force all the tag fields to be uppercase
	tags=( "${tags[@]^^}" )

	# Check for coverart conflicts.  Needed here
	# to allow script to exit right away if there
	# is a conflict
	__coverart_remove_conflict

	# Display a countdown before continuing
	__countdown_metadata

	# Display top banner
	__top_banner
fi

# Grab the total flacs to process
total_flacs_array=( "${directory}"/**/*${flac_extension} )

# String length of total number of flacs
total_flacs_length="${#total_flacs_array[@]}"
total_flacs_length="${#total_flacs_length}"

# This displays '[ ok ]' after 'Finding FLAC files to process...'
__processed_flacs_ok

#-------------------------------------------------------------------------------
# .: AUCDTECT :.
#-------------------------------------------------------------------------------
# The below order is probably the best bet in ensuring time
# isn't wasted on doing unnecessary operations if the
# FLAC files are corrupt or have metadata issues
if [[ "${aucdtect_flac}" == "true" ]] ; then
	# Prints title message of current operation
	__operation_message 'aucdtect'

	# Scroll terminal, if needed
	__scroll_terminal

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Open up a temporary file descriptor to send auCDtect's
	# STDOUT to
	__create_aucdtect_fd

	# Set the cursor to the correct row depending on whether there were more
	# or less files to process than the number of jobs to run
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# Less files than jobs to run, so only add the number of files
		# processed
		post_row=$(( $(__row) + ${#total_flacs_array[@]} ))
	else
		# More files than jobs to run, so add the number of jobs processed
		post_row=$(( $(__row) + jobs ))
	fi

	trap '__trap_sigint "$post_row" "aucdtect"' SIGINT

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files '__operation_aucdtect'

	printf "\033[${post_row}H"

	if [[ -f "${log_file}" ]] ; then
		# Print out log exists to STDERR
		__message_log_exists 'aucdtect'

		# Create and format log
		__create_log 'aucdtect'

		# Store operation status for Summary Of Operations
		operation_summary['Validate with auCDtect']="$(__msg_num_issues)"

		# Display Summary Of Operations
		__summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	operation_summary['Validate with auCDtect']='Operation Completed'
fi
#== .: END AUCDTECT :. =========================================================


#-------------------------------------------------------------------------------
# .: MD5 CHECK :.
#-------------------------------------------------------------------------------
if [[ "${md5_check_flac}" == "true" ]] ; then
	# Prints title message of current operation
	__operation_message 'md5_check'

	# Scroll terminal, if needed
	__scroll_terminal

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Set the cursor to the correct row depending on whether there were more
	# or less files to process than the number of jobs to run
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# Less files than jobs to run, so only add the number of files
		# processed
		post_row=$(( $(__row) + ${#total_flacs_array[@]} ))
	else
		# More files than jobs to run, so add the number of jobs processed
		post_row=$(( $(__row) + jobs ))
	fi

	trap '__trap_sigint "$post_row" "md5_check"' SIGINT

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files '__operation_md5check'

	printf "\033[${post_row}H"

	if [[ -f "${log_file}" ]] ; then
		# Print out log exists to STDERR
		__message_log_exists 'md5_check'

		# Prepend log header to log file
		__create_log 'md5_check'

		# Store operation status for Summary Of Operations
		operation_summary['Check MD5 Signature']="$(__msg_num_issues)"

		# Display Summary Of Operations
		__summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	operation_summary['Check MD5 Signature']='Operation Completed'
fi
#== .: END MD5 CHECK :. ========================================================


#-------------------------------------------------------------------------------
# .: COMPRESS/VERIFY :.
#-------------------------------------------------------------------------------
if [[ "${compress_flac}" == "true" ]] ; then
	# Prints title message of current operation
	__operation_message 'compress'

	# Scroll terminal, if needed
	__scroll_terminal

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Set the cursor to the correct row depending on whether there were more
	# or less files to process than the number of jobs to run
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# Less files than jobs to run, so only add the number of files
		# processed
		post_row=$(( $(__row) + ${#total_flacs_array[@]} ))
	else
		# More files than jobs to run, so add the number of jobs processed
		post_row=$(( $(__row) + jobs ))
	fi

	trap '__trap_sigint "$post_row" "compress"' SIGINT

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files '__operation_compress'

	printf "\033[${post_row}H"

	if [[ -f "${log_file}" ]] ; then
		# Print out log exists to STDERR
		__message_log_exists 'compress'

		# Prepend log header to log file
		__create_log 'compress'

		# Store operation status for Summary Of Operations
		operation_summary['Compress FLACs']="$(__msg_num_issues)"

		# Display Summary Of Operations
		__summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	operation_summary['Compress FLACs']='Operation Completed'
fi
#== .: END COMPRESS/VERIFY :. ==================================================


#-------------------------------------------------------------------------------
# .: TEST :.
#-------------------------------------------------------------------------------
if [[ "${test_flac}" == "true" ]] ; then
	# Prints title message of current operation
	__operation_message 'test'

	# Scroll terminal, if needed
	__scroll_terminal

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Set the cursor to the correct row depending on whether there were more
	# or less files to process than the number of jobs to run
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# Less files than jobs to run, so only add the number of files
		# processed
		post_row=$(( $(__row) + ${#total_flacs_array[@]} ))
	else
		# More files than jobs to run, so add the number of jobs processed
		post_row=$(( $(__row) + jobs ))
	fi

	trap '__trap_sigint "$post_row" "test"' SIGINT

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files '__operation_test'

	printf "\033[${post_row}H"

	if [[ -f "${log_file}" ]] ; then
		# Print out log exists to STDERR
		__message_log_exists 'test'

		# Prepend log header to log file
		__create_log 'test'

		# Store operation status for Summary Of Operations
		operation_summary['Test FLACs']="$(__msg_num_issues)"

		# Display Summary Of Operations
		__summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	operation_summary['Test FLACs']='Operation Completed'
fi
#== .: END TEST :. =============================================================


#-------------------------------------------------------------------------------
# .: REPLAYGAIN :.
#-------------------------------------------------------------------------------
if [[ "${replaygain_flac}" == "true" ]] ; then
	# Check if "-G, --replaygain-noforce" was called
	if [[ "${replaygain_noforce}" == "true" ]] ; then
		process_replaygain="__operation_replaygain_noforce"
	else
		process_replaygain="__operation_replaygain_force"
	fi

	# Prints title message of current operation
	__operation_message 'replaygain'

	# Obtain `metaflac' version information to test on.  Example:
	#   metaflac 1.3.0pre1
	#   -----------^
	# Test only the second integer in the version string above
	__metaflac_version

	#---------------------------------------------------------------------------
	# .: TEST REPLAYGAIN :.
	#---------------------------------------------------------------------------
	# Prints sub message of current operation
	__operation_message '' 'replaygain_test'

	# Scroll terminal, if needed
	__scroll_terminal

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Set the cursor to the correct row depending on whether there were more
	# or less files to process than the number of jobs to run
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# Less files than jobs to run, so only add the number of files
		# processed
		post_row=$(( $(__row) + ${#total_flacs_array[@]} ))
	else
		# More files than jobs to run, so add the number of jobs processed
		post_row=$(( $(__row) + jobs ))
	fi

	trap '__trap_sigint "$post_row" "replaygain_test"' SIGINT

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files '__operation_test_replaygain'

	printf "\033[${post_row}H"

	if [[ -f "${log_file}" ]] ; then
		# Print out log exists to STDERR
		__message_log_exists 'replaygain_test'

		# Prepend log header to log file
		__create_log 'replaygain_test'

		# Store operation status for Summary Of Operations
		operation_summary['> Testing']="$(__msg_num_issues)"

		# Display Summary Of Operations
		__summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	operation_summary['> Testing']='Operation Completed'
	#== .: END TEST REPLAYGAIN :. ==============================================


	#---------------------------------------------------------------------------
	# .: PROCESS REPLAYGAIN :.
	#---------------------------------------------------------------------------
	# Make printing pretty if specified directory is '.'
	if [[ "${directory}" == "." ]] ; then
		directory="${PWD}"
	fi

	# Grab number of directories to process provided as
	# ${total_directories}
	__total_directories

	# Prints sub message of current operation
	__operation_message '' 'replaygain_add'

	# Scroll terminal, if needed; we are specifying 'directory' to all the
	# '__scroll_terminal' function to apply logic on directories as opposed to
	# files
	__scroll_terminal 'directory'

	# Set the cursor to the correct row depending on whether there were more
	# or less directories to process than the number of jobs to run
	if (( ${#flac_directories_array[@]} < jobs )) ; then
		# Less directories than jobs to run, so only add the number of
		# directories processed
		post_row=$(( $(__row) + ${#flac_directories_array[@]} ))
	else
		# More directories than jobs to run, so add the number of jobs processed
		post_row=$(( $(__row) + jobs ))
	fi

	trap '__trap_sigint "$post_row" "replaygain_add"' SIGINT

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_directories "${process_replaygain}"

	printf "\033[${post_row}H"

	if [[ -f "${log_file}" ]] ; then
		# Print out log exists to STDERR
		__message_log_exists 'replaygain_add'

		# Prepend log header to log file
		__create_log 'replaygain_add'

		# Store operation status for Summary Of Operations
		operation_summary['> Adding']="$(__msg_num_issues)"

		# Display Summary Of Operations
		__summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	operation_summary['> Adding']='Operation Completed'
	#== .: END PROCESS REPLAYGAIN :. ===========================================
fi
#== .: END REPLAYGAIN :. =======================================================


#-------------------------------------------------------------------------------
# .: RETAG :.
#-------------------------------------------------------------------------------
if [[ "${retag_flac}" == "true" ]] ; then
	# If COVERART tag doesn't appear in any of the FLAC files'
	# tags, and if the user wants artwork to be kept, don't log
	# missing COVERART tags (in the event that the script adds
	# it into the tag array)
	if [[ "${coverart_warning}" != "true" && "${remove_artwork}" != "true" ]] ; then
		# Analyze tags but don't log COVERART as a missing
		# tag (if applicable)
		analyze_tags="__operation_analyze_tags_dont_log_coverart"
	else
		# Log all the missing tags found in the ${tags} array including COVERART
		# tag, regardless of whether it was added by the script or explicitly
		# chosen by the user
		analyze_tags="__operation_analyze_tags"
	fi

	# Prints title message of current operation
	__operation_message 'retag'

	# Copy the tag array because we will need to use it
	# later as we are _may_ add a temporary element to the
	# tag array
	old_tags=( "${tags[@]}" )

	#---------------------------------------------------------------------------
	# .: ANALYZE TAGS :.
	#---------------------------------------------------------------------------
	# Analyze FLAC tags to ensure none are missing and/or empty

	# Prints sub message of current operation
	__operation_message '' 'retag_analyze'

	# Scroll terminal, if needed
	__scroll_terminal

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Set the cursor to the correct row depending on whether there were more
	# or less files to process than the number of jobs to run
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# Less files than jobs to run, so only add the number of files
		# processed
		post_row=$(( $(__row) + ${#total_flacs_array[@]} ))
	else
		# More files than jobs to run, so add the number of jobs processed
		post_row=$(( $(__row) + jobs ))
	fi

	trap '__trap_sigint "$post_row" "retag_analyze"' SIGINT

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files "${analyze_tags}"

	printf "\033[${post_row}H"

	# Test for DEPRECATED tag, COVERART in METADATA_ERROR log.  If it
	# exists, set coverart_warning variable to make script output
	# warning upon completion
	if [[ -f "${log_file}" ]] ; then
		while read -r i ; do
			# Indentation is culled from reading in "${i}"
			# To change this, set IFS to '\n'
			if [[ "${i}" == *METADATA_BLOCK_PICTURE* ]] ; then
				coverart_warning="true"
				break
			fi
		done < "${log_file}"
	fi

	if [[ -f "${log_file}"  && "${coverart_warning}" == "true" ]] ; then
		# Display COVERART warning function and metadata issues
		printf '\n' >&2 ; __coverart_warning

		# Print out log exists to STDERR
		__message_log_exists 'retag'

		# Prepend log header to log file
		__create_log 'retag'

		# Store operation status for Summary Of Operations
		operation_summary['> Analyzing']="$(__msg_num_issues)"

		# Display Summary Of Operations
		__summary

		exit 1
	elif [[ -f "${log_file}" ]] ; then
		# Print out log exists to STDERR
		__message_log_exists 'retag'

		# Prepend log header to log file
		__create_log 'retag'

		# Store operation status for Summary Of Operations
		operation_summary['> Analyzing']="$(__msg_num_issues)"

		# Display Summary Of Operations
		__summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	operation_summary['> Analyzing']='Operation Completed'
	#== .: END ANALYZE TAGS :. =================================================


	#---------------------------------------------------------------------------
	# .: SET TAGS :.
	#---------------------------------------------------------------------------
	# Clear the old tags and re-tag with the kept tags

	# Restore the original tags array as the script _may_ have
	# added the COVERART tag.  This way, we ensure that the
	# COVERART tag was, in fact, temporary.
	tags=( "${old_tags[@]}" )

	# Prints sub message of current operation
	__operation_message '' 'retag_apply'

	# Scroll terminal, if needed
	__scroll_terminal

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Set the cursor to the correct row depending on whether there were more
	# or less files to process than the number of jobs to run
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# Less files than jobs to run, so only add the number of files
		# processed
		post_row=$(( $(__row) + ${#total_flacs_array[@]} ))
	else
		# More files than jobs to run, so add the number of jobs processed
		post_row=$(( $(__row) + jobs ))
	fi

	trap '__trap_sigint "$post_row" "retag_apply"' SIGINT

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files '__operation_set_tags'

	printf "\033[${post_row}H"

	# Store operation status for Summary Of Operations
	operation_summary['> Applying']='Operation Completed'
	#== .: END SET TAGS :. =====================================================
fi
#== .: END RETAG :. ============================================================


#-------------------------------------------------------------------------------
# .: EXTRACT ARTWORK :.
#-------------------------------------------------------------------------------
if [[ "${extract_artwork}" == "true" ]] ; then
	# Prints title message of current operation
	__operation_message 'extract_artwork'

	# Scroll terminal, if needed
	__scroll_terminal

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Set the cursor to the correct row depending on whether there were more
	# or less files to process than the number of jobs to run
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# Less files than jobs to run, so only add the number of files
		# processed
		post_row=$(( $(__row) + ${#total_flacs_array[@]} ))
	else
		# More files than jobs to run, so add the number of jobs processed
		post_row=$(( $(__row) + jobs ))
	fi

	trap '__trap_sigint "$post_row" "extract_artwork"' SIGINT

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files '__operation_extract_artwork'

	printf "\033[${post_row}H"

	if [[ -f "${log_file}" ]] ; then
		# Print out log exists to STDERR
		__message_log_exists 'extract_artwork'

		# Prepend log header to log file
		__create_log 'extract_artwork'

		# Store operation status for Summary Of Operations
		operation_summary['Extracting Artwork']="$(__msg_num_issues)"

		# Display Summary Of Operations
		__summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	operation_summary['Extracting Artwork']='Operation Completed'
fi
#== .: END EXTRACT ARTWORK :. ==================================================


#-------------------------------------------------------------------------------
# .: PRUNE :.
#-------------------------------------------------------------------------------
if [[ "${prune_flac}" == "true" ]] ; then
	# Don't remove artwork if user wants it kept.  We don't have to check
	# for the legacy COVERART tag as we are NOT removing any VORBIS_COMMENTs.
	if [[ "${remove_artwork}" == "true" ]] ; then
		# Remove artwork
		dont_prune_flac_metadata="STREAMINFO,VORBIS_COMMENT"
	else
		# Don't remove artwork
		dont_prune_flac_metadata="STREAMINFO,PICTURE,VORBIS_COMMENT"
	fi

	# Prints title message of current operation
	__operation_message 'prune'

	# Scroll terminal, if needed
	__scroll_terminal

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Set the cursor to the correct row depending on whether there were more
	# or less files to process than the number of jobs to run
	if (( ${#total_flacs_array[@]} < jobs )) ; then
		# Less files than jobs to run, so only add the number of files
		# processed
		post_row=$(( $(__row) + ${#total_flacs_array[@]} ))
	else
		# More files than jobs to run, so add the number of jobs processed
		post_row=$(( $(__row) + jobs ))
	fi

	trap '__trap_sigint "$post_row" "prune"' SIGINT

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files '__operation_prune'

	printf "\033[${post_row}H"

	if [[ -f "${log_file}" ]] ; then
		# Print out log exists to STDERR
		__message_log_exists 'prune'

		# Prepend log header to log file
		__create_log 'prune'

		# Store operation status for Summary Of Operations
		operation_summary['Prune METADATA Blocks']="$(__msg_num_issues)"

		# Display Summary Of Operations
		__summary

		exit 1
	fi

	# Store operation status for Summary Of Operations
	operation_summary['Prune METADATA Blocks']='Operation Completed'
fi
#== .: END PRUNE :. ============================================================


# Display warning about legacy COVERART tag, if applicable
if [[ "${coverart_warning}" == "true" ]] ; then
	__coverart_warning
fi

printf "\033[?25h"

# Display Summary Of Operations
__summary
#== .: END SCRIPT :. ===========================================================
