#!/usr/bin/env bash

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You can follow development of this script on Github at:
# https://github.com/sirjaren/redoflacs
#
# Please submit requests/changes/patches and/or comments
#-----------------------------------------------------------------
# TODO: Rework the Summary Of Operations to show sub processes (aka
#       Analyze Tags & Setting Tags)
# TODO: Condense some of the functions, separating bulky code
#       and getting rid of duplicated code
# TODO: Find a general format for logs and stick with it!
# TODO: Colorize filename and commands in STDERR
# TODO: Make it more clear on the Summary Of Operations
#       what it means when an operation has failed
# TODO: Consider creating a fallback to using box drawing
#       characters (ascii output?)
# TODO: Create a check on ReplayGain if using non git FLAC
#       and trying to create ReplayGain values on FLAC files
#       whos sample rate is higher than 48kHz
#-----------------------------------------------------------------
# File Descriptors used in this script
#    0: STDIN
#    1: STDOUT
#    2: STDERR
#    3: FIFO process manager
#    4: auCDtect's (STDOUT) output
#-----------------------------------------------------------------

tags=(
########################
#  USER CONFIGURATION  #
########################
# List the tags to be kept in each FLAC file
# The default is listed below.
# Be sure not to delete the parenthesis ")" below
# or put wanted tags below it! Another common tag
# not added by default is ALBUMARTIST.  Uncomment
# ALBUMARTIST below to allow script to keep this
# tag.

TITLE
ARTIST
#ALBUMARTIST
ALBUM
DISCNUMBER
DATE
TRACKNUMBER
TRACKTOTAL
GENRE

# The COMPRESSION tag is a custom tag to allow
# the script to determine which level of compression
# the FLAC file(s) has/have been compressed at.
COMPRESSION

# The RELEASETYPE tag is a custom tag the author
# of this script uses to catalogue what kind of
# release the album is (ie, Full Length, EP,
# Demo, etc.).
RELEASETYPE

# The SOURCE tag is a custom tag the author of
# this script uses to catalogue which source the
# album has derived from (ie, CD, Vinyl,
# Digital, etc.).
SOURCE

# The MASTERING tag is a custom tag the author of
# this script uses to catalogue how the album has
# been mastered (ie, Lossless, or Lossy).
MASTERING

# The REPLAYGAIN tags below, are added by the
# '-g, --replaygain' or '-G, --replaygain-noforce'
# argument.  If you want to keep the replaygain
# tags, make sure you leave these here.
REPLAYGAIN_REFERENCE_LOUDNESS
REPLAYGAIN_TRACK_GAIN
REPLAYGAIN_TRACK_PEAK
REPLAYGAIN_ALBUM_GAIN
REPLAYGAIN_ALBUM_PEAK

) # <- DO NOT DELETE PARENTHESIS!

# Set whether to remove embedded artwork within FLAC
# files.  By default, this script will remove any
# artwork it can find, whether it's in the legacy
# COVERART tag or METADATA_BLOCK_PICTURE.  Legal
# values are:
#    "true"  (Remove Artwork)
#    "false" (Keep Artwork)
REMOVE_ARTWORK="true"

# Set the type of COMPRESSION to compress the
# FLAC files.  Numbers range from 1-8, with 1 being
# the lowest compression and 8 being the highest
# compression.  The default is 8.
COMPRESSION_LEVEL=8

# Set the where you want the error logs to
# be placed. By default, they are placed in
# the user's HOME directory.
ERROR_LOG="${HOME}"

# Set where the created spectrogram files should
# be placed. By default, the spectrogram PNG files
# will be placed in the same directory as the tested
# FLAC files. Each PNG will have the same name as
# the tested FLAC file but with the extension ".png"
#
# The special value, "default" does the default
# action.  Other values are interpreted as a
# directory. An example of a user-defined location:
# SPECTROGRAM_LOCATION="${HOME}/Spectrogram_Images"
#
# See "--help" or "-h" for more information.
SPECTROGRAM_LOCATION="default"

##########################
#  END OF CONFIGURATION  #
##########################

######################
#  STATIC VARIABLES  #
######################
# Enable BASH 4 globstar
shopt -s globstar

# Version
VERSION="0.16.2"

# Various file extensions
FLAC_EXTENSION=".[Ff][Ll][Aa][Cc]"
WAV_EXTENSION=".[Ww][Aa][Vv]"

# Colors on by default
BOLD_BLUE="\033[1;34m"
BOLD_GREEN="\033[1;32m"
BOLD_RED="\033[1;31m"
CYAN="\033[0;36m"
MAGENTA="\033[0;35m"
YELLOW="\033[0;33m"
NORMAL="\033[0m"

# Log files with timestamp
VERIFY_ERRORS="${ERROR_LOG}/FLAC_Verify_Errors_$(date "+%Y%m%d-%H.%M.%S").log"
TEST_ERRORS="${ERROR_LOG}/FLAC_Test_Errors_$(date "+%Y%m%d-%H.%M.%S").log"
MD5_ERRORS="${ERROR_LOG}/MD5_Signature_Errors_$(date "+%Y%m%d-%H.%M.%S").log"
METADATA_ERRORS="${ERROR_LOG}/FLAC_Metadata_Errors_$(date "+%Y%m%d-%H.%M.%S").log"
REPLAY_TEST_ERRORS="${ERROR_LOG}/ReplayGain_Test_Errors_$(date "+%Y%m%d-%H.%M.%S").log"
REPLAY_ADD_ERRORS="${ERROR_LOG}/ReplayGain_Add_Errors_$(date "+%Y%m%d-%H.%M.%S").log"
AUCDTECT_ERRORS="${ERROR_LOG}/auCDtect_Errors_$(date "+%Y%m%d-%H.%M.%S").log"
PRUNE_ERRORS="${ERROR_LOG}/FLAC_Prune_Errors_$(date "+%Y%m%d-%H.%M.%S").log"

# Set arguments to null
# If enabled they will be changed to true
COMPRESS=""
TEST=""
AUCDTECT=""
MD5CHECK=""
REPLAYGAIN=""
REDO=""
PRUNE=""

###################################
#  INFORMATION PRINTED TO STDOUT  # 
###################################
# Bold green message
__info () {
	printf "${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s" \
	" " "*" " ${@}"
}
# Yellow message
__warn () {
	printf "${NORMAL}%s${YELLOW}%s${NORMAL}%s" \
	" " "*" " ${@}"
}
# Bold red message
__error () {
	printf "${NORMAL}%s${BOLD_RED}%s${NORMAL}%s" \
	" " "*" " ${@}"
}

# Prints a newline
__newline () {
	eval "printf '\n%.0s' {1..${1}}"
}

# Displaying currently running tasks
__title_compress_flac () {
	__newline 2
	__info "Compressing FLAC files with level ${COMPRESSION_LEVEL} compression and verifying output" ; __newline
}

__title_compress_notest_flac () {
	__newline 2
	__info "Compressing FLAC files with level ${COMPRESSION_LEVEL} compression" ; __newline
}

__title_test_replaygain () {
	__newline 2
	__info "Verifying FLAC Files can have ReplayGain Tags added" ; __newline
}

__title_add_replaygain () {
	__newline 2
	__info "Applying ReplayGain values by album directory" ; __newline
}

__title_analyze_tags () {
	__newline 2
	__info "Analyzing FLAC Tags" ; __newline
}

__title_setting_tags () {
	__newline 2
	__info "Setting new FLAC Tags" ; __newline
}

__title_testing_flac () {
	__newline 2
	__info "Testing the integrity of each FLAC file" ; __newline
}

__title_aucdtect_flac () {
	__newline 2
	__info "Validating FLAC is not lossy sourced" ; __newline
}

__title_md5check_flac () {
	__newline 2
	__info "Verifying the MD5 Signature in each FLAC file" ; __newline
}

__title_prune_flac () {
	# Change printed title based on whether embedded artwork is to be removed
	if [[ "${REMOVE_ARTWORK}" == "false" ]] ; then
		# Keep artwork
		local METADATA_REMOVED="STREAMINFO, VORBIS_COMMENT and PICTURE"
	else
		# Remove artwork
		local METADATA_REMOVED="STREAMINFO and VORBIS_COMMENT"
	fi

	__newline 2
	__info "Removing all METADATA blocks except ${METADATA_REMOVED}" ; __newline
}

# Error messages
# Don't display threads as script will quit after diplaying
__no_flacs () {
	{ __error "There are not any FLAC files to process!" ; __newline ;} >&2
}

# Information relating to currently running tasks
__print_compressing_flac () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Compressing FLAC ]' (20), minus three gaps (3), minus the
	# length of processed FLAC files, minus 3 (leaves a gap and the gives room for the
	# ellipsis (…) and cursor)
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 30 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 21 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 21 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Compressing FLAC" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}
__print_test_replaygain () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Testing ReplayGain ]' (22), minus three gaps (3), minus the
	# length of processed FLAC files, minus 3 (leaves a gap and the gives room for the
	# ellipsis (…) and cursor)
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 32 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"

	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 23 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 23 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Testing ReplayGain" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}
__print_add_replaygain () {
	# Obtain percentage of completed directories
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage_directories

	# Obtain current directory (stored in:
	# ${CURRENT_DIRECTORY_TOTAL} variable)
	__current_directory

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Adding ReplayGain ]' (21), minus three gaps (3), minus the
	# length of processed directories, minus 3 (leaves a gap and the gives room for the
	# ellipsis (…) and cursor)
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 31 - ${#CURRENT_DIRECTORY_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"

	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 22 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 22 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Adding ReplayGain" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_DIRECTORY_TOTAL}" " ${FILENAME}"
}
__print_testing_flac () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Testing FLAC ]' (16), minus three gaps (3), minus the
	# length of processed FLAC files, minus 3 (leaves a gap and the gives room for the
	# ellipsis (…) and cursor)
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 26 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi
	
	# 17 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 17 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Testing FLAC" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}
__print_failed_flac () {
	# Obtain percentage of completed files
	__find_percentage

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the gaps (and *) (8), minus the length
	# of the printed message, '[ Failed ]' (10), minus 2 (leaves a gap and the gives room for the
	# ellipsis (…))
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 20 ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 11 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 11 ))s${BOLD_BLUE}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r%s${BOLD_RED}%s${NORMAL}%s\n" \
	"" "[" " " "Failed" " " "]" "     " "*" " ${FILENAME}"
}
__print_checking_md5 () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Checking MD5 ]' (16), minus three gaps (3), minus the
	# length of processed FLAC files, minus 3 (leaves a gap and the gives room for the
	# ellipsis (…) and cursor)
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 26 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 17 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 17 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Checking MD5" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}
__print_ok_flac () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ ok ]' (6), minus three gaps (3), minus the
	# length of processed FLAC files, minus 2 (leaves a gap and the gives room for the
	# ellipsis (…))
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 15 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"

	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 7 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 7 ))s${BOLD_BLUE}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "ok" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}
__print_ok_replaygain () {
	# Obtain percentage of completed directories
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage_directories

	# Obtain current directory (stored in:
	# ${CURRENT_DIRECTORY_TOTAL} variable)
	__current_directory

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ ok ]' (6), minus three gaps (3), minus the
	# length of processed directories, minus 2 (leaves a gap and the gives room for the
	# ellipsis (…))
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 15 - ${#CURRENT_DIRECTORY_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"

	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 7 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 7 ))s${BOLD_BLUE}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "ok" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_DIRECTORY_TOTAL}" " ${FILENAME}"
}
__print_aucdtect_flac () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Validating FLAC ]' (19), minus three gaps (3), minus the
	# length of processed FLAC files, minus 3 (leaves a gap and the gives room for the
	# ellipsis (…) and cursor)
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 29 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 20 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 20 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Validating FLAC" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}
__print_aucdtect_issue () {
	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the gaps (and *) (8), minus the length
	# of the printed message, '[ Issue ]' (9), minus 2 (leaves a gap and the gives room for the
	# ellipsis (…))
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 19 ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 10 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 10 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r%s${BOLD_RED}%s${NORMAL}%s\n" \
	"" "[" " " "Issue" " " "]" "     " "*" " ${FILENAME}"
}
__print_aucdtect_spectrogram () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Creating Spectrogram ]' (24), minus three gaps (3), minus the
	# length of processed FLAC files, minus 3 (leaves a gap and the gives room for the
	# ellipsis (…) and cursor)
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 34 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 25 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 25 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Creating Spectrogram" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}
__print_aucdtect_skip () {
	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the gaps (and *) (8), minus the length
	# of the printed message, '[ Skipped ]' (11), minus 2 (leaves a gap and the gives room for the
	# ellipsis (…))
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 21 ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 12 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 12 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r%s${BOLD_RED}%s${NORMAL}%s\n" \
	"" "[" " " "Skipped" " " "]" "     " "*" " ${FILENAME}"
}
__print_done_flac () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Done ]' (8), minus three gaps (3), minus the
	# length of processed FLAC files, minus 2 (leaves a gap and the gives room for the
	# ellipsis (…))
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 17 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 9 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 9 ))s${BOLD_BLUE}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Done" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}
__print_level_same_compression () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of $COLUMNS minus the indent (7) minus length of the printed
	# message, [ Already At Level 8 ] (22) minus 2 (leaves a gap and the gives room for
	# the ellipsis (…))

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Already At Level 8 ]' (22), minus three gaps (3), minus the
	# length of processed FLAC files, minus 2 (leaves a gap and the gives room for the
	# ellipsis (…))
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 31 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 23 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 23 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Already At Level ${COMPRESSION_LEVEL}" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}
__print_analyzing_tags () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Analyzing Tags ]' (18), minus three gaps (3), minus the
	# length of processed FLAC files, minus 3 (leaves a gap and the gives room for the
	# ellipsis (…) and cursor)
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 28 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 19 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 19 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Analyzing Tags" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}
__print_setting_tags () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Setting Tags ]' (16), minus three gaps (3), minus the
	# length of processed FLAC files, minus 3 (leaves a gap and the gives room for the
	# ellipsis (…) and cursor)
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 26 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 17 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 17 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Setting Tags" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}
__print_prune_flac () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Pruning Metadata ]' (20), minus three gaps (3), minus the
	# length of processed FLAC files, minus 3 (leaves a gap and the gives room for the
	# ellipsis (…) and cursor)
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 30 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 21 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 21 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Pruning Metadata" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}

__print_interrupt () {
	# Obtain percentage of completed files
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage

	# Obtain current flac (stored in:
	# ${CURRENT_FLAC_TOTAL} variable)
	__current_flac

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Interrupted ]' (15), minus three gaps (3), minus the
	# length of processed FLAC files, minus 2 (leaves a gap and the gives room for the
	# ellipsis (…))
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 24 - ${#CURRENT_FLAC_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"
	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 16 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 16 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Interrupted" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_FLAC_TOTAL}" " ${FILENAME}"
}
__print_interrupt_replaygain () {
	# Obtain percentage of completed directories
	# (stored in: ${PERCENT_DISPLAY} variable)
	__find_percentage_directories

	# Obtain current directory (stored in:
	# ${CURRENT_DIRECTORY_TOTAL} variable)
	__current_directory

	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r COLUMNS < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with number of ${COLUMNS}
	COLUMNS="${COLUMNS/#*columns }"
	COLUMNS="${COLUMNS/%;*}"

	# This is the number of ${COLUMNS} minus the length of the percent (4), minus the length
	# of the printed message, '[ Interrupted ]' (15), minus three gaps (3), minus the
	# length of processed directories, minus 2 (leaves a gap and the gives room for the
	# ellipsis (…))
	MAX_FILENAME_LENGTH="$(( ${COLUMNS} - 24 - ${#CURRENT_DIRECTORY_TOTAL} ))"

	FILENAME="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	FILENAME="${FILENAME//
/?}"

	FILENAME_LENGTH="${#FILENAME}"

	if [[ "${FILENAME_LENGTH}" -gt "${MAX_FILENAME_LENGTH}" ]] ; then
		FILENAME="${FILENAME::$MAX_FILENAME_LENGTH}…"
	fi

	# 16 is the length of the printed message plus 1 for the gap at the end
	printf "\r${NORMAL}%$(( ${COLUMNS} - 16 ))s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\r${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s" \
	"" "[" " " "Interrupted" " " "]" "${PERCENT_DISPLAY}" " " "${CURRENT_DIRECTORY_TOTAL}" " ${FILENAME}"
}

######################################
#  FUNCTIONS TO DO VARIOUS COMMANDS  #
######################################
# Top banner displaying invocation settings
__top_banner () {
	# If Redo Tags is called, create the necessary spacing
	if [[ "${REDO}" == "true" ]] ; then
		__newline 2
	fi

	# Title
	printf "${NORMAL}%s" \
	"        Runtime Information" ; __newline

	# Title Line
	printf "${NORMAL}%s${BOLD_BLUE}%s${NORMAL}" \
	"   " "──────────────┬──────────────" ; __newline

	# Script Version
	printf "${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${CYAN}%s${NORMAL}" \
	"         Version " "│" " " "${VERSION}" ; __newline

	# Processes to be used
	printf "${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${CYAN}%s${NORMAL}" \
	"   Parallel Jobs " "│" " " "${jobs}" ; __newline

	# Log directory
	printf "${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${CYAN}%s${NORMAL}" \
	"   Log Directory " "│" " " "${ERROR_LOG}" ; __newline 2

	# Message indicating the searching of FLAC files
	__info "Finding FLAC files to process..."
}

# Create a countdown function for the metadata
# to allow user to quit script safely
__countdown_metadata () {
	# Countdown abort
	__countdown_abort () {
		__newline
		__info "Control-C received, exiting. Please wait..." ; __newline

		# Restore old stty settings, make stty happy
		# by redirecting /dev/stderr
		stty ${OLD_STTY} < /dev/stderr

		exit 1
	}

	# Creates the listing of tags to be kept
	__tags_listing () {
		for i in "${tags[@]}" ; do
			printf "%s\n" "     ${i}"
		done
	}

	# Creates the 10 second countdown
	__countdown_10 () {
		COUNT=10
		while [[ ${COUNT} -gt 1 ]] ; do
			printf "${BOLD_RED}%s${NORMAL}%s" "$COUNT" " "
			sleep 1
			((COUNT--))
		done
		# Below is the last second of the countdown
		# Put here for UI refinement (No extra spacing after last second)
		printf "${BOLD_RED}%s${NORMAL}" "1"
		sleep 1
	}

	# Trap SIGINT (Control-C) to abort cleanly
	trap __countdown_abort SIGINT

	__warn "CAUTION! These are the tag fields that will be kept" ; __newline
	__warn "when re-tagging the selected files:" ; __newline 2

	__tags_listing

	__newline
	__error "By default, this script will REMOVE embedded coverart" ; __newline
	__error "when re-tagging the files (that have the legacy COVERART" ; __newline
	__error "tag).  Change the REMOVE_ARTWORK option under USER" ; __newline
	__error "CONFIGURATION to \"false\" to keep embedded artwork." ; __newline 2

	__warn "Waiting 10 seconds before starting script..." ; __newline
	__warn "Ctrl+C (Control-C) to abort..." ; __newline

	printf "%s${BOLD_GREEN}%s${NORMAL}%s" \
	" " "*" " Starting in: "

	__countdown_10
}

##############################################
#  INCREMENT FLACS PROCESSED OR DIRECTORIES  #
##############################################
__increment_count () {
	# Add counter to temporary file (used for number of flacs processed/percentage)
	printf "%s\n" '.' >> "${PROCESSED_TMP_FILE}"
}

##################################
#  FIND CURRENT NUMBER OF FLACS  #
##################################
__current_flac () {
	# Obtain current number of processed FLAC files
	mapfile -n0 processed_array < "${PROCESSED_TMP_FILE}"
	CURRENT_FLAC="${#processed_array[@]}"

	# Store current FLAC out of total for display
	CURRENT_FLAC_TOTAL="[${CURRENT_FLAC}/${TOTAL_FLACS}]"
}

########################################
#  FIND CURRENT NUMBER OF DIRECTORIES  #
########################################
__current_directory () {
	# Obtain current number of processed directories
	mapfile -n0 processed_array < "${PROCESSED_TMP_FILE}"
	CURRENT_DIRECTORY="${#processed_array[@]}"

	# Store current directories out of total for display
	CURRENT_DIRECTORY_TOTAL="[${CURRENT_DIRECTORY}/${TOTAL_DIRECTORIES}]"
}

#######################
#  CREATE PERCENTAGE  #
#######################
__find_percentage () {
	# Obtain current number of processed FLAC files and create a percentage
	mapfile -n0 processed_array < "${PROCESSED_TMP_FILE}"
	PERCENT_DISPLAY="$(( ${#processed_array[@]} * 100 / ${TOTAL_FLACS} ))"

	case "${#PERCENT_DISPLAY}" in
		1)
			PERCENT_DISPLAY="  ${PERCENT_DISPLAY}%"
		;;
		2)
			PERCENT_DISPLAY=" ${PERCENT_DISPLAY}%"
		;;
		3)
			PERCENT_DISPLAY="${PERCENT_DISPLAY}%"
		;;
	esac	
}

######################################
#  CREATE PERCENTAGE OF DIRECTORIES  #
######################################
__find_percentage_directories () {
	# Obtain current number of processed directories and create a percentage
	mapfile -n0 processed_array < "${PROCESSED_TMP_FILE}"
	PERCENT_DISPLAY="$(( ${#processed_array[@]} * 100 / ${TOTAL_DIRECTORIES} ))"

	case "${#PERCENT_DISPLAY}" in
		1)
			PERCENT_DISPLAY="  ${PERCENT_DISPLAY}%"
		;;
		2)
			PERCENT_DISPLAY=" ${PERCENT_DISPLAY}%"
		;;
		3)
			PERCENT_DISPLAY="${PERCENT_DISPLAY}%"
		;;
	esac	
}

###############################################
#  FIND TOTAL DIRECTORIES HOUSING FLAC FILES  #
###############################################
__total_directories () {
	# Find all the directories in which to process the FLAC files. This will allow
	# multithreading when applying the ReplayGain tags without fear of race
	# conditions
	for i in "${total_flacs_array[@]}" ; do
		if [[ "${PROCESSED_DIRECTORY}" != "${i%/*}" ]] ; then
			flac_directories_array+=( "${i%/*}" )
		fi
		local PROCESSED_DIRECTORY="${i%/*}"
	done

	# Grab the total number of indices of above array
	TOTAL_DIRECTORIES_INDICES="$(( ${#flac_directories_array[@]} - 1 ))"

	# The total number of directories in a string variable
	TOTAL_DIRECTORIES="${#flac_directories_array[@]}"
}

####################################
#  CLEAR PROCESSED FLACS TMP FILE  #
####################################
__clear_processed_tmp_file () {
	> "${PROCESSED_TMP_FILE}"
}

##########################
#  CLEAR TEMPORARY FIFO  #
##########################
__clear_tmp_fd () {
	# Create temporary FIFO
	mkfifo "${TMP_FIFO}"

	# Open FIFO for reading and writing on file descriptor '3'
	exec 3<>"${TMP_FIFO}"

	# Remove temporary FIFO and leave just the file
	# descriptor available
	rm -f "${TMP_FIFO}"
}

####################################################
#  CREATE AUCDTECT TEMPORARY FIFO/FILE DESCRIPTOR  #
####################################################
__create_aucdtect_fd () {
	# Set up a temporary FIFO location
	TMP_AUCDTECT_FIFO="/tmp/redoflacs_aucdtect_fifo_$$"

	# Create the temporary FIFO
	mkfifo "${TMP_AUCDTECT_FIFO}"

	# Open FIFO for reading and writing on file descriptor '4'
	exec 4<>"${TMP_AUCDTECT_FIFO}"

	# Remove FIFO and leave just the file descriptor available
	rm "${TMP_AUCDTECT_FIFO}"
}

###############
#  KILL JOBS  #
###############
__kill_jobs () {
	# Hide error output in case there are no children to kill
	kill $(jobs -rp) 2> /dev/null
}

################
#  REPLAYGAIN  #
################
# Add ReplayGain to files and make sure each album disc uses the same
# ReplayGain values (multi-disc albums have their own ReplayGain) as well
# as make the tracks have their own ReplayGain values individually.
__replaygain () {
	#####################
	#  TEST REPLAYGAIN  #
	#####################

	__title_test_replaygain

	# Abort using BASH's trap command on SIGINT
	__replaygain_test_abort () {
		__print_interrupt

		# Kill running children
		__kill_jobs

		__newline
		__info "Control-C received, generating summary. Please wait..."

		if [[ -f "${REPLAY_TEST_ERRORS}" ]] ; then
			__newline >&2
			{ __error "There were issues with some of the FLAC files," ; __newline ;} >&2
			{ __error "please check:" ; __newline ;} >&2
			{ __error "\"${REPLAY_TEST_ERRORS}\" for details." ; __newline ;} >&2
		fi

		REPLAYGAIN_COMPLETE="interrupt"
		__operation_summary

		exit 1
	}

	# Trap SIGINT (Control-C) to abort cleanly
	trap __replaygain_test_abort SIGINT

	__test_replaygain () {
		# Let's make sure to kill running children if this
		# function was aborted via SIGINT.  This function
		# will receive SIGTERM from the kill in previous trap.
		trap '__kill_jobs ; exit 1' SIGTERM

		# Increment number of FLACs processed
		__increment_count

		__print_test_replaygain

		# Check if file is a FLAC file (hide output) and send to
		# background to allow killing on SIGTERM
		metaflac --show-md5sum "${i}" >/dev/null 2>&1 &

		# Wait on background process and return exit code of
		# said process
		wait "${!}"

		# Exit code 130 is SIGINT so only check for exit code '1'
		if [[ "${?}" -eq "1" ]] ; then
			# File is not a FLAC file, display failed
			__print_failed_flac
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: Not a FLAC file" \
				   "------------------------------------------------------------------" \
				   >> "${REPLAY_TEST_ERRORS}"
		else
			# File is a FLAC file, display ok
			__print_ok_flac
		fi

		# Print newline into FIFO after completion
		__newline >&3
	}

	# Make sure the temporary file is cleared before proceeding
	__clear_processed_tmp_file

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Start as many processes as determined by ${jobs}
	for i in "${total_flacs_array[@]:0:${jobs}}" ; do
		__test_replaygain &
	done

	# Add the number of processes started above to count
	ITERATION="${jobs}"

	# If the FLAC files to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if [[ "${TOTAL_FLACS}" -gt "${jobs}" ]] ; then

		# After each newline is read from FIFO, start a new process
		while read ; do
			# If current number of FLACs to process is less than total FLACs
			# found, add another FLAC to process
			if [[ "${ITERATION}" -lt "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				((ITERATION++))
				__test_replaygain &

			# If current number of FLACs to process is the last FLAC file, continue
			# processing it and break out of loop (to prevent hanging FIFO)
			elif [[ "${ITERATION}" -eq "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				__test_replaygain &
				break
			fi
		done <&3

	fi

    # Wait for children processes
    wait

	if [[ -f "${REPLAY_TEST_ERRORS}" ]] ; then
		__newline >&2
		{ __error "There were issues with some of the FLAC files," ; __newline ;} >&2
		{ __error "please check:" ; __newline ;} >&2
		{ __error "\"${REPLAY_TEST_ERRORS}\" for details." ; __newline ;} >&2

		REPLAYGAIN_COMPLETE="false"
		__operation_summary

		exit 1
	fi

	########################
	#  PROCESS REPLAYGAIN  #
	########################

	# Make printing pretty if specified DIRECTORY is '.'
	if [[ "${DIRECTORY}" == "." ]] ; then
		DIRECTORY="${PWD}"
	fi

	# Grab number of directories to process provided as
	# TOTAL_DIRECTORIES variable
	__total_directories

	__title_add_replaygain

	# Trap SIGINT (Control-C) to abort cleanly
	trap __replaygain_process_abort SIGINT

	# Abort using BASH's trap command on SIGINT
	__replaygain_process_abort () {
		__print_interrupt_replaygain

		# Kill running children
		__kill_jobs

		__newline
		__info "Control-C received, generating summary. Please wait..." ; __newline

		if [[ -f "${REPLAY_ADD_ERRORS}" ]] ; then
			__newline >&2
			{ __error "There were issues adding ReplayGain values," ; __newline ;} >&2
			{ __error "please check:" ; __newline ;} >&2
			{ __error "\"${REPLAY_ADD_ERRORS}\" for details." ; __newline ;} >&2
		fi

		REPLAYGAIN_COMPLETE="interrupt"
		__operation_summary

		exit 1
	}

	# Check if "-G, --replaygain-noforce" was called
	if [[ "${REPLAYGAIN_NOFORCE}" == "true" ]] ; then
		# Above option was called, skip FLAC files if all ReplayGain
		# tracks can be accounted for
		__process_replaygain () {
			# Let's make sure to kill running children if this
			# function was aborted via SIGINT.  This function
			# will receive SIGTERM from the kill in previous trap
			trap '__kill_jobs ; exit 1' SIGTERM

			# Increment number of directories processed and create percentage
			# of total processed out of the total directories
			__increment_count

			# ${i} is the parent directory to the FLAC files
			# ${j} is a FLAC file -> under ${i}
			for j in "${i}"/*${FLAC_EXTENSION} ; do
				# Grab all of the ReplayGain tags
				REPLAYGAIN_REFERENCE_LOUDNESS="$(metaflac --show-tag=REPLAYGAIN_REFERENCE_LOUDNESS "${j}")"
				REPLAYGAIN_REFERENCE_LOUDNESS="${REPLAYGAIN_REFERENCE_LOUDNESS#*=}"

				REPLAYGAIN_TRACK_GAIN="$(metaflac --show-tag=REPLAYGAIN_TRACK_GAIN "${j}")"
				REPLAYGAIN_TRACK_GAIN="${REPLAYGAIN_TRACK_GAIN#*=}"

				REPLAYGAIN_TRACK_PEAK="$(metaflac --show-tag=REPLAYGAIN_TRACK_PEAK "${j}")"
				REPLAYGAIN_TRACK_PEAK="${REPLAYGAIN_TRACK_PEAK#*=}"

				REPLAYGAIN_ALBUM_GAIN="$(metaflac --show-tag=REPLAYGAIN_ALBUM_GAIN "${j}")"
				REPLAYGAIN_ALBUM_GAIN="${REPLAYGAIN_ALBUM_GAIN#*=}"

				REPLAYGAIN_ALBUM_PEAK="$(metaflac --show-tag=REPLAYGAIN_ALBUM_PEAK "${j}")"
				REPLAYGAIN_ALBUM_PEAK="${REPLAYGAIN_ALBUM_PEAK#*=}"

				# Test if any ReplayGain values are empty
				if [[ -z "${REPLAYGAIN_REFERENCE_LOUDNESS}" || \
					  -z "${REPLAYGAIN_TRACK_GAIN}" || \
					  -z "${REPLAYGAIN_TRACK_PEAK}" || \
					  -z "${REPLAYGAIN_ALBUM_GAIN}" || \
					  -z "${REPLAYGAIN_ALBUM_PEAK}" \
				   ]] ; then
					# At _least_ one tag is missing from current file, so
					# apply new ReplayGain values
					__print_add_replaygain

					# Add ReplayGain to FLAC files under directory and send
					# to background to allow killing on SIGTERM.  Metaflac
					# automatically removes old ReplayGain values (if any)
					# before proceeding
					metaflac --add-replay-gain "${i}"/*${FLAC_EXTENSION} >/dev/null 2>&1 &

					# Wait on background process and return exit code of
					# said process
					wait "${!}"

					# Exit code 130 is SIGINT so only check for exit code '1'
					if [[ "${?}" -eq 1 ]] ; then
						__print_failed_flac
						printf "%s\n%s\n%s\n%s\n" \
							   "Directory: ${i}" \
							   "ERROR:     There was an issue with some FLAC files in this directory." \
							   "           Check that the sample rate is the same for all FLAC files." \
							   "------------------------------------------------------------------" \
							   >> "${REPLAY_ADD_ERRORS}"

						# Placeholder variable tested after this loop
						# if the loop completes with 'break'
						BROKE_OUT_OF_LOOP="true"

						# Break out of loop and on to next directory
						break
					else
						__print_ok_replaygain

						# Placeholder variable tested after this loop
						# if the loop completes with 'break'
						BROKE_OUT_OF_LOOP="true"

						# Break out of loop and on to next directory
						break
					fi
				fi
			done

			# If processed directory did not have missing ReplayGain
			# tags, print ok (skipped adding ReplayGain tags)
			if [[ "${BROKE_OUT_OF_LOOP}" != "true" ]] ; then
				__print_ok_replaygain
			fi

			# Print newline into FIFO after completion
			__newline >&3
		}
	else
		# Above option was NOT called
		__process_replaygain () {
			# Let's make sure to kill running children if this
			# function was aborted via SIGINT.  This function
			# will receive SIGTERM from the kill in previous trap
			trap '__kill_jobs ; exit 1' SIGTERM

			# Increment number of directories processed
			__increment_count

			__print_add_replaygain

			# Add ReplayGain to FLAC files under directory and send
			# to background to allow killing on SIGTERM
			metaflac --add-replay-gain "${i}"/*${FLAC_EXTENSION} >/dev/null 2>&1 &

			# Wait on background process and return exit code of
			# said process
			wait "${!}"

			# Exit code 130 is SIGINT so only check for exit code '1'
			if [[ "${?}" -eq 1 ]] ; then
				__print_failed_flac
				printf "%s\n%s\n%s\n%s\n" \
					   "Directory: ${i}" \
					   "ERROR:     There was an issue with some FLAC files in this directory." \
					   "           Check that the sample rate is the same for all FLAC files." \
					   "------------------------------------------------------------------" \
					   >> "${REPLAY_ADD_ERRORS}"
			else
				__print_ok_replaygain
			fi

			# Print newline into FIFO after completion
			__newline >&3
		}
	fi

	# Make sure the temporary file is cleared before proceeding
	__clear_processed_tmp_file

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Start as many processes as determined by ${jobs}
	for i in "${flac_directories_array[@]:0:${jobs}}" ; do
		__process_replaygain &
	done

	# Add the number of processes started above to count
	ITERATION="${jobs}"

	# If the directories to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if [[ "${TOTAL_DIRECTORIES}" -gt "${jobs}" ]] ; then

		# After each newline is read from FIFO, start a new process
		while read ; do
			# If current number of directories to process is less than total directories
			# found, add another directory to process
			if [[ "${ITERATION}" -lt "${TOTAL_DIRECTORIES_INDICES}" ]] ; then
				# Set ${i} to current directory to process
				i="${flac_directories_array[${ITERATION}]}"
				((ITERATION++))
				__process_replaygain &

			# If current directory to process is the last directory, continue
			# processing it and break out of loop (to prevent hanging FIFO)
			elif [[ "${ITERATION}" -eq "${TOTAL_DIRECTORIES_INDICES}" ]] ; then
				# Set ${i} to current directory to process
				i="${flac_directories_array[${ITERATION}]}"
				__process_replaygain &
				break
			fi
		done <&3

	fi

	# Wait for children processes
	wait

	if [[ -f "${REPLAY_ADD_ERRORS}" ]] ; then
		__newline >&2
		{ __error "There were issues with some of the FLAC files," ; __newline ;} >&2
		{ __error "please check:" ; __newline ;} >&2
		{ __error "\"${REPLAY_ADD_ERRORS}\" for details." ; __newline ;} >&2

		REPLAYGAIN_COMPLETE="false"
		__operation_summary

		exit 1
	fi

	# ReplayGain completed successfully
	REPLAYGAIN_COMPLETE="true"
}

#############################
#  COMPRESS & VERIFY FLACS  #
#############################
# Compress FLAC files and verify output
__compress_flacs () {
	# If '-C, --compress-notest' was called, print the
	# correct title
	if [[ "${SKIP_TEST}" == "true" ]] ; then
		__title_compress_notest_flac
	else
		__title_compress_flac
	fi

	# Abort script and remove temporarily encoded FLAC files (if any)
	# and check for any errors thus far
	__compress_abort () {
		__print_interrupt

		# Kill running children
		__kill_jobs

		__newline
		__info "Control-C received, removing temporary files and" ; __newline
		__info "generating summary. Please wait..." ; __newline

		# Remove temporarily encoded FLAC files
		rm -f "${DIRECTORY}"/**/*.tmp,fl-ac+en\'c

		if [[ -f "${VERIFY_ERRORS}" ]] ; then
			__newline >&2
			{ __error "Errors found in some FLAC files, please check:" ; __newline ;} >&2
			{ __error "\"${VERIFY_ERRORS}\" for errors" ; __newline ;} >&2
		fi

		COMPRESS_COMPLETE="interrupt"
		__operation_summary

		exit 1
	}

	# Trap SIGINT (Control-C) to abort cleanly
	trap __compress_abort SIGINT

	__compress_f () {
		# Let's make sure to kill running children if this
		# function was aborted via SIGINT.  This function
		# will receive SIGTERM from the kill in previous trap
		trap '__kill_jobs ; exit 1' SIGTERM

		# Increment number of FLACs processed
		__increment_count

		# Test for COMPRESSION level in FLAC file. Hide error output since
		# we'll be verifying the FLAC file later
		COMPRESSION="$(metaflac --show-tag=COMPRESSION "${i}" 2> /dev/null)"
		COMPRESSION="${COMPRESSION/#*=}"

		if [[ "${COMPRESSION}" != "${COMPRESSION_LEVEL}" ]] ; then
			__print_compressing_flac

			# Compress FLAC file with user defined COMPRESSION and send to
			# background to allow killing on SIGTERM
			flac -f -${COMPRESSION_LEVEL} -V --totally-silent "${i}" &

			# Wait on background process and return exit code of
			# said process
			wait "${!}"

			# Exit code 130 is SIGINT so only check for exit code '1'
			if [[ "${?}" -eq 1 ]] ; then
				__print_failed_flac
				printf "%s\n%s\n%s\n" \
					   "FLAC:  ${i}" \
					   "ERROR: Not a FLAC file or failed verification." \
					   "------------------------------------------------------------------" \
					   >> "${VERIFY_ERRORS}"
			else
				metaflac --remove-tag=COMPRESSION "${i}"
				metaflac --set-tag=COMPRESSION=${COMPRESSION_LEVEL} "${i}"
				__print_ok_flac
			fi

		# If already at COMPRESSION_LEVEL, test the FLAC file instead
		# or skip the file if '-C, --compress-notest' was specified
		else
			__print_level_same_compression

			if [[ "${SKIP_TEST}" != "true" ]] ; then
				__print_testing_flac

				# Test FLAC file and send to background to allow
				# killing on SIGTERM
				flac -t --totally-silent "${i}" &

				# Wait on background process and return exit code of
				# said process
				wait "${!}"

				# Exit code 130 is SIGINT so only check for exit code '1'
				if [[ "${?}" -eq 1 ]] ; then
					__print_failed_flac
					printf "%s\n%s\n%s\n" \
						   "FLAC:  ${i}" \
						   "ERROR: Not a FLAC file or failed testing." \
						   "------------------------------------------------------------------" \
						   >> "${VERIFY_ERRORS}"
				else
					__print_ok_flac
				fi
			fi

		fi

		# Print newline into FIFO after completion
		__newline >&3
	}

	# Make sure the temporary file is cleared before proceeding
	__clear_processed_tmp_file

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Start as many processes as determined by ${jobs}
	for i in "${total_flacs_array[@]:0:${jobs}}" ; do
		__compress_f &
	done

	# Add the number of processes started above to count
	ITERATION="${jobs}"

	# If the FLAC files to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if [[ "${TOTAL_FLACS}" -gt "${jobs}" ]] ; then

		# After each newline is read from FIFO, start a new process
		while read ; do
			# If current number of FLACs to process is less than total FLACs
			# found, add another FLAC to process
			if [[ "${ITERATION}" -lt "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				((ITERATION++))
				__compress_f &
			else
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				__compress_f &
				break
			fi
		done <&3

	fi

	# Wait for children processes
	wait

	if [[ -f "${VERIFY_ERRORS}" ]] ; then
		__newline >&2
		{ __error "Errors found in some FLAC files, please check:" ; __newline ;} >&2
		{ __error "\"${VERIFY_ERRORS}\" for errors" ; __newline ;} >&2

		COMPRESS_COMPLETE="false"
		__operation_summary

		exit 1
	fi

	# Compress FLACS completed successfully
	COMPRESS_COMPLETE="true"
}

################
#  TEST FLACS  #
################
# Test FLAC files
__test_flacs () {
	__title_testing_flac

	# Abort script and check for any errors thus far
	__test_abort () {
		__print_interrupt

		# Kill running children
		__kill_jobs

		__newline
		__info "Control-C received, generating summary. Please wait..." ; __newline

		if [[ -f "${TEST_ERRORS}" ]] ; then
			__newline >&2
			{ __error "Errors found in some FLAC files, please check:" ; __newline ;} >&2
			{ __error "\"${TEST_ERRORS}\" for errors" ; __newline ;} >&2
		fi

		TEST_COMPLETE="interrupt"
		__operation_summary

		exit 1
	}

	# Trap SIGINT (Control-C) to abort cleanly
	trap __test_abort SIGINT

	__test_f () {
		# Let's make sure to kill running children if this
		# function was aborted via SIGINT.  This function
		# will receive SIGTERM from the kill in previous trap
		trap '__kill_jobs ; exit 1' SIGTERM

		# Increment number of FLACs processed
		__increment_count

		__print_testing_flac

		# Test FLAC file and send to background to
		# allow killing on SIGTERM
		flac -t --totally-silent "${i}" &

		# Wait on background process and return exit code of
		# said process
		wait "${!}"

		# Exit code 130 is SIGINT so only check for exit code '1'
		if [[ "${?}" -eq 1 ]] ; then
			__print_failed_flac
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: Not a FLAC file or failed testing." \
				   "------------------------------------------------------------------" \
				   >> "${TEST_ERRORS}"
		else
			__print_ok_flac
		fi

		# Print newline into FIFO after completion
		__newline >&3
	}

	# Make sure the temporary file is cleared before proceeding
	__clear_processed_tmp_file

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Start as many processes as determined by ${jobs}
	for i in "${total_flacs_array[@]:0:${jobs}}" ; do
		__test_f &
	done

	# Add the number of processes started above to count
	ITERATION="${jobs}"

	# If the FLAC files to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if [[ "${TOTAL_FLACS}" -gt "${jobs}" ]] ; then

		# After each newline is read from FIFO, start a new process
		while read ; do

			# If current number of FLACs to process is less than total FLACs
			# found, add another FLAC to process
			if [[ "${ITERATION}" -lt "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				((ITERATION++))
				__test_f &

			# If current number of FLACs to process is the last FLAC file, continue
			# processing it and break out of loop (to prevent hanging FIFO)
			elif [[ "${ITERATION}" -eq "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				__test_f &
				break
			fi
		done <&3

	fi

	# Wait for children processes
	wait

	if [[ -f "${TEST_ERRORS}" ]] ; then
		__newline >&2
		{ __error "Errors found in some FLAC files, please check:" ; __newline ;} >&2
		{ __error "\"${TEST_ERRORS}\" for errors" ; __newline ;} >&2

		TEST_COMPLETE="false"
		__operation_summary

		exit 1
	fi

	# Test FLACS completed successfully
	TEST_COMPLETE="true"
}

#######################################
#  CHECK FLAC VALIDITY WITH AUCDTECT  #
#######################################
# Use auCDtect to check FLAC validity
__aucdtect () {
	# Check if SPECTROGRAM_LOCATION is user-defined
	if [[ "${SPECTROGRAM_LOCATION}" != "default" ]] ; then
		# Put spectrograms in user-defined location
		# Test to make sure directory exists
		if [[ ! -d "${SPECTROGRAM_LOCATION}" ]] ; then
			{ __error "\"${SPECTROGRAM_LOCATION}\" doesn't exist!" ; __newline ;} >&2
			{ __error "Please choose a valid directory under USER CONFIGURATION!" ; __newline ;} >&2

			exit 1
		fi
	fi

	__title_aucdtect_flac

	# Abort script and check for any errors thus far
	__aucdtect_abort () {
		__print_interrupt

		# Kill running children
		__kill_jobs

		__newline
		__info "Control-C received, removing temporary files and" ; __newline
		__info "generating summary. Please wait..." ; __newline

		# Remove temporarily created WAV files (if any)
		rm -f "${DIRECTORY}"/**/*_redoflacs_"$$".wav

		if [[ -f "${AUCDTECT_ERRORS}" ]] ; then
			__newline >&2
			{ __error "Some FLAC files may be lossy sourced, please check:" ; __newline ;} >&2
			{ __error "\"${AUCDTECT_ERRORS}\" for details" ; __newline ;} >&2
		fi

		AUCDTECT_COMPLETE="interrupt"
		__operation_summary

		exit 1
	}

	# Trap SIGINT (Control-C) to abort cleanly
	trap __aucdtect_abort SIGINT

	__aucdtect_f () {
		# Let's make sure to kill running children if this
		# function was aborted via SIGINT.  This function
		# will receive SIGTERM from the kill in previous trap
		trap '__kill_jobs ; exit 1' SIGTERM

		# Increment number of FLACs processed
		__increment_count

		__print_aucdtect_flac

		# Get the bit depth of a FLAC file, also used to check
		# if FLAC file is real.  Hide stderr output
		BITS="$(metaflac --show-bps "${i}" 2> /dev/null)"

		# Exit code 130 is SIGINT so only check for exit code '1'
		if [[ "${?}" -eq "1" ]] ; then
			# File is not a FLAC file, display failed
			__print_failed_flac
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: Not a FLAC file" \
				   "------------------------------------------------------------------" \
				   >> "${AUCDTECT_ERRORS}"

		# Skip the FLAC file if it has a bit depth greater
		# than 16 since auCDtect doesn't support audio
		# files with a higher resolution than a CD.
		elif [[ "${BITS}" -gt "16" ]] ; then
			__print_aucdtect_skip
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: The above file has a bit depth greater than 16 and was skipped" \
				   "------------------------------------------------------------------" \
				   >> "${AUCDTECT_ERRORS}"

		# FLAC checks out, continue processing
		else
			# The WAV file to be created from current FLAC file
			DECODED_WAV="${i%${FLAC_EXTENSION}}_redoflacs_"$$".wav"

			# Decompress FLAC to WAV so auCDtect can read the audio file
			# and send to background to allow killing on SIGTERM
			flac --totally-silent -d "${i}" -o "${DECODED_WAV}" &

			# Wait on background process and return exit code of
			# said process
			wait "${!}"

			# Exit code 130 is SIGINT so only check for exit code '1'
			# If FLAC file failed decoding to WAV, log error, otherwise
			# continue processing
			if [[ "${?}" -eq "1" ]] ; then
				__print_failed_flac
				printf "%s\n%s\n%s\n" \
					   "FLAC:  ${i}" \
					   "ERROR: Failed decoding FLAC file to WAV (most likely corrupt)" \
					   "------------------------------------------------------------------" \
					   >> "${AUCDTECT_ERRORS}"
			else
				# 'export MALLOC_CHECK_' allows the dynamic linked version of auCDtect
				# to run without throwing errors
				export MALLOC_CHECK_="0"

				# The actual auCDtect command with highest accuracy setting
				# 2> hides the displayed progress to /dev/null disabling the progress percentage
				# STDOUT is sent to file descriptor '4' and the prcess sent to the background to allow
				# killing via SIGTERM
				"${AUCDTECT_COMMAND}" -m0 "${DECODED_WAV}" 2>/dev/null >&4 &

				# Wait on background process and return exit code of
				# said process
				wait "${!}"

				# Exit code 130 is SIGINT so only check for exit code '1'
				# If auCDtect failed to 
				if [[ "${?}" -eq "1" ]] ; then
					__print_failed_flac
					printf "%s\n%s\n%s\n%s\n%s\n%s\n" \
						   "FLAC:  ${i}" \
						   "WAV:   ${DECODED_WAV}" \
						   "ERROR: auCDtect failed to analyze the decoded WAV file." \
						   "       Something may have happened when decoding the above FLAC" \
						   "       file.  Please verify the FLAC file is not corrupt." \
						   "------------------------------------------------------------------" \
						   >> "${AUCDTECT_ERRORS}"
				else
					# Grab the conclusion of auCDtect's command
					# Below options prevents hanging FIFO by only reading
					# what is necessary:
					#    -s7:  Discard first seven lines from auCDtect's output
					#    -n2:  Only grab 2 lines from auCDtect's output
					#     -t:  Remove trailing newlines from auCDtect's output
					#    -u4:  Obtain auCDtect's output from file descriptor '4'
					#  array:  Store captured output into 'aucdtect_check_array'
					mapfile -s7 -n2 -t -u4 aucdtect_check_array

					# There is an issue with the processed FLAC file
					if [[ "${aucdtect_check_array[0]}" != "This track looks like CDDA with probability 100%" ]] ; then
						# If user specified '-A, --aucdtect-spectrogram', then
						# create a spectrogram with SoX and change logging accordingly
						if [[ "${CREATE_SPECTROGRAM}" == "true" ]] ; then
							# Check whether to place spectrogram images in user-defined location
							if [[ "${SPECTROGRAM_LOCATION}" == "default" ]] ; then
								# Place images in same directory as the FLAC files
								# Make sure we don't clobber any picture files
								if [[ -f "${i%${FLAC_EXTENSION}}.png" ]] ; then
									# File exists so prepend "spectrogram" before ".png"
									SPECTROGRAM_PICTURE="${i%${FLAC_EXTENSION}}.spectrogram.png"
								else
									# File doesn't exist, so create the spectrogram with the basename of "$i"
									# with ".png" as the extension
									SPECTROGRAM_PICTURE="${i%${FLAC_EXTENSION}}.png"
								fi
							else
								# Place images in user-defined location
								FLAC_FILE="${i##*/}"
								SPECTROGRAM_PICTURE="${SPECTROGRAM_LOCATION}/${FLAC_FILE%${FLAC_EXTENSION}}.png"
							fi

							# Let's create the spectrogram for the failed FLAC file
							# and output progress
							__print_aucdtect_spectrogram

							# SoX command to create the spectrogram and place it in SPECTROGRAM_PICTURE,
							# sent to the background to allow killing via SIGTERM
							"${SOX_COMMAND}" "${i}" -n spectrogram -c '' -t "${i}" -p1 -z90 -Z0 -q249 -wHann -x1800 -y513 -o "${SPECTROGRAM_PICTURE}" &

							# Use the below version of the command to create hi-res spectrograms
							#"${SOX_COMMAND}" "${i}" -n spectrogram -c '' -t "${i}" -p1 -z90 -Z0 -q249 -wHann -x5000 -y1025 -o "${SPECTROGRAM_PICTURE}"

							# Wait on background process and return exit code of
							# said process
							wait "${!}"

							# Print ISSUE and log error, and show where to find
							# the created spectrogram of the processed FLAC file
							__print_aucdtect_issue
							printf "%s\n%s\n%s\n%s\n" \
								   "FLAC:        ${i}" \
								   "ERROR:       ${aucdtect_check_array[0]}" \
								   "SPECTROGRAM: ${SPECTROGRAM_PICTURE}" \
								   "------------------------------------------------------------------" \
								   >> "${AUCDTECT_ERRORS}"
						else
							# Print ISSUE and log error
							__print_aucdtect_issue
							printf "%s\n%s\n%s\n" \
								   "FLAC:  ${i}" \
								   "ERROR: ${aucdtect_check_array[0]}" \
								   "------------------------------------------------------------------" \
								   >> "${AUCDTECT_ERRORS}"
						fi
					# The processed FLAC file is OK
					else
						__print_ok_flac
					fi

					# Remove temporary WAV file
					rm "${DECODED_WAV}"
				fi
			fi
		fi

		# Print newline into FIFO after completion
		__newline >&3
	}

	# Make sure the temporary file is cleared before proceeding
	__clear_processed_tmp_file

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Open up a temporary file descriptor to send auCDtect's
	# STDOUT to
	__create_aucdtect_fd

	# Start as many processes as determined by ${jobs}
	for i in "${total_flacs_array[@]:0:${jobs}}" ; do
		__aucdtect_f &
	done

	# Add the number of processes started above to count
	ITERATION="${jobs}"

	# If the FLAC files to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if [[ "${TOTAL_FLACS}" -gt "${jobs}" ]] ; then

		# After each newline is read from FIFO, start a new process
		while read ; do
			# If current number of FLACs to process is less than total FLACs
			# found, add another FLAC to process
			if [[ "${ITERATION}" -lt "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				((ITERATION++))
				__aucdtect_f &

			# If current number of FLACs to process is the last FLAC file, continue
			# processing it and break out of loop (to prevent hanging FIFO)
			elif [[ "${ITERATION}" -eq "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				__aucdtect_f &
				break
			fi
		done <&3

	fi

	# Wait for children processes
	wait

	if [[ -f "${AUCDTECT_ERRORS}" ]] ; then
		__newline >&2
		{ __error "Some FLAC files may be lossy sourced, please check:" ; __newline ;} >&2
		{ __error "\"${AUCDTECT_ERRORS}\" for details" ; __newline ;} >&2

		AUCDTECT_COMPLETE="false"
		__operation_summary

		exit 1
	fi

	# auCDtect completed successfully
	AUCDTECT_COMPLETE="true"
}

#########################
#  CHECK MD5 SIGNATURE  #
#########################
# Check for unset MD5 Signatures in FLAC files
__md5_check () {
	__title_md5check_flac

	# Abort script and check for any errors thus far
	__md5_check_abort () {
		__print_interrupt

		# Kill running children
		__kill_jobs

		__newline
		__info "Control-C received, generating summary. Please wait..." ; __newline

		if [[ -f "${MD5_ERRORS}" ]] ; then
			__newline >&2
			{ __error "The MD5 Signature is unset for some FLAC files or there were" ; __newline ;} >&2
			{ __error "issues with some of the FLAC files, please check:" ; __newline ;} >&2
			{ __error "\"${MD5_ERRORS}\" for details" ; __newline ;} >&2
		fi

		MD5CHECK_COMPLETE="interrupt"
		__operation_summary

		exit 130
	}

	# Trap SIGINT (Control-C) to abort cleanly
	trap __md5_check_abort SIGINT

	__md5_c () {
		# Let's make sure to kill running children if this
		# function was aborted via SIGINT.  This function
		# will receive SIGTERM from the kill in previous trap
		trap '__kill_jobs ; exit 130' SIGTERM

		# Increment number of FLACs processed
		__increment_count

		__print_checking_md5

		# Get the MD5 checksum (hide stderr output).  Also
		# used to check if FLAC file is real
		MD5_SUM="$(metaflac --show-md5sum "${i}" 2> /dev/null)"

		# Exit code 130 is SIGINT so only check for exit code '1'
		if [[ "${?}" -eq "1" ]] ; then
			# File is not a FLAC file, display failed
			__print_failed_flac
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: Not a FLAC file" \
				   "------------------------------------------------------------------" \
				   >> "${MD5_ERRORS}"

		# FLAC file is real, check for unset MD5 checksum
		elif [[ "${MD5_SUM}" == "00000000000000000000000000000000" ]] ; then
			__print_failed_flac
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: MD5 Signature unset: (${MD5_SUM})" \
				   "------------------------------------------------------------------" \
				   >> "${MD5_ERRORS}"
		else
				__print_ok_flac
		fi

		# Print newline into FIFO after completion
		__newline >&3
	}

	# Make sure the temporary file is cleared before proceeding
	__clear_processed_tmp_file

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Start as many processes as determined by ${jobs}
	for i in "${total_flacs_array[@]:0:${jobs}}" ; do
		__md5_c &
	done

	# Add the number of processes started above to count
	ITERATION="${jobs}"

	# If the FLAC files to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if [[ "${TOTAL_FLACS}" -gt "${jobs}" ]] ; then

		# After each newline is read from FIFO, start a new process
		while read ; do

			# If current number of FLACs to process is less than total FLACs
			# found, add another FLAC to process
			if [[ "${ITERATION}" -lt "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				((ITERATION++))
				__md5_c &

			# If current number of FLACs to process is the last FLAC file, continue
			# processing it and break out of loop (to prevent hanging FIFO)
			elif [[ "${ITERATION}" -eq "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				__md5_c &
				break
			fi
		done <&3

	fi

	# Wait for children processes
	wait

	if [[ -f "${MD5_ERRORS}" ]] ; then
		__newline >&2
		{ __error "The MD5 Signature is unset for some FLAC files or there were" ; __newline ;} >&2
		{ __error "issues with some of the FLAC files, please check:" ; __newline ;} >&2
		{ __error "\"${MD5_ERRORS}\" for details" ; __newline ;} >&2

		MD5CHECK_COMPLETE="false"
		__operation_summary

		exit 1
	fi

	# MD5 Check completed successfully
	MD5CHECK_COMPLETE="true"
}

###############
#  REDO TAGS  #
###############
# If COVERART tag is kept and REMOVE_ARTWORK is set to 'true'
# display conflict and exit
__coverart_remove_conflict () {
	# Check if COVERART exists in the tag array.  Notify user
	# of its deprecation and advise against using it, preferring
	# METADATA_BLOCK_PICTURE
	for j in "${tags[@]}" ; do
		if [[ "${j}" == "COVERART" ]] ; then
			# If REMOVE_ARTWORK is "true" (remove the artwork), then
			# exit and warn the user you can't specify whether you want to
			# remove artwork, yet keep the COVERART tag in USER CONFIGURATION
			if [[ "${REMOVE_ARTWORK}" == "true" ]] ; then

				# Display COVERART tag warning
				__coverart_warning

				__newline >&2
				{ __error "It appears you have REMOVE_ARTWORK set to \"true\" under" ; __newline ;} >&2
				{ __error "USER CONFIGURATION, yet COVERART is specified as one" ; __newline ;} >&2
				{ __error "(or more) of the FLAC tags to be kept. Please choose either" ; __newline ;} >&2
				{ __error "keep album artwork (ie REMOVE_ARTWORK=\"false\") or remove" ; __newline ;} >&2
				{ __error "the COVERART tag under the USER CONFIGURATION portion of this" ; __newline ;} >&2
				{ __error "script." ; __newline ;} >&2

				# Remove temporary file
				rm -f "${PROCESSED_TMP_FILE}"

				exit 1
			# COVERART was found, but artwork is to be removed,
			# so warn user
			else
				# Create COVERART_WARNING variable, so script can append
				# the coverart_warning function after completion as well as
				# determine the correct tag array to use (whether we should
				# add COVERART or not)
				COVERART_WARNING="true"

				# Display tag field warning
				__countdown_metadata
			fi
		fi
	done

	# COVERART wasn't found and REMOVE_ARTWORK is set to 'true'
	if [[ "${COVERART_WARNING}" != "true" ]] ; then
		__countdown_metadata
	fi
}

# Display why COVERART tag should not be used
__coverart_warning () {
	__newline >&2
	{ __warn "The COVERART tag is deprecated and should not be" ; __newline ;} >&2
	{ __warn "used. Instead, consider migrating over to the new format:" ; __newline ;} >&2
	{ __warn "METADATA_BLOCK_PICTURE, using modern tag editors. Read:" ; __newline ;} >&2
	{ __warn "http://wiki.xiph.org/VorbisComment#Unofficial_COVERART_field_.28deprecated.29" ; __newline ;} >&2
	{ __warn "for more details." ; __newline ;} >&2
}

# Check for missing tags and retag FLAC files if all files
# are not missing tags
__redo_tags () {
	# Abort script and check for any errors thus far
	__redo_tags_abort () {
		__print_interrupt

		# Kill running children
		__kill_jobs

		__newline
		__info "Control-C received, generating summary. Please wait..." ; __newline

		# Test for DEPRECATED tag, COVERART in METADATA_ERROR log.  If it
		# exists, set COVERART_WARNING variable to make script output
		# warning upon completion
		if [[ -f "${METADATA_ERRORS}" ]] ; then
			while read i ; do
				# Indentation is culled from reading in "${i}"
				# To change this, set IFS to '\n'
				if [[ "${i}" == "the new format: METADATA_BLOCK_PICTURE." ]] ; then
					COVERART_WARNING="true"
					break
				fi
			done < "${METADATA_ERRORS}"
		fi

		if [[ -f "${METADATA_ERRORS}"  && "${COVERART_WARNING}" == "true" ]] ; then
			# Display COVERART warning function and metadata issues
			__newline >&2

			# Below is already redirected to STDERR
			__coverart_warning

			__newline >&2
			{ __error "Some FLAC files have missing tags or there were" ; __newline ;} >&2
			{ __error "issues with some of the FLAC files, please check:" ; __newline ;} >&2
			{ __error "\"${METADATA_ERRORS}\" for details." ; __newline ;} >&2
			{ __error "Not Re-Tagging files." ; __newline ;} >&2

			REDO_COMPLETE="interrupt"
			__operation_summary

			exit 1

		elif [[ -f "${METADATA_ERRORS}" ]] ; then
			# Just display metadata issues
			__newline >&2
			{ __error "Some FLAC files have missing tags or there were" ; __newline ;} >&2
			{ __error "issues with some of the FLAC files, please check:" ; __newline ;} >&2
			{ __error "\"${METADATA_ERRORS}\" for details." ; __newline ;} >&2
			{ __error "Not Re-Tagging files." ; __newline ;} >&2

			REDO_COMPLETE="interrupt"
			__operation_summary

			exit 1
		fi

		REDO_COMPLETE="interrupt"
		__operation_summary

		exit 1
	}

	# Trap SIGINT (Control-C) to abort cleanly
	trap __redo_tags_abort SIGINT

	################
	# ANALYZE TAGS #
	################

	__analyze_tags () {
		# Check if file is a FLAC file (variable hides output)
		CHECK_FLAC="$(metaflac --show-md5sum "${i}" 2>&1)"

		# If above command return anything other than '0', log output
		if [[ "${?}" -ne "0" ]] ; then
			printf "%s\n%s\n%s\n" \
				  "FLAC:  ${i}" \
				  "ERROR: The above file does not appear to be a FLAC file" \
				  "------------------------------------------------------------------" \
				  >> "${METADATA_ERRORS}"
			# File is not a FLAC file, display failed
			__print_failed_flac
		else
			# Iterate through each tag field and check if tag is missing
			for j in "${tags[@]}" ; do
				# Check if ALBUMARTIST is in tag array and apply operations on
				# the tag field if it exists
				if [[ "${j}" == "ALBUMARTIST" ]] ; then
					# ALBUMARTIST exists in tag array so allow script to check the
					# various naming conventions within the FLAC files (ie,
					# 'ALBUM ARTIST' or 'ALBUM_ARTIST')

					# "ALBUMARTIST" or "ALBUM ARTIST" or "ALBUM_ARTIST", case-insensitive
					if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${i}")" ]] ; then
						local TEMP_TAG="$(metaflac --show-tag=ALBUMARTIST "${i}")"
					elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${i}")" ]] ; then
						local TEMP_TAG="$(metaflac --show-tag="ALBUM ARTIST" "${i}")"
					elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${i}")" ]] ; then
						local TEMP_TAG="$(metaflac --show-tag="ALBUM_ARTIST" "${i}")"
					fi
				else
					# Grab current tag "${j}" from FLAC file
					local TEMP_TAG="$(metaflac --show-tag="${j}" "${i}")"
				fi

				# Tag field (ie 10 Years, 2001, etc)
				local TAG_VALUE="${TEMP_TAG/#*=}"

				# If tags are not found store missing information into an array
				# to be logged
				if [[ -z "${TAG_VALUE}" && "${FILE_PRINTED}" != "true" ]] ; then
					# First instance of missing tag for current file
					missing_tags_array+=( "FLAC:  ${i}"
								   "ERROR: ${j} tag not found" )
					FILE_PRINTED="true"
				elif [[ -z "${TAG_VALUE}" && "${FILE_PRINTED}" == "true" ]] ; then
					# If more than one missing tag in current file,
					# don't print out filename, just the missing tag
					missing_tags_array+=( "       ${j} tag not found" )
				fi
			done
				# If missing_tags_array is not empty, there are missing
				# tags in the current file so log output
				if [[ -n "${missing_tags_array[@]}" ]] ; then
					# Add separator to log for each file
					missing_tags_array+=( "------------------------------------------------------------------" )
					# Print array into log file
					printf "%s\n" "${missing_tags_array[@]}" >> "${METADATA_ERRORS}"
				fi

		# Done analyzing FLAC file tags
		__print_done_flac
		fi
	}

	__analyze_tags_dont_log_coverart () {
		# Check if file is a FLAC file (variable hides output)
		CHECK_FLAC="$(metaflac --show-md5sum "${i}" 2>&1)"

		# If above command return anything other than '0', log output
		if [[ "${?}" -ne "0" ]] ; then
			printf "$%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: The above file does not appear to be a FLAC file" \
				   "------------------------------------------------------------------" \
				   >> "${METADATA_ERRORS}"
			# File is not a FLAC file, display failed
			__print_failed_flac
		else
			# Album artwork is to be kept so preserve COVERART by adding
			# it to the tag array (temporary)
			tags+=( COVERART )

			# Iterate through each tag field and check if tag is missing (except
			# for the COVERART tag)
			for j in "${tags[@]}" ; do
				# Check if ALBUMARTIST is in tag array and apply operations on
				# the tag field if it exists
				if [[ "${j}" == "ALBUMARTIST" ]] ; then
					# ALBUMARTIST exists in tag array so allow script to check the
					# various naming conventions within the FLAC files (ie,
					# 'ALBUM ARTIST' or 'ALBUM_ARTIST')

					# "ALBUMARTIST" or "ALBUM ARTIST" or "ALBUM_ARTIST", case-insensitive
					if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${i}")" ]] ; then
						local TEMP_TAG="$(metaflac --show-tag=ALBUMARTIST "${i}")"
					elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${i}")" ]] ; then
						local TEMP_TAG="$(metaflac --show-tag="ALBUM ARTIST" "${i}")"
					elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${i}")" ]] ; then
						local TEMP_TAG="$(metaflac --show-tag="ALBUM_ARTIST" "${i}")"
					fi
				else
					# Grab current tag "${j}" from FLAC file
					local TEMP_TAG="$(metaflac --show-tag="${j}" "${i}")"
				fi

				# Tag field (ie 10 Years, 2001, etc)
				local TAG_VALUE="${TEMP_TAG/#*=}"

				# If COVERART tag is not null, then log file that has
				# the COVERART tag embedded within it about deprecation
				if [[ "${j}" == "COVERART" && -n "${TAG_VALUE}" ]] ; then
					printf "%s\n%s\n%s\n%s\n" \
						   "FLAC:  ${i}" \
						   "ERROR: \"${j}\" tag is DEPRECATED in above file. Consider migrating to" \
						   "       the new format: METADATA_BLOCK_PICTURE." \
						   "------------------------------------------------------------------" \
						   >> "${METADATA_ERRORS}"
				fi

				# If tags are not found store missing information into an array
				# to be logged. Skip output of COVERART tag as this is a temporary
				# addition to the tag array (for processing legacy artwork)
				if [[ -z "${TAG_VALUE}" && "${FILE_PRINTED}" != "true" && "${j}" != "COVERART" ]] ; then
					# First instance of missing tag for current file
					missing_tags_array+=( "FLAC:  ${i}"
										  "ERROR: ${j} tag not found" )
					FILE_PRINTED="true"
				elif [[ -z "${TAG_VALUE}" && "${FILE_PRINTED}" == "true" && "${j}" != "COVERART" ]] ; then
					# If more than one missing tag in current file, don't print
					# out filename
					missing_tags_array+=( "       ${j} tag not found" )
				fi
			done
				# If missing_tags_array is not empty, there are missing
				# tags in the current file so log output
				if [[ -n "${missing_tags_array[@]}" ]] ; then
					# Add separator to log for each file
					missing_tags_array+=( "------------------------------------------------------------------" )
					# Print array into log file
					printf "%s\n" "${missing_tags_array[@]}" >> "${METADATA_ERRORS}"
				fi

		# Done analyzing FLAC file tags
		__print_done_flac
		fi
	}

	# If COVERART was specified under USER CONFIGURATION
	# set the tag array accordingly and test whether there
	# are missing tags in each FLAC file
	if [[ "${COVERART_WARNING}" == "true" ]] ; then
		__title_analyze_tags

		# COVERART is already in the tag array. Implies album
		# artwork is to be kept, so log if COVERART tag is missing
		__check_tags () {
			# Let's make sure to kill running children if this
			# function was aborted via SIGINT.  This function
			# will receive SIGTERM from the kill in previous trap
			trap '__kill_jobs ; exit 1' SIGTERM

			# Increment number of FLACs processed
			__increment_count

			# Print script operation title
			__print_analyzing_tags

			# Analyze FLACs for missing tags
			__analyze_tags

			# Print newline into FIFO after completion
			__newline >&3
		}
	else
		# COVERART is not in the tag array, so add it if album artwork
		# is to be kept
		if [[ "${REMOVE_ARTWORK}" == "false" ]] ; then
			__title_analyze_tags

			# Analyze tags but don't log COVERART is missing tag
			__check_tags () {
				# Let's make sure to kill running children if this
				# function was aborted via SIGINT.  This function
				# will receive SIGTERM from the kill in previous trap
				trap '__kill_jobs ; exit 1' SIGTERM

				# Increment number of FLACs processed
				__increment_count

				# Print script operation title
				__print_analyzing_tags

				# Analyze FLACs for missing tags
				# (except for COVERART tag)
				__analyze_tags_dont_log_coverart

				# Print newline into FIFO after completion
				__newline >&3
			}
		else
			__title_analyze_tags

			# Album artwork is NOT kept, so process tag fields, omitting COVERART
			__check_tags () {
				# Let's make sure to kill running children if this
				# function was aborted via SIGINT.  This function
				# will receive SIGTERM from the kill in previous trap
				trap '__kill_jobs ; exit 1' SIGTERM

				# Increment number of FLACs processed
				__increment_count

				# Print script operation title
				__print_analyzing_tags

				# Analyze FLACs for missing tags
				__analyze_tags

				# Print newline into FIFO after completion
				__newline >&3
			}
		fi
	fi

	# Make sure the temporary file is cleared before proceeding
	__clear_processed_tmp_file

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Start as many processes as determined by ${jobs}
	for i in "${total_flacs_array[@]:0:${jobs}}" ; do
		__check_tags &
	done

	# Add the number of processes started above to count
	ITERATION="${jobs}"

	# If the FLAC files to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if [[ "${TOTAL_FLACS}" -gt "${jobs}" ]] ; then

		# After each newline is read from FIFO, start a new process
		while read ; do
			# If current number of FLACs to process is less than total FLACs
			# found, add another FLAC to process
			if [[ "${ITERATION}" -lt "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				((ITERATION++))
				__check_tags &

			# If current number of FLACs to process is the last FLAC file, continue
			# processing it and break out of loop (to prevent hanging FIFO)
			elif [[ "${ITERATION}" -eq "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				__check_tags &
				break
			fi
		done <&3

	fi

	# Wait for children processes
	wait

	# Test for DEPRECATED tag, COVERART in METADATA_ERROR log.  If it
	# exists, set COVERART_WARNING variable to make script output
	# warning upon completion
	if [[ -f "${METADATA_ERRORS}" ]] ; then
		while read i ; do
			# Indentation is culled from reading in "${i}"
			# To change this, set IFS to '\n'
			if [[ "${i}" == "the new format: METADATA_BLOCK_PICTURE." ]] ; then
				COVERART_WARNING="true"
				break
			fi
		done < "${METADATA_ERRORS}"
	fi

	if [[ -f "${METADATA_ERRORS}"  && "${COVERART_WARNING}" == "true" ]] ; then
		# Display COVERART warning function and metadata issues
		__newline >&2

		# Below is already redirected to STDERR
		__coverart_warning

		__newline >&2
		{ __error "Some FLAC files have missing tags or there were" ; __newline ;} >&2
		{ __error "issues with some of the FLAC files, please check:" ; __newline ;} >&2
		{ __error "\"${METADATA_ERRORS}\" for details." ; __newline ;} >&2
		{ __error "Not Re-Tagging files." ; __newline ;} >&2

		REDO_COMPLETE="false"
		__operation_summary

		exit 1
	elif [[ -f "${METADATA_ERRORS}" ]] ; then
		# Just display metadata issues
		__newline >&2
		{ __error "Some FLAC files have missing tags or there were" ; __newline ;} >&2
		{ __error "issues with some of the FLAC files, please check:" ; __newline ;} >&2
		{ __error "\"${METADATA_ERRORS}\" for details." ; __newline ;} >&2
		{ __error "Not Re-Tagging files." ; __newline ;} >&2

		REDO_COMPLETE="false"
		__operation_summary

		exit 1
	fi

	############
	# SET TAGS #
	############

	# Restore the original tags array as it _may_ have added the
	# COVERART tag.  This way, we ensure that the COVERART
	# tag was, in fact, temporary.
	tags=( "${old_tags[@]}" )

	__title_setting_tags

	# Set the FLAC metadata to each FLAC file
	__remove_set_tags () {
		# Set up 'album_tags_array' associative array
		declare -A album_tags_array

		# Iterate through the tag array and set a variable for each tag
		for j in "${tags[@]}" ; do
			# Check if ALBUMARTIST is in tag array and apply operations on
			# the tag field if it exists
			if [[ "${j}" == "ALBUMARTIST" ]] ; then
				# ALBUMARTIST exists in tag array so allow script to check the
				# various naming conventions within the FLAC files (ie,
				# 'ALBUM ARTIST' or 'ALBUM_ARTIST')

				# "ALBUMARTIST"
				if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${i}")" ]] ; then
					local TEMP_TAG="$(metaflac --show-tag=ALBUMARTIST "${i}")"
				elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${i}")" ]] ; then
					local TEMP_TAG="$(metaflac --show-tag="ALBUM ARTIST" "${i}")"
				elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${i}")" ]] ; then
					local TEMP_TAG="$(metaflac --show-tag="ALBUM_ARTIST" "${i}")"
				fi
			else
				# Grab current tag "${j}" from FLAC file
				local TEMP_TAG="$(metaflac --show-tag="${j}" "${i}")"
			fi

			# Tag key (ie ARTIST, DATE, etc)
			local TAG_KEY="${TEMP_TAG//=*}"
			# Make uppercase
			local TAG_KEY="${TAG_KEY^^}"

			# Tag field (ie 10 Years, 2001, etc)
			local TAG_VALUE="${TEMP_TAG/#*=}"

			# Put new tag values into associative array
			album_tags_array["${TAG_KEY}"]="${TAG_VALUE}"
		done
	
		# Iterate through the tag array and add the saved tags back.
		# Use process substitution to allow this to finish if user
		# invokes SIGINT
		metaflac --remove-all-tags --import-tags-from=- "${i}" \
			< <(for j in "${tags[@]}" ; do
				printf "%s\n" "${j}=${album_tags_array["${j}"]}"
			done)
	}

	# Actual function to re-tag FLAC files
	__retag_flacs () {
		# Let's make sure to kill running children if this
		# function was aborted via SIGINT.  This function
		# will receive SIGTERM from the kill in previous trap
		trap '__kill_jobs ; exit 1' SIGTERM

		# Increment number of FLACs processed
		__increment_count

		__print_setting_tags

		# Remove and set new tags
		__remove_set_tags

		__print_ok_flac

		# Print newline into FIFO after completion
		__newline >&3
	}

	# Make sure the temporary file is cleared before proceeding
	__clear_processed_tmp_file

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Start as many processes as determined by ${jobs}
	for i in "${total_flacs_array[@]:0:${jobs}}" ; do
		__retag_flacs &
	done

	# Add the number of processes started above to count
	ITERATION="${jobs}"

	# If the FLAC files to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if [[ "${TOTAL_FLACS}" -gt "${jobs}" ]] ; then

		# After each newline is read from FIFO, start a new process
		while read ; do

			# If current number of FLACs to process is less than total FLACs
			# found, add another FLAC to process
			if [[ "${ITERATION}" -lt "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				((ITERATION++))
				__retag_flacs &

			# If current number of FLACs to process is the last FLAC file, continue
			# processing it and break out of loop (to prevent hanging FIFO)
			elif [[ "${ITERATION}" -eq "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				__retag_flacs &
				break
			fi
		done <&3

	fi

	# Wait for children processes
	wait

	# Redo Tags completed successfully
	REDO_COMPLETE="true"
}

#################
#  PRUNE FLACS  #
#################
# Clear excess FLAC metadata from each FLAC file
__prune_flacs () {
	__title_prune_flac

	# Abort script and check for any errors thus far
	__prune_abort () {
		__print_interrupt

		# Kill running children
		__kill_jobs

		__newline
		__info "Control-C received, generating summary. Please wait..." ; __newline

		if [[ -f "${PRUNE_ERRORS}" ]] ; then
			__newline >&2
			{ __error "There were issues with some of the FLAC files," ; __newline ;} >&2
			{ __error "please check:" ; __newline ;} >&2
			{ __error "\"${PRUNE_ERRORS}\" for details." ; __newline ;} >&2
		fi

		PRUNE_COMPLETE="interrupt"
		__operation_summary

		exit 1
	}

	# Trap SIGINT (Control-C) to abort cleanly	
	trap __prune_abort SIGINT

	__prune_f () {
		# Let's make sure to kill running children if this
		# function was aborted via SIGINT.  This function
		# will receive SIGTERM from the kill in previous trap
		trap '__kill_jobs ; exit 1' SIGTERM

		# Increment number of FLACs processed
		__increment_count

		__print_prune_flac

		# Check if file is a FLAC file (hide output) and send to
		# background to allow killing on SIGTERM
		metaflac --show-md5sum "${i}" >/dev/null 2>&1 &

		# Wait on background process and return exit code of
		# said process
		wait "${!}"

		# Exit code 130 is SIGINT so only check for exit code '1'
		if [[ "${?}" -eq "1" ]] ; then
			# File is not a FLAC file, display failed
			__print_failed_flac
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: The above file does not appear to be a FLAC file" \
				   "------------------------------------------------------------------" \
				   >> "${PRUNE_ERRORS}"
		else
			# Remove all information but STREAMINFO,VORBIS_COMMENTs, and
			# possibly METADATA_BLOCK_PICTURE
			metaflac --remove --dont-use-padding --except-block-type="${DONT_PRUNE_FLAC_METADATA}" "${i}"

			# File is a FLAC file, display ok
			__print_ok_flac
		fi

		# Print newline into FIFO after completion
		__newline >&3
	}
	
	# Don't remove artwork if user wants it kept.  We don't have to check
	# for the legacy COVERART tag as we are NOT removing any VORBIS_COMMENTs.
	if [[ "${REMOVE_ARTWORK}" == "true" ]] ; then
		# Remove artwork
		DONT_PRUNE_FLAC_METADATA="STREAMINFO,VORBIS_COMMENT"
	else
		# Don't remove artwork
		DONT_PRUNE_FLAC_METADATA="STREAMINFO,PICTURE,VORBIS_COMMENT"
	fi

	# Make sure the temporary file is cleared before proceeding
	__clear_processed_tmp_file

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Start as many processes as determined by ${jobs}
	for i in "${total_flacs_array[@]:0:${jobs}}" ; do
		__prune_f &
	done

	# Add the number of processes started above to count
	ITERATION="${jobs}"

	# If the FLAC files to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if [[ "${TOTAL_FLACS}" -gt "${jobs}" ]] ; then

		# After each newline is read from FIFO, start a new process
		while read ; do
			# If current number of FLACs to process is less than total FLACs
			# found, add another FLAC to process
			if [[ "${ITERATION}" -lt "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				((ITERATION++))
				__prune_f &

			# If current number of FLACs to process is the last FLAC file, continue
			# processing it and break out of loop (to prevent hanging FIFO)
			elif [[ "${ITERATION}" -eq "${TOTAL_FLACS_INDICES}" ]] ; then
				# Set ${i} to current FLAC to process
				i="${total_flacs_array[${ITERATION}]}"
				__prune_f &
				break
			fi
		done <&3

	fi

	# Wait for children processes
	wait

	if [[ -f "${PRUNE_ERRORS}" ]] ; then
		__newline >&2
		{ __error "There were issues with some of the FLAC files," ; __newline ;} >&2
		{ __error "please check:" ; __newline ;} >&2
		{ __error "\"${PRUNE_ERRORS}\" for details." ; __newline ;} >&2
	fi

	# Prune FLACS completed successfully
	PRUNE_COMPLETE="true"
}

#######################
#  DISPLAY LONG HELP  #
#######################
# Display a lot of help
__long_help () {
LONG_HELP="  Usage: ${0} [operations] [options] [target] ...
  Operations:
    -c, --compress
           Compress the FLAC files with the user-specified level of compression
           defined under USER CONFIGURATION (as the variable COMPRESSION_LEVEL)
           and verify the resultant files.

           The default is 8, with the range of values starting from 1 to 8 with
           the smallest compression at 1, and the highest at 8.  This option
           will add a tag to all successfully verified FLAC files.  Below
           shows the default COMPRESSION tag added to each successfully
           verified FLAC:

                       COMPRESSION=8

           If any FLAC files already have the defined COMPRESSION_LEVEL tag (a
           good indicator the files are already compressed at that level), the
           script will instead test the FLAC files for any errors.  This is useful
           to check your entire music library to make sure all the FLAC files are
           compressed at the level specified as well as make sure they are intact.

           If any files are found to be corrupt, this script will quit upon
           finishing the compression of any other files and produce an error
           log.

    -C, --compress-notest
           Same as the '--compress' option, but if any FLAC files already have the
           defined COMPRESSION_LEVEL tag, the script will skip the file and continue
           on to the next without test the FLAC file's integrity.  Useful for
           checking all your FLAC files are compressed at the level specified.

    -t, --test
           Same as compress but instead of compressing the FLAC files, this
           script just verfies the files.  This option will NOT add the
           COMPRESSION tag to the files.

           As with the '--compress' option, this will produce an error log if
           any FLAC files are found to be corrupt.

    -a, --aucdtect
           Uses the auCDtect program by Oleg Berngardt and Alexander Djourik to
           analyze FLAC files and check with fairly accurate precision whether
           the FLAC files are lossy sourced or not.  For example, an MP3 file
           converted to FLAC is no longer lossless therefore lossy sourced.

           While this program isn't foolproof, it gives a good idea which FLAC
           files will need further investigation (ie a spectrogram).  This program
           does not work on FLAC files which have a bit depth more than a typical
           audio CD (16bit), and will skip the files that have a higher bit depth.

           If any files are found to not be perfect (100% CDDA), a log will be created
           with the questionable FLAC files recorded in it.

    -A, --aucdtect-spectrogram
           Same as '-a, --aucdtect' with the addition of creating a spectrogram for
           each FLAC file that fails auCDtect, that is, any FLAC file that does not
           return 100% CDDA from auCDtect will be scanned and a spectrogram will be
           created.

           Any FLAC file skipped (due to having a higher bit depth than 16), will
           NOT have a spectrogram created.

           By default, each spectrogram will be created in the same folder as the
           tested FLAC file with the same name as the tested FLAC file:

               03 - Some FLAC File.flac --> 03 - Some FLAC File.png

           If there already is a PNG file with the same name as the tested FLAC,
           the name 'spectrogram' will prepend the '.png' extension:

               03 - Some FLAC File.flac --> 03 - Some FLAC File.spectrogram.png

           The user can change the location of where to store the created
           spectrogram images by changing the value of SPECTROGRAM_LOCATION under
           the USER CONFIGURATION section of this script.  The location defined by
           the user will be tested to see if it exists before starting the script.
           If the location does NOT exist, the script will warn the user and exit.

           The created PNG file is large in resolution to best capture the
           FLAC file's waveform (roughly 5140x2149).

           The spectrogram is created using the program SoX.  If the user tries
           to use this option without having SoX installed, the script will warn
           the user that SoX is missing and exit.

    -m, --md5check
           Check the FLAC files for unset MD5 Signatures and log the output of
           any unset signatures.  An unset MD5 signature doesn't necessarily mean
           a FLAC file is corrupt, and can be repaired with a re-encoding of said
           FLAC file.

    -p, --prune
           Delete every METADATA block in each FLAC file except the STREAMINFO and
           VORBIS_COMMENT block.  If REMOVE_ARTWORK is set to 'false', then the
           PICTURE block will NOT be removed.

    -g, --replaygain
           Add ReplayGain tags to the FLAC files.  The ReplayGain is calculated
           for ALBUM and TRACK values. ReplayGain is applied via VORBIS_TAGS and
           as such, will require the redo, '--r argument' to have these tags kept
           in order to preserve the added ReplayGain values.  The tags added are:

                      REPLAYGAIN_REFERENCE_LOUDNESS
                      REPLAYGAIN_TRACK_GAIN
                      REPLAYGAIN_TRACK_PEAK
                      REPLAYGAIN_ALBUM_GAIN
                      REPLAYGAIN_ALBUM_PEAK

           This option ignores any ReplayGain tags that may already be set,
           removing existing values before applying new ones.

           In order for the ReplayGain values to be applied correctly, the
           script has to determine which FLAC files to add values by directory.
           What this means is that the script must add the ReplayGain values by
           working off the FLAC files' parent directory.  If there are some FLAC
           files found, the script will move up one directory and begin applying
           the ReplayGain values.  This is necessary in order to get the
           REPLAYGAIN_ALBUM_GAIN and REPLAYGAIN_ALBUM_PEAK values set correctly.
           Without doing this, the ALBUM and TRACK values would be identical.

           If a user has many FLAC files under one directory (of different
           albums/artists), the ReplayGain ALBUM values are going to be incorrect
           as the script will perceive all those FLAC files to essentially be
           from the same album.  This is mitigated by having your music library
           somewhat organized with each album housing the correct FLAC files and
           no others.  Keep in mind, multi-disc albums must be in separate folders
           in order to be processed with different ALBUM GAIN and PEAK values.

           If there are any errors found while creating the ReplayGain values
           and/or setting the values, an error log will be produced.

    -G, --replaygain-noforce
           Same as '-g, --replaygain' but will check for existing ReplayGain
           tags before reapplying new ones.  If any one of the five ReplayGain
           tags are missing from any FLAC file, the script will apply new values
           to each FLAC file in that folder (first removing the old ReplayGain
           tags - if any).

           If all five ReplayGain tags are intact in every FLAC
           file in a directory, that directory will be skipped and no new
           ReplayGain tags will be added.

    -r, --redo
           Extract the configured tags in each FLAC file and clear the rest before
           retagging the file.  The default tags kept are:

                      TITLE
                      ARTIST
                      ALBUM
                      DISCNUMBER
                      DATE
                      TRACKNUMBER
                      TRACKTOTAL
                      GENRE
                      COMPRESSION
                      RELEASETYPE
                      SOURCE
                      MASTERING
                      REPLAYGAIN_REFERENCE_LOUDNESS
                      REPLAYGAIN_TRACK_GAIN
                      REPLAYGAIN_TRACK_PEAK
                      REPLAYGAIN_ALBUM_GAIN
                      REPLAYGAIN_ALBUM_PEAK

           If any FLAC files have missing tags (from those configured to be kept),
           the file and the missing tag will be recorded in a log.

           The tags that can be kept are eseentially infinite, as long as the
           tags to be kept are set in the tag configuration located at the top of
           this script under USER CONFIGURATION.

           If this option is specified, a warning will appear upon script
           execution.  This warning will show which of the configured TAG fields
           to keep when re-tagging the FLAC files.  A countdown will appear
           giving the user 10 seconds to abort the script, after which, the script
           will begin running it's course.

    -l, --all
           This option is short for:

                      -c, --compress
                      -m, --md5check
                      -p, --prune
                      -g, --replaygain
                      -r, --redo

           If any of these options (or variations of the above options) are called, this
           script will warn the user of conflicting options and exit.

    -L, --reallyall
           This option is short for:

                      -c, --compress
                      -m, --md5check
                      -p, --prune
                      -g, --replaygain
                      -r, --redo
                      -A, --aucdtect-spectrogram

           If any of these options (or variations of the above options) are called, this
           script will warn the user of conflicting options and exit.

  Options:
    -j[N], --jobs[=N]
           Set the number of parallel jobs to run on script invocation.  If this is not set,
           this script will attempt to find the number of CPU cores available, using the number
           found as the number of parallel jobs to run.

           If the script is unable to find the number of CPU cores available, the number of jobs
           will be set to two (2) by default.

    -n, --no-color
           Turn off color output.

    -v, --version
           Display script version and exit.

    -h, --help
           Shows this help message."
# End of long help

# Print out help (will be piped to ${PAGER} elsewhere)
printf "%s\n" "${LONG_HELP}"
}

########################
#  DISPLAY SHORT HELP  #
########################
# Display short help
__short_help () {
	printf "%s\n" "   Usage: ${0} [operations] [options] [target] ..."
	printf "%s\n" "   Operations:"
	printf "%s\n" "     -c, --compress"
	printf "%s\n" "     -C, --compress-notest"
	printf "%s\n" "     -t, --test"
	printf "%s\n" "     -m, --md5check"
	printf "%s\n" "     -a, --aucdtect"
	printf "%s\n" "     -A, --aucdtect-spectrogram"
	printf "%s\n" "     -p, --prune"
	printf "%s\n" "     -g, --replaygain"
	printf "%s\n" "     -G, --replaygain-noforce"
	printf "%s\n" "     -r, --redo"
	printf "%s\n" "     -l, --all"
	printf "%s\n" "     -L, --reallyall"
	printf "%s\n" "   Options:"
	printf "%s\n" "     -j[N], --jobs[=N]"
	printf "%s\n" "     -n, --no-color"
	printf "%s\n" "     -v, --version"
	printf "%s\n" "     -h, --help"
	printf "%s\n" "   This is the short help; for details use '${0} --help' or '${0} -h'"
}

###################
#  DISPLAY USAGE  #
###################
__usage () {
	printf "%s\n" "   Usage: ${0} [operations] [options] [target] ..."
}

############################
#  DISPLAY SCRIPT VERSION  #
############################
# Display script version
__print_version () {
	printf "%s\n" "Version ${VERSION}"
}

#####################################
#  DETERMINE NUMBER OF JOBS TO RUN  #
#####################################
__find_cores () {
	# Check if /proc is mounted by comparing device numbers of
	# /proc and / and see if they don't match (ie, /proc is mounted)
	if [[ "$(stat -c %d%D /proc)" == "$(stat -c %d%D /)" ]] ; then
		# /proc is not mounted, default to 2 jobs
		jobs=2
	else
		# /proc is mounted, check for cpuinfo
		if [[ ! -f /proc/cpuinfo ]] ; then
			# /proc/cpuinfo doesn't exist
			jobs=2
		else
			# /proc/cpuinfo exists, find total number
			# of cores to use

			# Store contents of /proc/cpuinfo into
			# cores_array
			mapfile -n0 -t cores_array < /proc/cpuinfo

			# For each line, if matched string is found,
			# add processor number to jobs variable
			for i in "${cores_array[@]}" ; do
				if [[ "${i}" == processor$'\t':\ * ]] ; then
					jobs="${i#processor$'\t': }"
				fi
			done

			# Add +1 to jobs since the number of useable cores
			# starts at 0
			((jobs++))
		fi
	fi
}

##################################
#  DISPLAY COMPLETED OPERATIONS  #
##################################
__operation_summary () {
	# Grab the number of processed FLAC files
	mapfile -n0 processed_flacs_array < "${PROCESSED_TMP_FILE}"

	# Change the number of elements from above array to a variable
	PROCESSED_FLACS_DIGITS="${#processed_flacs_array[@]}"

	# Find the percentage of Processed Flacs / Total Flacs
	PERCENTAGE_DIGITS="$(( ${PROCESSED_FLACS_DIGITS} * 100 / ${TOTAL_FLACS} ))"

	# Set up spacing for Processed Flacs
	case "${#PROCESSED_FLACS_DIGITS}" in
		1)
			PROCESSED_FLAC_SPACING="     "
		;;
		2)
			PROCESSED_FLAC_SPACING="    "
		;;
		3)
			PROCESSED_FLAC_SPACING="   "
		;;
		4)
			PROCESSED_FLAC_SPACING="  "
		;;
		5)
			PROCESSED_FLAC_SPACING=" "
		;;
		6)
			PROCESSED_FLAC_SPACING=""
		;;
	esac

	# Set up spacing for Total Flacs
	case "${#TOTAL_FLACS}" in
		1)
			TOTAL_FLAC_SPACING="     "
		;;
		2)
			TOTAL_FLAC_SPACING="    "
		;;
		3)
			TOTAL_FLAC_SPACING="   "
		;;
		4)
			TOTAL_FLAC_SPACING="  "
		;;
		5)
			TOTAL_FLAC_SPACING=" "
		;;
		6)
			TOTAL_FLAC_SPACING=""
		;;
	esac


	# Set up spacing for Percentage
	case "${#PERCENTAGE_DIGITS}" in
		1)
			PERCENTAGE_SPACING="   "
		;;
		2)
			PERCENTAGE_SPACING="  "
		;;
		3)
			PERCENTAGE_SPACING=" "
		;;
	esac

	# Build the operation line in the Summary Of Operations
	__summary_line () {
		# Set up spacing for Operation
		case "${OPERATION}" in
			"auCDtect")
				OPERATION_SPACING="    "
			;;
			"Compress")
				OPERATION_SPACING="    "
			;;
			"Test Flacs")
				OPERATION_SPACING="  "
			;;
			"MD5 Check")
				OPERATION_SPACING="   "
			;;
			"ReplayGain")
				OPERATION_SPACING="  "
			;;
			"Redo Tags")
				OPERATION_SPACING="   "
			;;
			"Prune Flacs")
				OPERATION_SPACING=" "
			;;
		esac

		case "${OPERATION_SUMMARY}" in
			"complete")
				# Example of printed string below:
				# '   │ MD5 Check   │  Completed  │   104 / 104   │ 100% │'

				# Set up the printed string with colors
				printf "%s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
				\
				"   " "│" " " "${OPERATION}" "${OPERATION_SPACING}" "│" \
				"  " "Completed" "  " "│" \
				"${TOTAL_FLAC_SPACING}" "${TOTAL_FLACS}" \
				" " "/" " " \
				"${TOTAL_FLACS}" "${TOTAL_FLAC_SPACING}" \
				"│" " " "100%" " " "│"
			;;

			"failed")
				# Example of printed string below:
				# '   │ MD5 Check   │   Failed    │   104 / 104   │ 100% │'

				# Set up the printed string with colors
				printf "%s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
				\
				"   " "│" " " "${OPERATION}" "${OPERATION_SPACING}" "│" \
				"   " "Failed" "    " "│" \
				"${TOTAL_FLAC_SPACING}" "${TOTAL_FLACS}" \
				" " "/" " " \
				"${TOTAL_FLACS}" "${TOTAL_FLAC_SPACING}" \
				"│" " " "100%" " " "│"
			;;

			"interrupted")
				# Example of printed string below:
				# '   │ MD5 Check   │ Interrupted │    24 / 104   │  23% │'

				# Set up the printed string with colors
				printf "%s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
				\
				"   " "│" " " "${OPERATION}" "${OPERATION_SPACING}" "│" \
				" " "Interrupted" " " "│" \
				"${PROCESSED_FLAC_SPACING}" "${PROCESSED_FLACS_DIGITS}" \
				" " "/" " " \
				"${TOTAL_FLACS}" "${TOTAL_FLAC_SPACING}" \
				"│" "${PERCENTAGE_SPACING}" "${PERCENTAGE_DIGITS}%" " " "│"
			;;

			"did not run")
				# Example of printed string below:
				# '   │ MD5 Check   │ Did Not Run │     0 / 104   │   0% │'

				# Set up the printed string with colors
				printf "%s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
				\
				"   " "│" " " "${OPERATION}" "${OPERATION_SPACING}" "│" \
				" " "Did Not Run" " " "│" \
				"     " "0" \
				" " "/" " " \
				"${TOTAL_FLACS}" "${TOTAL_FLAC_SPACING}" \
				"│" "   " "0%" " " "│"
			;;

			*)
				# Should not ever happen!
			;;
		esac
	}

	# Begin printing the table
	printf "\n%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "┌───────────────────────────┬──────────────────────┐"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "│" "   Summary Of Operations   " "│" " # Of Processed Flacs " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "├─────────────┬─────────────┼───────────────┬──────┤"

	# auCDtect operations
	if [[ "${AUCDTECT}" == "true" && "${AUCDTECT_COMPLETE}" == "true" ]] ; then
		OPERATION="auCDtect"
		OPERATION_SUMMARY="complete"
		__summary_line
	elif [[ "${AUCDTECT}" == "true" && "${AUCDTECT_COMPLETE}" == "false" ]] ; then
		OPERATION="auCDtect"
		OPERATION_SUMMARY="failed"
		__summary_line
	elif [[ "${AUCDTECT}" == "true" && "${AUCDTECT_COMPLETE}" == "interrupt" ]] ; then
		OPERATION="auCDtect"
		OPERATION_SUMMARY="interrupted"
		__summary_line
	elif [[ "${AUCDTECT}" == "true" ]] ; then
		OPERATION="auCDtect"
		OPERATION_SUMMARY="did not run"
		__summary_line
	fi

	# Compress Flacs operations
	if [[ "${COMPRESS}" == "true" && "${COMPRESS_COMPLETE}" == "true" ]] ; then
		OPERATION="Compress"
		OPERATION_SUMMARY="complete"
		__summary_line
	elif [[ "${COMPRESS}" == "true" && "${COMPRESS_COMPLETE}" == "false" ]] ; then
		OPERATION="Compress"
		OPERATION_SUMMARY="failed"
		__summary_line
	elif [[ "${COMPRESS}" == "true" && "${COMPRESS_COMPLETE}" == "interrupt" ]] ; then
		OPERATION="Compress"
		OPERATION_SUMMARY="interrupted"
		__summary_line
	elif [[ "${COMPRESS}" == "true" ]] ; then
		OPERATION="Compress"
		OPERATION_SUMMARY="did not run"
		__summary_line
	fi

	# Test Flacs operations
	if [[ "${TEST}" == "true" && "${TEST_COMPLETE}" == "true" ]] ; then
		OPERATION="Test Flacs"
		OPERATION_SUMMARY="complete"
		__summary_line
	elif [[ "${TEST}" == "true" && "${TEST_COMPLETE}" == "false" ]] ; then
		OPERATION="Test Flacs"
		OPERATION_SUMMARY="failed"
		__summary_line
	elif [[ "${TEST}" == "true" && "${TEST_COMPLETE}" == "interrupt" ]] ; then
		OPERATION="Test Flacs"
		OPERATION_SUMMARY="interrupted"
		__summary_line
	elif [[ "${TEST}" == "true" ]] ; then
		OPERATION="Test Flacs"
		OPERATION_SUMMARY="did not run"
		__summary_line
	fi

	# MD5 Check operations
	if [[ "${MD5CHECK}" == "true" && "${MD5CHECK_COMPLETE}" == "true" ]] ; then
		OPERATION="MD5 Check"
		OPERATION_SUMMARY="complete"
		__summary_line
	elif [[ "${MD5CHECK}" == "true" && "${MD5CHECK_COMPLETE}" == "false" ]] ; then
		OPERATION="MD5 Check"
		OPERATION_SUMMARY="failed"
		__summary_line
	elif [[ "${MD5CHECK}" == "true" && "${MD5CHECK_COMPLETE}" == "interrupt" ]] ; then
		OPERATION="MD5 Check"
		OPERATION_SUMMARY="interrupted"
		__summary_line
	elif [[ "${MD5CHECK}" == "true" ]] ; then
		OPERATION="MD5 Check"
		OPERATION_SUMMARY="did not run"
		__summary_line
	fi

	# ReplayGain operations
	if [[ "${REPLAYGAIN}" == "true" && "${REPLAYGAIN_COMPLETE}" == "true" ]] ; then
		OPERATION="ReplayGain"
		OPERATION_SUMMARY="complete"
		__summary_line
	elif [[ "${REPLAYGAIN}" == "true" && "${REPLAYGAIN_COMPLETE}" == "false" ]] ; then
		OPERATION="ReplayGain"
		OPERATION_SUMMARY="failed"
		__summary_line
	elif [[ "${REPLAYGAIN}" == "true" && "${REPLAYGAIN_COMPLETE}" == "interrupt" ]] ; then
		OPERATION="ReplayGain"
		OPERATION_SUMMARY="interrupted"
		__summary_line
	elif [[ "${REPLAYGAIN}" == "true" ]] ; then
		OPERATION="ReplayGain"
		OPERATION_SUMMARY="did not run"
		__summary_line
	fi

	# Redo Tags operations
	if [[ "${REDO}" == "true" && "${REDO_COMPLETE}" == "true" ]] ; then
		OPERATION="Redo Tags"
		OPERATION_SUMMARY="complete"
		__summary_line
	elif [[ "${REDO}" == "true" && "${REDO_COMPLETE}" == "false" ]] ; then
		OPERATION="Redo Tags"
		OPERATION_SUMMARY="failed"
		__summary_line
	elif [[ "${REDO}" == "true" && "${REDO_COMPLETE}" == "interrupt" ]] ; then
		OPERATION="Redo Tags"
		OPERATION_SUMMARY="interrupted"
		__summary_line
	elif [[ "${REDO}" == "true" ]] ; then
		OPERATION="Redo Tags"
		OPERATION_SUMMARY="did not run"
		__summary_line
	fi

	# Prune Flacs operations
	if [[ "${PRUNE}" == "true" && "${PRUNE_COMPLETE}" == "true" ]] ; then
		OPERATION="Prune Flacs"
		OPERATION_SUMMARY="complete"
		__summary_line
	elif [[ "${PRUNE}" == "true" && "${PRUNE_COMPLETE}" == "false" ]] ; then
		OPERATION="Prune Flacs"
		OPERATION_SUMMARY="failed"
		__summary_line
	elif [[ "${PRUNE}" == "true" && "${PRUNE_COMPLETE}" == "interrupt" ]] ; then
		OPERATION="Prune Flacs"
		OPERATION_SUMMARY="interrupted"
		__summary_line
	elif [[ "${PRUNE}" == "true" ]] ; then
		OPERATION="Prune Flacs"
		OPERATION_SUMMARY="did not run"
		__summary_line
	fi

	# Below creates the legend
	printf "%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "├─────────────┴─────────────┴───────────────┴──────┤"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "│" "                      Legend                      " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "├──────────────────────────────────────────────────┤"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s\n" \
	"   " "│" "   " "Completed" " " ":" " Entire operation completed without " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "│" "               any issues.                        " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "│" "                                                  " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s\n" \
	"   " "│" "      " "Failed" " " ":" " Entire operation completed, but    " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "│" "               some files have issues.            " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "│" "                                                  " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s\n" \
	"   " "│" " " "Interrupted" " " ":" " Operation halted by user via the   " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "│" "               SIGINT signal (Control-C).         " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "│" "                                                  " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s\n" \
	"   " "│" " " "Did Not Run" " " ":" " Operation did not run due to       " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "│" "               interruption from user or failure  " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "│" "               of the previous operation.         " "│"
	printf "%s${BOLD_BLUE}%s${NORMAL}\n" \
	"   " "└──────────────────────────────────────────────────┘"

	## CLEANUP SECTION ##
	# Remove temporary file
	rm -f "${PROCESSED_TMP_FILE}"

	# Restore old stty settings, make stty happy
	# by redirecting /dev/stderr
	stty ${OLD_STTY} < /dev/stderr
}

#######################
#  PRE-SCRIPT CHECKS  #
#######################
# Make sure we are running BASH 4 or greater
BASH_VERSION_CHECK="${BASH_VERSION%%.*}"
if [[ "${BASH_VERSION_CHECK}" < 4 ]] ; then
	{ __error "You must be running BASH version 4 or greater to use" ; __newline ;} >&2
	{ __error "this program!" ; __newline ;} >&2
	exit 1
fi

	###################################
	#  PROCESS POSITIONAL PARAMETERS  #
	###################################
# If no arguments are made to the script show usage & short help
if [[ "${#}" -eq 0 ]] ; then
	__short_help
	exit 1
fi

# Add case where only one argument is specified
if [[ "${#}" -eq 1 ]] ; then
	case "${1}" in
		--version|-v)
			__print_version
			exit 0
		;;
		--help|-h)
			# Check for ${PAGER}. If a pager is available
			# lets use it. If not, just display help
			if [[ -n "${PAGER}" ]] ; then
				__long_help | "${PAGER}"
				exit 0
			else
				__long_help
				exit 0
			fi
		;;
		*)
			__usage >&2
			exit 1
		;;
	esac
fi

# Add case where two arguments are specified and the
# arguments called are not to have anything after them
if [[ "${#}" -eq 2 ]] ; then
	case "${1}" in
		--no-color|-n)
			__usage >&2
			exit 1
		;;
		--version|-v)
			__usage >&2
			exit 1
		;;
		--help|-h)
			__usage >&2
			exit 1
		;;
	esac
fi

# Separate the long and short style arguments into their
# own arrays as well as capture the last non-arguements, to
# prevent multiple directories being called
for i in "${@}" ; do
	if [[ "${i}" == --* ]] ; then
		long_style_arguments_array+=( "${i}" )
	elif [[ "${i}" == -* ]] ; then
		short_style_arguments_array+=( "${i}" )
	else
		non_arguments_array+=( "${i}" )
	fi
done

# If there are 0 (zero) directories or more than 1, exit script
if [[ "${#non_arguments_array[@]}" -eq 0 || "${#non_arguments_array[@]}" -gt 1 ]] ; then
	__usage >&2
	exit 1
fi

# If there were any long style arguments called, convert them
# to short style in order for getopts to be able to process
# them correctly (ignoring "--help" and "--version" since
# this is taken care of above).  Add invalid arguments to it's
# own array
if [[ -n "${long_style_arguments_array[@]}" ]] ; then
	for i in "${long_style_arguments_array[@]}" ; do
		case "${i}" in
			--compress)
				converted_arguments_array+=( -c )
			;;
			--compress-notest)
				converted_arguments_array+=( -C )
			;;
			--test)
				converted_arguments_array+=( -t )
			;;
			--md5check)
				converted_arguments_array+=( -m )
			;;
			--aucdtect)
				converted_arguments_array+=( -a )
			;;
			--aucdtect-spectrogram)
				converted_arguments_array+=( -A )
			;;
			--prune)
				converted_arguments_array+=( -p )
			;;
			--replaygain)
				converted_arguments_array+=( -g )
			;;
			--replaygain-noforce)
				converted_arguments_array+=( -G )
			;;
			--redo)
				converted_arguments_array+=( -r )
			;;
			--all)
				converted_arguments_array+=( -l )
			;;
			--reallyall)
				converted_arguments_array+=( -L )
			;;
			--no-color)
				converted_arguments_array+=( -n )
			;;
			--jobs=[0-9]*)
				# Set number of jobs to run via the required
				# integer argument after '-j'
				jobs="${i##*=}"
			;;
			--version)
				__usage >&2
				exit 1
			;;
			--help)
				__usage >&2
				exit 1
			;;
			*)
				# Set invalid argument into array
				invalid_arguments_array+=( "${i}" )
			;;
		esac
	done
fi

# If there were any short style arguments called, go through
# them, adding the valid arguments to the "converted_arguments"
# array and adding invalid arguments to it's own array
if [[ -n "${short_style_arguments_array[@]}" ]] ; then
	while getopts ":LlcCtgGaAmprnj:hv" ARGUMENTS "${short_style_arguments_array[@]}" ; do
		case "${ARGUMENTS}" in
			l)
				converted_arguments_array+=( -l )
			;;
			L)
				converted_arguments_array+=( -L )
			;;
			c)
				converted_arguments_array+=( -c )
			;;
			C)
				converted_arguments_array+=( -C )
			;;
			t)
				converted_arguments_array+=( -t )
			;;
			g)
				converted_arguments_array+=( -g )
			;;
			G)
				converted_arguments_array+=( -G )
			;;
			a)
				converted_arguments_array+=( -a )
			;;
			A)
				converted_arguments_array+=( -A )
			;;
			m)
				converted_arguments_array+=( -m )
			;;
			p)
				converted_arguments_array+=( -p )
			;;
			r)
				converted_arguments_array+=( -r )
			;;
			n)
				converted_arguments_array+=( -n )
			;;
			j)
				# Set number of jobs to run via the required
				# integer argument after '-j'
				jobs="${OPTARG}"
				converted_arguments_array+=( -j )
			;;
			h)
				converted_arguments_array+=( -h )
			;;
			v)
				converted_arguments_array+=( -v )
			;;
			:)
				# Currently, this is just for '-j' so we can explicity specify it
				parameter_errors_array+=( "-${OPTARG} requires an integer after it (eg. -${OPTARG}11)." )
			;;
			?)
				# Set invalid argument from getopts into
				# array using ${OPTARG}
				invalid_arguments_array+=( "-${OPTARG}" )
			;;
		esac
	done
fi

# If there were invalid arguments called, display them and
# exit script
if [[ -n "${invalid_arguments_array[@]}" || -n "${parameter_errors_array[@]}" ]] ; then
	__usage >&2

	if [[ -n "${invalid_arguments_array[@]}" ]] ; then
		__newline >&2
		__error "Invalid options:" >&2

		for i in "${invalid_arguments_array[@]}" ; do
			printf "%s" " ${i}" >&2
		done

		__newline >&2
	fi

	if [[ -n "${parameter_errors_array[@]}" ]] ; then
		__newline >&2

		for i in "${parameter_errors_array[@]}" ; do
			{ __error "${i}" ; __newline ;} >&2
		done
	fi

	exit 1
fi

# Run through all the converted arguments and set up the correct
# values based on what the user called, thereby allowing the
# script to process said values and execute the corresponding
# functions
for i in "${converted_arguments_array[@]}" ; do
	case "${i}" in
		-l)
			ALL="true"
		;;
		-L)
			REALLYALL="true"
		;;
		-c)
			COMPRESS="true"
			COMPRESS_TEST="true"
		;;
		-C)
			COMPRESS="true"
			SKIP_TEST="true"
		;;
		-t)
			TEST="true"
		;;
		-g)
			REPLAYGAIN="true"
			# Below used only once to test for
			# command compatibility
			REPLAYGAIN_FORCE="true"
		;;
		-G)
			REPLAYGAIN="true"
			REPLAYGAIN_NOFORCE="true"
		;;
		-a)
			AUCDTECT="true"
			NO_SPECTROGRAM="true"
		;;
		-A)
			AUCDTECT="true"
			CREATE_SPECTROGRAM="true"
		;;
		-m)
			MD5CHECK="true"
		;;
		-p)
			PRUNE="true"
		;;
		-r)
			REDO="true"
		;;
		-n)
			NO_COLOR="true"
		;;
		-j)
			# Do nothing, ${jobs} has already been stored
			# in previous getopts loop
			:
		;;
		-v)
			__usage >&2
			exit 1
		;;
		-h)
			__usage >&2
			exit 1
		;;
		*)
			# Should not ever happen!
			{ __error "This is a BUG! Please report to:" ; __newline ;} >&2
			{ printf "%s\n" "   https://github.com/sirjaren/redoflacs/issues/new" ;} >&2

			exit 1
		;;
	esac
done

# Put all the called arguments into an array
called_arguments_array=( "${@}" )

# Set the last argument as the directory and remove the
# ending slash (if any) to prevent double slashes from
# appearing because of BASH's globstar.
#
# This only appears if the directory chosen is the direct
# parent directory to the FLAC files to be processed.
#
# BASH 4.2 allows negative indices (ie):
#
# DIRECTORY="${called_arguments_array[-1]%/}"
DIRECTORY="${called_arguments_array[$(( ${#called_arguments_array[@]} - 1 ))]%/}"

	###############################
	#  END POSITIONAL PARAMETERS  #
	###############################

# This must come before the other options in
# order for it to take effect
if [[ "${NO_COLOR}" == "true" ]] ; then
	BOLD_BLUE=""
	BOLD_GREEN=""
	BOLD_RED=""
	CYAN=""
	MAGENTA=""
	YELLOW=""
	NORMAL=""
fi

# Check whether DIRECTORY exists
if [[ ! -d "${DIRECTORY}" ]] ; then
	{ printf "%s\n" "  Usage: ${0} [OPTION] [PATH_TO_FLAC(s)]..." ;} >&2
	{ __error "Please specify a directory!" ; __newline ;} >&2

	exit 1
fi

# Check to make sure script has all the dependencies
# necessary to complete script succesfully
# Check if each command can be found in $PATH
SLEEP_EXISTS="$(command -v sleep)"
STTY_EXISTS="$(command -v stty)"
STAT_EXISTS="$(command -v stat)"
MKFIFO_EXISTS="$(command -v mkfifo)"
METAFLAC_EXISTS="$(command -v metaflac)"
FLAC_EXISTS="$(command -v flac)"

# Go through and test if each command was found (by displaying its $PATH).  If
# it's empty, add where you can find the package to an array to be displayed.
if [[ -z "${SLEEP_EXISTS}" ]] ; then
	command_exists_array+=( "You can generally install \"sleep\" with the \"coreutils\" package." )
fi

if [[ -z "${STTY_EXISTS}" ]] ; then
	command_exists_array+=( "You can generally install \"stty\" with the \"coreutils\" package." )
fi

if [[ -z "${STAT_EXISTS}" ]] ; then
	command_exists_array+=( "You can generally install \"stat\" with the \"coreutils\" package." )
fi

if [[ -z "${MKFIFO_EXISTS}" ]] ; then
	command_exists_array+=( "You can generally install \"mkfifo\" with the \"coreutils\" package." )
fi

if [[ -z "${METAFLAC_EXISTS}" ]] ; then
	command_exists_array+=( "You can generally install \"metaflac\" with the \"flac\" package." )
fi

if [[ -z "${FLAC_EXISTS}" ]] ; then
	command_exists_array+=( "You can generally install \"flac\" with the \"flac\" package." )
fi

# Display (in bold red) message that system is missing vital programs
__display_missing_commands_header () {
	{ __error "You seem to be missing one or more necessary programs" ; __newline ;} >&2
	{ __error "to run this script reliably.  Below shows the program(s)" ; __newline ;} >&2
	{ __error "missing, as well as where you can install them from:" ; __newline 2 ;} >&2
}

# If all the programs above were found, continue with script.  Else
# display warning and exit script, printing out which package has
# the missing programs
if [[ -n "${command_exists_array[@]}" ]] ; then
	__display_missing_commands_header
	# Iterate through array and print each value
	for i in "${command_exists_array[@]}" ; do
		{ __warn "${i}" ; __newline ;} >&2
	done
	exit 1
fi

# If "-l, --all" and "-L, --reallyall" are both called, warn and exit
if [[ "${ALL}" == "true" && "${REALLYALL}" == "true" ]] ; then
	{ __error "Running both \"-l, --all\" and \"-L, --reallyall\" conflict!" ; __newline ;} >&2
	{ __error "Please choose one or the other." ; __newline ;} >&2

	exit 1
fi

# If "-l, --all" or "-L, --reallyall" was called, check if arguments
# were called that already will be performed by the above argument(s).
# If any were called, display a warning and exit the script
if [[ "${ALL}" == "true" || "${REALLYALL}" == "true" ]] ; then

	# Check for "-c, --compress".  If used add it to array
	if [[ "${COMPRESS}" == "true" && "${SKIP_TEST}" == "false" ]] ; then
		argument_conflict_array+=( "-c, --compress" )
	# Check for "-C, --compress-notest".  If used add it to array
	elif [[ "${COMPRESS}" == "true" && "${SKIP_TEST}" == "true" ]] ; then
		argument_conflict_array+=( "-C, --compress-notest" )
	fi

	# Check for "-t, --test".  If used add it to array
	if [[ "${TEST}" == "true" ]] ; then
		argument_conflict_array+=( "-t, --test" )
	fi

	# Check for "-m, --md5check".  If used add it to array
	if [[ "${MD5CHECK}" == "true" ]] ; then
		argument_conflict_array+=( "-m, --md5check" )
	fi

	# Check for "-p, --prune".  If used add it to array
	if [[ "${PRUNE}" == "true" ]] ; then
		argument_conflict_array+=( "-p, --prune" )
	fi

	# Check for "-g, --replaygain".  If used add it to array
	if [[ "${REPLAYGAIN}" == "true" && "${REPLAYGAIN_NOFORCE}" != "true" ]] ; then
		argument_conflict_array+=( "-g, --replaygain" )
	# Check for "-G, --replaygain-noforce".  If used add it to array
	elif [[ "${REPLAYGAIN}" == "true" && "${REPLAYGAIN_NOFORCE}" == "true" ]] ; then
		argument_conflict_array+=( "-G, --replaygain-noforce" )
	fi

	# Check for "-r, --redo".  If used add it to array
	if [[ "${REDO}" == "true" ]] ; then
		argument_conflict_array+=( "-r, --redo" )
	fi

	# If "-L, --reallyall" was called, check for the various forms of calling
	# auCDtect.  If it was called, add it to array
	if [[ "${REALLYALL}" == "true" ]] ; then
		if [[ "${AUCDTECT}" == "true" && "${CREATE_SPECTROGRAM}" == "true" ]] ; then
			argument_conflict_array+=( "-A, --aucdtect-spectrogram" )
		elif [[ "${AUCDTECT}" == "true" && "${CREATE_SPECTROGRAM}" != "true" ]] ; then
			argument_conflict_array+=( "-a, --aucdtect" )
		fi
	fi

	# If the array is not empty, the user called some incompatible options with
	# "-l, --all" or "-L, --reallyall", so print which options were called that
	# are incompatible and exit script
	if [[ -n "${argument_conflict_array[@]}" ]] ; then
		# "-l, --all"
		if [[ "${ALL}" == "true" ]] ; then
			{ __error "The below options conflict with \"-l, --all\"" ; __newline ;} >&2
		# "-L, --reallyall"
		elif [[ "${REALLYALL}" == "true" ]] ; then
			{ __error "The below options conflict with \"-L, --reallyall\"" ; __newline ;} >&2
		fi

		# Iterate through array and print each value
		for i in "${argument_conflict_array[@]}" ; do
			{ __error "     ${i}" ; __newline ;} >&2
		done

		{ __error "Please remove incompatible options." ; __newline ;} >&2

		exit 1
	fi
fi

# If "-C, --compress-notest" and "-c, --compress" are both called, warn and exit
if [[ "${SKIP_TEST}" == "true" && "${COMPRESS_TEST}" == "true" ]] ; then
	{ __error "Running both \"-c, --compress\" and \"-C, --compress-notest\" conflict!" ; __newline ;} >&2
	{ __error "Please choose one or the other." ; __newline ;} >&2
	exit 1
fi

# If "-c, --compress" and "-t, --test" are both called, warn and exit
if [[ "${COMPRESS_TEST}" == "true" && "${TEST}" == "true" ]] ; then
	{ __error "Running both \"-c, --compress\" and \"-t, --test\" conflict!" ; __newline ;} >&2
	{ __error "Please choose one or the other." ; __newline ;} >&2
	exit 1
fi

# If "-g, --replaygain" and "-G, --replaygain-noforce" are both called, warn and exit
if [[ "${REPLAYGAIN_FORCE}" == "true" && "${REPLAYGAIN_NOFORCE}" == "true" ]] ; then
	{ __error "Running both \"-g, --replaygain\" and \"-G, --replaygain-noforce\" conflict!" ; __newline ;} >&2
	{ __error "Please choose one or the other." ; __newline ;} >&2
	exit 1
fi

# If "-a, --aucdtect" and "-A, --aucdtect-spectrogram" are both called, warn and exit
if [[ "${NO_SPECTROGRAM}" == "true"  && "${CREATE_SPECTROGRAM}" == "true" ]] ; then
	{ __error "Running both \"-a, --aucdtect\" and \"-A, --aucdtect-spectrogram\" conflict!" ; __newline ;} >&2
	{ __error "Please choose one or the other." ; __newline ;} >&2
	exit 1
fi

# Check for at least 1 FLAC file
read -r FIND_FLACS < <( printf "%s\n" "${DIRECTORY}"/**/*${FLAC_EXTENSION} )

# No FLAC files found
if [[ ! -f "${FIND_FLACS}" ]] ; then
	__no_flacs
	exit 1
fi

# If ${jobs} wasn't set upon invocation, check in /proc
# to see how many jobs should be run
if [[ -z "${jobs}" ]] ; then
	__find_cores
fi

###########################
#  END PRE-SCRIPT CHECKS  #
###########################

##################
#  BEGIN SCRIPT  #
##################
# Store current stty settings
OLD_STTY="$(stty -g)"

# Prevent Control-C from displaying '^C'.  May already be set
stty -ctlecho 2> /dev/null

# Temporary FIFO location
TMP_FIFO="/tmp/redoflacs_fifo_$$"

# Temporary processed files location
PROCESSED_TMP_FILE="/tmp/redoflacs_tmpfile_$$"

# Force all the tag fields to be uppercase
tags=( "${tags[@]^^}" )

# Copy the above 'tag' array because we will need to use it
# later as we are _may_ add a temporary element to the
# 'tag' array
old_tags=( "${tags[@]}" )

# Display the top banner
if [[ "${REDO}" != "true" ]] ; then
	# Display top banner (in background to allow
	# the script to continue processing
	__top_banner
else
	# Check for coverart conflicts and display
	# top banner
	__coverart_remove_conflict
	__top_banner
fi

# Grab the total flacs to process
total_flacs_array=( "${DIRECTORY}"/**/*${FLAC_EXTENSION} )

# Grab the total number of FLACs found
TOTAL_FLACS="${#total_flacs_array[@]}"

# Grab the total number of indices of above array
TOTAL_FLACS_INDICES="$(( ${#total_flacs_array[@]} - 1 ))"

# Initialize / Clear the temporary file
> "${PROCESSED_TMP_FILE}"

# If "-l, --all" or "-L, --reallyall" was called,
# enable the various arguments to allow script to
# run them
if [[ "${ALL}" == "true" ]] ; then
	COMPRESS="true"
	MD5CHECK="true"
	PRUNE="true"
	REPLAYGAIN="true"
	REDO="true"
elif [[ "${REALLYALL}" == "true" ]] ; then
	COMPRESS="true"
	MD5CHECK="true"
	PRUNE="true"
	REPLAYGAIN="true"
	REDO="true"
	AUCDTECT="true"
	# This is needed to let script know that we want auCDtect
	# to create a spectrogram (ie "-A, --aucdtect-spectrogram")
	CREATE_SPECTROGRAM="true"
fi

# The below order is probably the best bet in ensuring time
# isn't wasted on doing unnecessary operations if the
# FLAC files are corrupt or have metadata issues
if [[ "${AUCDTECT}" == "true" ]] ; then
	# Check if auCDtect is found/installed
	AUCDTECT_COMMAND="$(command -v auCDtect)"
	if [[ -z "${AUCDTECT_COMMAND}" ]] ; then
		# Check alternate spelling
		AUCDTECT_COMMAND="$(command -v aucdtect)"
	fi

	if [[ -n "${AUCDTECT_COMMAND}" ]] ; then
		# If "-A, --aucdtect-spectrogram" was called
		# make sure SoX is installed before starting
		if [[ "${CREATE_SPECTROGRAM}" == "true" ]] ; then
			SOX_COMMAND="$(command -v sox)"
			if [[ -z "${SOX_COMMAND}" ]] ; then
				# SoX can't be found, exit
				{ __error "It appears SoX is not installed. Please verify you" ; __newline ;} >&2
				{ __error "have this program installed and can be found in \$PATH" ; __newline ;} >&2

				exit 1
			fi
		fi

		# Run auCDtect function/command
		__aucdtect
	else
		# auCDtect can't be found, exit
		{ __error "It appears auCDtect is not installed. Please verify you" ; __newline ;} >&2
		{ __error "have this program installed and can be found in \$PATH" ; __newline ;} >&2

		exit 1
	fi
fi

if [[ "${COMPRESS}" == "true" ]] ; then
	__compress_flacs
fi

if [[ "${TEST}" == "true" ]] ; then
	__test_flacs
fi

if [[ "${MD5CHECK}" == "true" ]] ; then
	__md5_check
fi

if [[ "${REPLAYGAIN}" == "true" ]] ; then
	__replaygain
fi

if [[ "${REDO}" == "true" ]] ; then
	__redo_tags
fi

if [[ "${PRUNE}" == "true" ]] ; then
	__prune_flacs
fi

# Display warning about legacy COVERART tag, if applicable
if [[ "${COVERART_WARNING}" == "true" ]] ; then
	printf ''
	__coverart_warning
fi

# Display summary of completed tasks
__operation_summary

exit 0
################
#  END SCRIPT  #
################
